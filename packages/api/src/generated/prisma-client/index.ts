// Code generated by Prisma (prisma@1.34.3). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  aboutUs: (where?: AboutUsWhereInput) => Promise<boolean>;
  admin: (where?: AdminWhereInput) => Promise<boolean>;
  appointment: (where?: AppointmentWhereInput) => Promise<boolean>;
  blog: (where?: BlogWhereInput) => Promise<boolean>;
  blogComment: (where?: BlogCommentWhereInput) => Promise<boolean>;
  blogPost: (where?: BlogPostWhereInput) => Promise<boolean>;
  city: (where?: CityWhereInput) => Promise<boolean>;
  contactUs: (where?: ContactUsWhereInput) => Promise<boolean>;
  country: (where?: CountryWhereInput) => Promise<boolean>;
  disease: (where?: DiseaseWhereInput) => Promise<boolean>;
  diseaseCovered: (where?: DiseaseCoveredWhereInput) => Promise<boolean>;
  doctor: (where?: DoctorWhereInput) => Promise<boolean>;
  doctorOld: (where?: DoctorOldWhereInput) => Promise<boolean>;
  doctorShedule: (where?: DoctorSheduleWhereInput) => Promise<boolean>;
  doctorSheduleTime: (where?: DoctorSheduleTimeWhereInput) => Promise<boolean>;
  doctorsRating: (where?: DoctorsRatingWhereInput) => Promise<boolean>;
  drShedule: (where?: DrSheduleWhereInput) => Promise<boolean>;
  emailSubscription: (where?: EmailSubscriptionWhereInput) => Promise<boolean>;
  facility: (where?: FacilityWhereInput) => Promise<boolean>;
  hospital: (where?: HospitalWhereInput) => Promise<boolean>;
  hospitalFacility: (where?: HospitalFacilityWhereInput) => Promise<boolean>;
  hospitalRating: (where?: HospitalRatingWhereInput) => Promise<boolean>;
  illness: (where?: IllnessWhereInput) => Promise<boolean>;
  insurance: (where?: InsuranceWhereInput) => Promise<boolean>;
  insuranceCategory: (where?: InsuranceCategoryWhereInput) => Promise<boolean>;
  job: (where?: JobWhereInput) => Promise<boolean>;
  language: (where?: LanguageWhereInput) => Promise<boolean>;
  message: (where?: MessageWhereInput) => Promise<boolean>;
  migration: (where?: MigrationWhereInput) => Promise<boolean>;
  offer: (where?: OfferWhereInput) => Promise<boolean>;
  onlineAppointment: (where?: OnlineAppointmentWhereInput) => Promise<boolean>;
  onlineDoctor: (where?: OnlineDoctorWhereInput) => Promise<boolean>;
  onlineRating: (where?: OnlineRatingWhereInput) => Promise<boolean>;
  optTime: (where?: OptTimeWhereInput) => Promise<boolean>;
  page: (where?: PageWhereInput) => Promise<boolean>;
  passwordReset: (where?: PasswordResetWhereInput) => Promise<boolean>;
  patient: (where?: PatientWhereInput) => Promise<boolean>;
  postImage: (where?: PostImageWhereInput) => Promise<boolean>;
  searchDesign: (where?: SearchDesignWhereInput) => Promise<boolean>;
  sheduleTime: (where?: SheduleTimeWhereInput) => Promise<boolean>;
  slider: (where?: SliderWhereInput) => Promise<boolean>;
  speciality: (where?: SpecialityWhereInput) => Promise<boolean>;
  translation: (where?: TranslationWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
  videoRequest: (where?: VideoRequestWhereInput) => Promise<boolean>;
  visitor: (where?: VisitorWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  aboutUs: (where: AboutUsWhereUniqueInput) => AboutUsNullablePromise;
  aboutUses: (args?: {
    where?: AboutUsWhereInput;
    orderBy?: AboutUsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<AboutUs>;
  aboutUsesConnection: (args?: {
    where?: AboutUsWhereInput;
    orderBy?: AboutUsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => AboutUsConnectionPromise;
  admin: (where: AdminWhereUniqueInput) => AdminNullablePromise;
  admins: (args?: {
    where?: AdminWhereInput;
    orderBy?: AdminOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Admin>;
  adminsConnection: (args?: {
    where?: AdminWhereInput;
    orderBy?: AdminOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => AdminConnectionPromise;
  appointment: (
    where: AppointmentWhereUniqueInput
  ) => AppointmentNullablePromise;
  appointments: (args?: {
    where?: AppointmentWhereInput;
    orderBy?: AppointmentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Appointment>;
  appointmentsConnection: (args?: {
    where?: AppointmentWhereInput;
    orderBy?: AppointmentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => AppointmentConnectionPromise;
  blog: (where: BlogWhereUniqueInput) => BlogNullablePromise;
  blogs: (args?: {
    where?: BlogWhereInput;
    orderBy?: BlogOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Blog>;
  blogsConnection: (args?: {
    where?: BlogWhereInput;
    orderBy?: BlogOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => BlogConnectionPromise;
  blogComment: (
    where: BlogCommentWhereUniqueInput
  ) => BlogCommentNullablePromise;
  blogComments: (args?: {
    where?: BlogCommentWhereInput;
    orderBy?: BlogCommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<BlogComment>;
  blogCommentsConnection: (args?: {
    where?: BlogCommentWhereInput;
    orderBy?: BlogCommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => BlogCommentConnectionPromise;
  blogPost: (where: BlogPostWhereUniqueInput) => BlogPostNullablePromise;
  blogPosts: (args?: {
    where?: BlogPostWhereInput;
    orderBy?: BlogPostOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<BlogPost>;
  blogPostsConnection: (args?: {
    where?: BlogPostWhereInput;
    orderBy?: BlogPostOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => BlogPostConnectionPromise;
  city: (where: CityWhereUniqueInput) => CityNullablePromise;
  cities: (args?: {
    where?: CityWhereInput;
    orderBy?: CityOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<City>;
  citiesConnection: (args?: {
    where?: CityWhereInput;
    orderBy?: CityOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CityConnectionPromise;
  contactUs: (where: ContactUsWhereUniqueInput) => ContactUsNullablePromise;
  contactUses: (args?: {
    where?: ContactUsWhereInput;
    orderBy?: ContactUsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ContactUs>;
  contactUsesConnection: (args?: {
    where?: ContactUsWhereInput;
    orderBy?: ContactUsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ContactUsConnectionPromise;
  country: (where: CountryWhereUniqueInput) => CountryNullablePromise;
  countries: (args?: {
    where?: CountryWhereInput;
    orderBy?: CountryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Country>;
  countriesConnection: (args?: {
    where?: CountryWhereInput;
    orderBy?: CountryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CountryConnectionPromise;
  disease: (where: DiseaseWhereUniqueInput) => DiseaseNullablePromise;
  diseases: (args?: {
    where?: DiseaseWhereInput;
    orderBy?: DiseaseOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Disease>;
  diseasesConnection: (args?: {
    where?: DiseaseWhereInput;
    orderBy?: DiseaseOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => DiseaseConnectionPromise;
  diseaseCovered: (
    where: DiseaseCoveredWhereUniqueInput
  ) => DiseaseCoveredNullablePromise;
  diseaseCovereds: (args?: {
    where?: DiseaseCoveredWhereInput;
    orderBy?: DiseaseCoveredOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<DiseaseCovered>;
  diseaseCoveredsConnection: (args?: {
    where?: DiseaseCoveredWhereInput;
    orderBy?: DiseaseCoveredOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => DiseaseCoveredConnectionPromise;
  doctor: (where: DoctorWhereUniqueInput) => DoctorNullablePromise;
  doctors: (args?: {
    where?: DoctorWhereInput;
    orderBy?: DoctorOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Doctor>;
  doctorsConnection: (args?: {
    where?: DoctorWhereInput;
    orderBy?: DoctorOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => DoctorConnectionPromise;
  doctorOld: (where: DoctorOldWhereUniqueInput) => DoctorOldNullablePromise;
  doctorOlds: (args?: {
    where?: DoctorOldWhereInput;
    orderBy?: DoctorOldOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<DoctorOld>;
  doctorOldsConnection: (args?: {
    where?: DoctorOldWhereInput;
    orderBy?: DoctorOldOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => DoctorOldConnectionPromise;
  doctorShedule: (
    where: DoctorSheduleWhereUniqueInput
  ) => DoctorSheduleNullablePromise;
  doctorShedules: (args?: {
    where?: DoctorSheduleWhereInput;
    orderBy?: DoctorSheduleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<DoctorShedule>;
  doctorShedulesConnection: (args?: {
    where?: DoctorSheduleWhereInput;
    orderBy?: DoctorSheduleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => DoctorSheduleConnectionPromise;
  doctorSheduleTime: (
    where: DoctorSheduleTimeWhereUniqueInput
  ) => DoctorSheduleTimeNullablePromise;
  doctorSheduleTimes: (args?: {
    where?: DoctorSheduleTimeWhereInput;
    orderBy?: DoctorSheduleTimeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<DoctorSheduleTime>;
  doctorSheduleTimesConnection: (args?: {
    where?: DoctorSheduleTimeWhereInput;
    orderBy?: DoctorSheduleTimeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => DoctorSheduleTimeConnectionPromise;
  doctorsRating: (
    where: DoctorsRatingWhereUniqueInput
  ) => DoctorsRatingNullablePromise;
  doctorsRatings: (args?: {
    where?: DoctorsRatingWhereInput;
    orderBy?: DoctorsRatingOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<DoctorsRating>;
  doctorsRatingsConnection: (args?: {
    where?: DoctorsRatingWhereInput;
    orderBy?: DoctorsRatingOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => DoctorsRatingConnectionPromise;
  drShedule: (where: DrSheduleWhereUniqueInput) => DrSheduleNullablePromise;
  drShedules: (args?: {
    where?: DrSheduleWhereInput;
    orderBy?: DrSheduleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<DrShedule>;
  drShedulesConnection: (args?: {
    where?: DrSheduleWhereInput;
    orderBy?: DrSheduleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => DrSheduleConnectionPromise;
  emailSubscription: (
    where: EmailSubscriptionWhereUniqueInput
  ) => EmailSubscriptionNullablePromise;
  emailSubscriptions: (args?: {
    where?: EmailSubscriptionWhereInput;
    orderBy?: EmailSubscriptionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<EmailSubscription>;
  emailSubscriptionsConnection: (args?: {
    where?: EmailSubscriptionWhereInput;
    orderBy?: EmailSubscriptionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => EmailSubscriptionConnectionPromise;
  facility: (where: FacilityWhereUniqueInput) => FacilityNullablePromise;
  facilities: (args?: {
    where?: FacilityWhereInput;
    orderBy?: FacilityOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Facility>;
  facilitiesConnection: (args?: {
    where?: FacilityWhereInput;
    orderBy?: FacilityOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FacilityConnectionPromise;
  hospital: (where: HospitalWhereUniqueInput) => HospitalNullablePromise;
  hospitals: (args?: {
    where?: HospitalWhereInput;
    orderBy?: HospitalOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Hospital>;
  hospitalsConnection: (args?: {
    where?: HospitalWhereInput;
    orderBy?: HospitalOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => HospitalConnectionPromise;
  hospitalFacility: (
    where: HospitalFacilityWhereUniqueInput
  ) => HospitalFacilityNullablePromise;
  hospitalFacilities: (args?: {
    where?: HospitalFacilityWhereInput;
    orderBy?: HospitalFacilityOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<HospitalFacility>;
  hospitalFacilitiesConnection: (args?: {
    where?: HospitalFacilityWhereInput;
    orderBy?: HospitalFacilityOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => HospitalFacilityConnectionPromise;
  hospitalRating: (
    where: HospitalRatingWhereUniqueInput
  ) => HospitalRatingNullablePromise;
  hospitalRatings: (args?: {
    where?: HospitalRatingWhereInput;
    orderBy?: HospitalRatingOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<HospitalRating>;
  hospitalRatingsConnection: (args?: {
    where?: HospitalRatingWhereInput;
    orderBy?: HospitalRatingOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => HospitalRatingConnectionPromise;
  illness: (where: IllnessWhereUniqueInput) => IllnessNullablePromise;
  illnesses: (args?: {
    where?: IllnessWhereInput;
    orderBy?: IllnessOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Illness>;
  illnessesConnection: (args?: {
    where?: IllnessWhereInput;
    orderBy?: IllnessOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => IllnessConnectionPromise;
  insurance: (where: InsuranceWhereUniqueInput) => InsuranceNullablePromise;
  insurances: (args?: {
    where?: InsuranceWhereInput;
    orderBy?: InsuranceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Insurance>;
  insurancesConnection: (args?: {
    where?: InsuranceWhereInput;
    orderBy?: InsuranceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => InsuranceConnectionPromise;
  insuranceCategory: (
    where: InsuranceCategoryWhereUniqueInput
  ) => InsuranceCategoryNullablePromise;
  insuranceCategories: (args?: {
    where?: InsuranceCategoryWhereInput;
    orderBy?: InsuranceCategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<InsuranceCategory>;
  insuranceCategoriesConnection: (args?: {
    where?: InsuranceCategoryWhereInput;
    orderBy?: InsuranceCategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => InsuranceCategoryConnectionPromise;
  job: (where: JobWhereUniqueInput) => JobNullablePromise;
  jobs: (args?: {
    where?: JobWhereInput;
    orderBy?: JobOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Job>;
  jobsConnection: (args?: {
    where?: JobWhereInput;
    orderBy?: JobOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => JobConnectionPromise;
  language: (where: LanguageWhereUniqueInput) => LanguageNullablePromise;
  languages: (args?: {
    where?: LanguageWhereInput;
    orderBy?: LanguageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Language>;
  languagesConnection: (args?: {
    where?: LanguageWhereInput;
    orderBy?: LanguageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => LanguageConnectionPromise;
  message: (where: MessageWhereUniqueInput) => MessageNullablePromise;
  messages: (args?: {
    where?: MessageWhereInput;
    orderBy?: MessageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Message>;
  messagesConnection: (args?: {
    where?: MessageWhereInput;
    orderBy?: MessageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => MessageConnectionPromise;
  migration: (where: MigrationWhereUniqueInput) => MigrationNullablePromise;
  migrations: (args?: {
    where?: MigrationWhereInput;
    orderBy?: MigrationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Migration>;
  migrationsConnection: (args?: {
    where?: MigrationWhereInput;
    orderBy?: MigrationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => MigrationConnectionPromise;
  offer: (where: OfferWhereUniqueInput) => OfferNullablePromise;
  offers: (args?: {
    where?: OfferWhereInput;
    orderBy?: OfferOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Offer>;
  offersConnection: (args?: {
    where?: OfferWhereInput;
    orderBy?: OfferOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => OfferConnectionPromise;
  onlineAppointment: (
    where: OnlineAppointmentWhereUniqueInput
  ) => OnlineAppointmentNullablePromise;
  onlineAppointments: (args?: {
    where?: OnlineAppointmentWhereInput;
    orderBy?: OnlineAppointmentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<OnlineAppointment>;
  onlineAppointmentsConnection: (args?: {
    where?: OnlineAppointmentWhereInput;
    orderBy?: OnlineAppointmentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => OnlineAppointmentConnectionPromise;
  onlineDoctor: (
    where: OnlineDoctorWhereUniqueInput
  ) => OnlineDoctorNullablePromise;
  onlineDoctors: (args?: {
    where?: OnlineDoctorWhereInput;
    orderBy?: OnlineDoctorOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<OnlineDoctor>;
  onlineDoctorsConnection: (args?: {
    where?: OnlineDoctorWhereInput;
    orderBy?: OnlineDoctorOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => OnlineDoctorConnectionPromise;
  onlineRating: (
    where: OnlineRatingWhereUniqueInput
  ) => OnlineRatingNullablePromise;
  onlineRatings: (args?: {
    where?: OnlineRatingWhereInput;
    orderBy?: OnlineRatingOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<OnlineRating>;
  onlineRatingsConnection: (args?: {
    where?: OnlineRatingWhereInput;
    orderBy?: OnlineRatingOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => OnlineRatingConnectionPromise;
  optTime: (where: OptTimeWhereUniqueInput) => OptTimeNullablePromise;
  optTimes: (args?: {
    where?: OptTimeWhereInput;
    orderBy?: OptTimeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<OptTime>;
  optTimesConnection: (args?: {
    where?: OptTimeWhereInput;
    orderBy?: OptTimeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => OptTimeConnectionPromise;
  page: (where: PageWhereUniqueInput) => PageNullablePromise;
  pages: (args?: {
    where?: PageWhereInput;
    orderBy?: PageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Page>;
  pagesConnection: (args?: {
    where?: PageWhereInput;
    orderBy?: PageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PageConnectionPromise;
  passwordReset: (
    where: PasswordResetWhereUniqueInput
  ) => PasswordResetNullablePromise;
  passwordResets: (args?: {
    where?: PasswordResetWhereInput;
    orderBy?: PasswordResetOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<PasswordReset>;
  passwordResetsConnection: (args?: {
    where?: PasswordResetWhereInput;
    orderBy?: PasswordResetOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PasswordResetConnectionPromise;
  patient: (where: PatientWhereUniqueInput) => PatientNullablePromise;
  patients: (args?: {
    where?: PatientWhereInput;
    orderBy?: PatientOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Patient>;
  patientsConnection: (args?: {
    where?: PatientWhereInput;
    orderBy?: PatientOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PatientConnectionPromise;
  postImage: (where: PostImageWhereUniqueInput) => PostImageNullablePromise;
  postImages: (args?: {
    where?: PostImageWhereInput;
    orderBy?: PostImageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<PostImage>;
  postImagesConnection: (args?: {
    where?: PostImageWhereInput;
    orderBy?: PostImageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PostImageConnectionPromise;
  searchDesign: (
    where: SearchDesignWhereUniqueInput
  ) => SearchDesignNullablePromise;
  searchDesigns: (args?: {
    where?: SearchDesignWhereInput;
    orderBy?: SearchDesignOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<SearchDesign>;
  searchDesignsConnection: (args?: {
    where?: SearchDesignWhereInput;
    orderBy?: SearchDesignOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => SearchDesignConnectionPromise;
  sheduleTime: (
    where: SheduleTimeWhereUniqueInput
  ) => SheduleTimeNullablePromise;
  sheduleTimes: (args?: {
    where?: SheduleTimeWhereInput;
    orderBy?: SheduleTimeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<SheduleTime>;
  sheduleTimesConnection: (args?: {
    where?: SheduleTimeWhereInput;
    orderBy?: SheduleTimeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => SheduleTimeConnectionPromise;
  slider: (where: SliderWhereUniqueInput) => SliderNullablePromise;
  sliders: (args?: {
    where?: SliderWhereInput;
    orderBy?: SliderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Slider>;
  slidersConnection: (args?: {
    where?: SliderWhereInput;
    orderBy?: SliderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => SliderConnectionPromise;
  speciality: (where: SpecialityWhereUniqueInput) => SpecialityNullablePromise;
  specialities: (args?: {
    where?: SpecialityWhereInput;
    orderBy?: SpecialityOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Speciality>;
  specialitiesConnection: (args?: {
    where?: SpecialityWhereInput;
    orderBy?: SpecialityOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => SpecialityConnectionPromise;
  translation: (
    where: TranslationWhereUniqueInput
  ) => TranslationNullablePromise;
  translations: (args?: {
    where?: TranslationWhereInput;
    orderBy?: TranslationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Translation>;
  translationsConnection: (args?: {
    where?: TranslationWhereInput;
    orderBy?: TranslationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => TranslationConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserNullablePromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  videoRequest: (
    where: VideoRequestWhereUniqueInput
  ) => VideoRequestNullablePromise;
  videoRequests: (args?: {
    where?: VideoRequestWhereInput;
    orderBy?: VideoRequestOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<VideoRequest>;
  videoRequestsConnection: (args?: {
    where?: VideoRequestWhereInput;
    orderBy?: VideoRequestOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => VideoRequestConnectionPromise;
  visitor: (where: VisitorWhereUniqueInput) => VisitorNullablePromise;
  visitors: (args?: {
    where?: VisitorWhereInput;
    orderBy?: VisitorOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Visitor>;
  visitorsConnection: (args?: {
    where?: VisitorWhereInput;
    orderBy?: VisitorOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => VisitorConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createAboutUs: (data: AboutUsCreateInput) => AboutUsPromise;
  updateAboutUs: (args: {
    data: AboutUsUpdateInput;
    where: AboutUsWhereUniqueInput;
  }) => AboutUsPromise;
  updateManyAboutUses: (args: {
    data: AboutUsUpdateManyMutationInput;
    where?: AboutUsWhereInput;
  }) => BatchPayloadPromise;
  upsertAboutUs: (args: {
    where: AboutUsWhereUniqueInput;
    create: AboutUsCreateInput;
    update: AboutUsUpdateInput;
  }) => AboutUsPromise;
  deleteAboutUs: (where: AboutUsWhereUniqueInput) => AboutUsPromise;
  deleteManyAboutUses: (where?: AboutUsWhereInput) => BatchPayloadPromise;
  createAdmin: (data: AdminCreateInput) => AdminPromise;
  updateAdmin: (args: {
    data: AdminUpdateInput;
    where: AdminWhereUniqueInput;
  }) => AdminPromise;
  updateManyAdmins: (args: {
    data: AdminUpdateManyMutationInput;
    where?: AdminWhereInput;
  }) => BatchPayloadPromise;
  upsertAdmin: (args: {
    where: AdminWhereUniqueInput;
    create: AdminCreateInput;
    update: AdminUpdateInput;
  }) => AdminPromise;
  deleteAdmin: (where: AdminWhereUniqueInput) => AdminPromise;
  deleteManyAdmins: (where?: AdminWhereInput) => BatchPayloadPromise;
  createAppointment: (data: AppointmentCreateInput) => AppointmentPromise;
  updateAppointment: (args: {
    data: AppointmentUpdateInput;
    where: AppointmentWhereUniqueInput;
  }) => AppointmentPromise;
  updateManyAppointments: (args: {
    data: AppointmentUpdateManyMutationInput;
    where?: AppointmentWhereInput;
  }) => BatchPayloadPromise;
  upsertAppointment: (args: {
    where: AppointmentWhereUniqueInput;
    create: AppointmentCreateInput;
    update: AppointmentUpdateInput;
  }) => AppointmentPromise;
  deleteAppointment: (where: AppointmentWhereUniqueInput) => AppointmentPromise;
  deleteManyAppointments: (
    where?: AppointmentWhereInput
  ) => BatchPayloadPromise;
  createBlog: (data: BlogCreateInput) => BlogPromise;
  updateBlog: (args: {
    data: BlogUpdateInput;
    where: BlogWhereUniqueInput;
  }) => BlogPromise;
  updateManyBlogs: (args: {
    data: BlogUpdateManyMutationInput;
    where?: BlogWhereInput;
  }) => BatchPayloadPromise;
  upsertBlog: (args: {
    where: BlogWhereUniqueInput;
    create: BlogCreateInput;
    update: BlogUpdateInput;
  }) => BlogPromise;
  deleteBlog: (where: BlogWhereUniqueInput) => BlogPromise;
  deleteManyBlogs: (where?: BlogWhereInput) => BatchPayloadPromise;
  createBlogComment: (data: BlogCommentCreateInput) => BlogCommentPromise;
  updateBlogComment: (args: {
    data: BlogCommentUpdateInput;
    where: BlogCommentWhereUniqueInput;
  }) => BlogCommentPromise;
  updateManyBlogComments: (args: {
    data: BlogCommentUpdateManyMutationInput;
    where?: BlogCommentWhereInput;
  }) => BatchPayloadPromise;
  upsertBlogComment: (args: {
    where: BlogCommentWhereUniqueInput;
    create: BlogCommentCreateInput;
    update: BlogCommentUpdateInput;
  }) => BlogCommentPromise;
  deleteBlogComment: (where: BlogCommentWhereUniqueInput) => BlogCommentPromise;
  deleteManyBlogComments: (
    where?: BlogCommentWhereInput
  ) => BatchPayloadPromise;
  createBlogPost: (data: BlogPostCreateInput) => BlogPostPromise;
  updateBlogPost: (args: {
    data: BlogPostUpdateInput;
    where: BlogPostWhereUniqueInput;
  }) => BlogPostPromise;
  updateManyBlogPosts: (args: {
    data: BlogPostUpdateManyMutationInput;
    where?: BlogPostWhereInput;
  }) => BatchPayloadPromise;
  upsertBlogPost: (args: {
    where: BlogPostWhereUniqueInput;
    create: BlogPostCreateInput;
    update: BlogPostUpdateInput;
  }) => BlogPostPromise;
  deleteBlogPost: (where: BlogPostWhereUniqueInput) => BlogPostPromise;
  deleteManyBlogPosts: (where?: BlogPostWhereInput) => BatchPayloadPromise;
  createCity: (data: CityCreateInput) => CityPromise;
  updateCity: (args: {
    data: CityUpdateInput;
    where: CityWhereUniqueInput;
  }) => CityPromise;
  updateManyCities: (args: {
    data: CityUpdateManyMutationInput;
    where?: CityWhereInput;
  }) => BatchPayloadPromise;
  upsertCity: (args: {
    where: CityWhereUniqueInput;
    create: CityCreateInput;
    update: CityUpdateInput;
  }) => CityPromise;
  deleteCity: (where: CityWhereUniqueInput) => CityPromise;
  deleteManyCities: (where?: CityWhereInput) => BatchPayloadPromise;
  createContactUs: (data: ContactUsCreateInput) => ContactUsPromise;
  updateContactUs: (args: {
    data: ContactUsUpdateInput;
    where: ContactUsWhereUniqueInput;
  }) => ContactUsPromise;
  updateManyContactUses: (args: {
    data: ContactUsUpdateManyMutationInput;
    where?: ContactUsWhereInput;
  }) => BatchPayloadPromise;
  upsertContactUs: (args: {
    where: ContactUsWhereUniqueInput;
    create: ContactUsCreateInput;
    update: ContactUsUpdateInput;
  }) => ContactUsPromise;
  deleteContactUs: (where: ContactUsWhereUniqueInput) => ContactUsPromise;
  deleteManyContactUses: (where?: ContactUsWhereInput) => BatchPayloadPromise;
  createCountry: (data: CountryCreateInput) => CountryPromise;
  updateCountry: (args: {
    data: CountryUpdateInput;
    where: CountryWhereUniqueInput;
  }) => CountryPromise;
  updateManyCountries: (args: {
    data: CountryUpdateManyMutationInput;
    where?: CountryWhereInput;
  }) => BatchPayloadPromise;
  upsertCountry: (args: {
    where: CountryWhereUniqueInput;
    create: CountryCreateInput;
    update: CountryUpdateInput;
  }) => CountryPromise;
  deleteCountry: (where: CountryWhereUniqueInput) => CountryPromise;
  deleteManyCountries: (where?: CountryWhereInput) => BatchPayloadPromise;
  createDisease: (data: DiseaseCreateInput) => DiseasePromise;
  updateDisease: (args: {
    data: DiseaseUpdateInput;
    where: DiseaseWhereUniqueInput;
  }) => DiseasePromise;
  updateManyDiseases: (args: {
    data: DiseaseUpdateManyMutationInput;
    where?: DiseaseWhereInput;
  }) => BatchPayloadPromise;
  upsertDisease: (args: {
    where: DiseaseWhereUniqueInput;
    create: DiseaseCreateInput;
    update: DiseaseUpdateInput;
  }) => DiseasePromise;
  deleteDisease: (where: DiseaseWhereUniqueInput) => DiseasePromise;
  deleteManyDiseases: (where?: DiseaseWhereInput) => BatchPayloadPromise;
  createDiseaseCovered: (
    data: DiseaseCoveredCreateInput
  ) => DiseaseCoveredPromise;
  updateDiseaseCovered: (args: {
    data: DiseaseCoveredUpdateInput;
    where: DiseaseCoveredWhereUniqueInput;
  }) => DiseaseCoveredPromise;
  updateManyDiseaseCovereds: (args: {
    data: DiseaseCoveredUpdateManyMutationInput;
    where?: DiseaseCoveredWhereInput;
  }) => BatchPayloadPromise;
  upsertDiseaseCovered: (args: {
    where: DiseaseCoveredWhereUniqueInput;
    create: DiseaseCoveredCreateInput;
    update: DiseaseCoveredUpdateInput;
  }) => DiseaseCoveredPromise;
  deleteDiseaseCovered: (
    where: DiseaseCoveredWhereUniqueInput
  ) => DiseaseCoveredPromise;
  deleteManyDiseaseCovereds: (
    where?: DiseaseCoveredWhereInput
  ) => BatchPayloadPromise;
  createDoctor: (data: DoctorCreateInput) => DoctorPromise;
  updateDoctor: (args: {
    data: DoctorUpdateInput;
    where: DoctorWhereUniqueInput;
  }) => DoctorPromise;
  updateManyDoctors: (args: {
    data: DoctorUpdateManyMutationInput;
    where?: DoctorWhereInput;
  }) => BatchPayloadPromise;
  upsertDoctor: (args: {
    where: DoctorWhereUniqueInput;
    create: DoctorCreateInput;
    update: DoctorUpdateInput;
  }) => DoctorPromise;
  deleteDoctor: (where: DoctorWhereUniqueInput) => DoctorPromise;
  deleteManyDoctors: (where?: DoctorWhereInput) => BatchPayloadPromise;
  createDoctorOld: (data: DoctorOldCreateInput) => DoctorOldPromise;
  updateDoctorOld: (args: {
    data: DoctorOldUpdateInput;
    where: DoctorOldWhereUniqueInput;
  }) => DoctorOldPromise;
  updateManyDoctorOlds: (args: {
    data: DoctorOldUpdateManyMutationInput;
    where?: DoctorOldWhereInput;
  }) => BatchPayloadPromise;
  upsertDoctorOld: (args: {
    where: DoctorOldWhereUniqueInput;
    create: DoctorOldCreateInput;
    update: DoctorOldUpdateInput;
  }) => DoctorOldPromise;
  deleteDoctorOld: (where: DoctorOldWhereUniqueInput) => DoctorOldPromise;
  deleteManyDoctorOlds: (where?: DoctorOldWhereInput) => BatchPayloadPromise;
  createDoctorShedule: (data: DoctorSheduleCreateInput) => DoctorShedulePromise;
  updateDoctorShedule: (args: {
    data: DoctorSheduleUpdateInput;
    where: DoctorSheduleWhereUniqueInput;
  }) => DoctorShedulePromise;
  updateManyDoctorShedules: (args: {
    data: DoctorSheduleUpdateManyMutationInput;
    where?: DoctorSheduleWhereInput;
  }) => BatchPayloadPromise;
  upsertDoctorShedule: (args: {
    where: DoctorSheduleWhereUniqueInput;
    create: DoctorSheduleCreateInput;
    update: DoctorSheduleUpdateInput;
  }) => DoctorShedulePromise;
  deleteDoctorShedule: (
    where: DoctorSheduleWhereUniqueInput
  ) => DoctorShedulePromise;
  deleteManyDoctorShedules: (
    where?: DoctorSheduleWhereInput
  ) => BatchPayloadPromise;
  createDoctorSheduleTime: (
    data: DoctorSheduleTimeCreateInput
  ) => DoctorSheduleTimePromise;
  updateDoctorSheduleTime: (args: {
    data: DoctorSheduleTimeUpdateInput;
    where: DoctorSheduleTimeWhereUniqueInput;
  }) => DoctorSheduleTimePromise;
  updateManyDoctorSheduleTimes: (args: {
    data: DoctorSheduleTimeUpdateManyMutationInput;
    where?: DoctorSheduleTimeWhereInput;
  }) => BatchPayloadPromise;
  upsertDoctorSheduleTime: (args: {
    where: DoctorSheduleTimeWhereUniqueInput;
    create: DoctorSheduleTimeCreateInput;
    update: DoctorSheduleTimeUpdateInput;
  }) => DoctorSheduleTimePromise;
  deleteDoctorSheduleTime: (
    where: DoctorSheduleTimeWhereUniqueInput
  ) => DoctorSheduleTimePromise;
  deleteManyDoctorSheduleTimes: (
    where?: DoctorSheduleTimeWhereInput
  ) => BatchPayloadPromise;
  createDoctorsRating: (data: DoctorsRatingCreateInput) => DoctorsRatingPromise;
  updateDoctorsRating: (args: {
    data: DoctorsRatingUpdateInput;
    where: DoctorsRatingWhereUniqueInput;
  }) => DoctorsRatingPromise;
  updateManyDoctorsRatings: (args: {
    data: DoctorsRatingUpdateManyMutationInput;
    where?: DoctorsRatingWhereInput;
  }) => BatchPayloadPromise;
  upsertDoctorsRating: (args: {
    where: DoctorsRatingWhereUniqueInput;
    create: DoctorsRatingCreateInput;
    update: DoctorsRatingUpdateInput;
  }) => DoctorsRatingPromise;
  deleteDoctorsRating: (
    where: DoctorsRatingWhereUniqueInput
  ) => DoctorsRatingPromise;
  deleteManyDoctorsRatings: (
    where?: DoctorsRatingWhereInput
  ) => BatchPayloadPromise;
  createDrShedule: (data: DrSheduleCreateInput) => DrShedulePromise;
  updateDrShedule: (args: {
    data: DrSheduleUpdateInput;
    where: DrSheduleWhereUniqueInput;
  }) => DrShedulePromise;
  updateManyDrShedules: (args: {
    data: DrSheduleUpdateManyMutationInput;
    where?: DrSheduleWhereInput;
  }) => BatchPayloadPromise;
  upsertDrShedule: (args: {
    where: DrSheduleWhereUniqueInput;
    create: DrSheduleCreateInput;
    update: DrSheduleUpdateInput;
  }) => DrShedulePromise;
  deleteDrShedule: (where: DrSheduleWhereUniqueInput) => DrShedulePromise;
  deleteManyDrShedules: (where?: DrSheduleWhereInput) => BatchPayloadPromise;
  createEmailSubscription: (
    data: EmailSubscriptionCreateInput
  ) => EmailSubscriptionPromise;
  updateEmailSubscription: (args: {
    data: EmailSubscriptionUpdateInput;
    where: EmailSubscriptionWhereUniqueInput;
  }) => EmailSubscriptionPromise;
  updateManyEmailSubscriptions: (args: {
    data: EmailSubscriptionUpdateManyMutationInput;
    where?: EmailSubscriptionWhereInput;
  }) => BatchPayloadPromise;
  upsertEmailSubscription: (args: {
    where: EmailSubscriptionWhereUniqueInput;
    create: EmailSubscriptionCreateInput;
    update: EmailSubscriptionUpdateInput;
  }) => EmailSubscriptionPromise;
  deleteEmailSubscription: (
    where: EmailSubscriptionWhereUniqueInput
  ) => EmailSubscriptionPromise;
  deleteManyEmailSubscriptions: (
    where?: EmailSubscriptionWhereInput
  ) => BatchPayloadPromise;
  createFacility: (data: FacilityCreateInput) => FacilityPromise;
  updateFacility: (args: {
    data: FacilityUpdateInput;
    where: FacilityWhereUniqueInput;
  }) => FacilityPromise;
  updateManyFacilities: (args: {
    data: FacilityUpdateManyMutationInput;
    where?: FacilityWhereInput;
  }) => BatchPayloadPromise;
  upsertFacility: (args: {
    where: FacilityWhereUniqueInput;
    create: FacilityCreateInput;
    update: FacilityUpdateInput;
  }) => FacilityPromise;
  deleteFacility: (where: FacilityWhereUniqueInput) => FacilityPromise;
  deleteManyFacilities: (where?: FacilityWhereInput) => BatchPayloadPromise;
  createHospital: (data: HospitalCreateInput) => HospitalPromise;
  updateHospital: (args: {
    data: HospitalUpdateInput;
    where: HospitalWhereUniqueInput;
  }) => HospitalPromise;
  updateManyHospitals: (args: {
    data: HospitalUpdateManyMutationInput;
    where?: HospitalWhereInput;
  }) => BatchPayloadPromise;
  upsertHospital: (args: {
    where: HospitalWhereUniqueInput;
    create: HospitalCreateInput;
    update: HospitalUpdateInput;
  }) => HospitalPromise;
  deleteHospital: (where: HospitalWhereUniqueInput) => HospitalPromise;
  deleteManyHospitals: (where?: HospitalWhereInput) => BatchPayloadPromise;
  createHospitalFacility: (
    data: HospitalFacilityCreateInput
  ) => HospitalFacilityPromise;
  updateHospitalFacility: (args: {
    data: HospitalFacilityUpdateInput;
    where: HospitalFacilityWhereUniqueInput;
  }) => HospitalFacilityPromise;
  updateManyHospitalFacilities: (args: {
    data: HospitalFacilityUpdateManyMutationInput;
    where?: HospitalFacilityWhereInput;
  }) => BatchPayloadPromise;
  upsertHospitalFacility: (args: {
    where: HospitalFacilityWhereUniqueInput;
    create: HospitalFacilityCreateInput;
    update: HospitalFacilityUpdateInput;
  }) => HospitalFacilityPromise;
  deleteHospitalFacility: (
    where: HospitalFacilityWhereUniqueInput
  ) => HospitalFacilityPromise;
  deleteManyHospitalFacilities: (
    where?: HospitalFacilityWhereInput
  ) => BatchPayloadPromise;
  createHospitalRating: (
    data: HospitalRatingCreateInput
  ) => HospitalRatingPromise;
  updateHospitalRating: (args: {
    data: HospitalRatingUpdateInput;
    where: HospitalRatingWhereUniqueInput;
  }) => HospitalRatingPromise;
  updateManyHospitalRatings: (args: {
    data: HospitalRatingUpdateManyMutationInput;
    where?: HospitalRatingWhereInput;
  }) => BatchPayloadPromise;
  upsertHospitalRating: (args: {
    where: HospitalRatingWhereUniqueInput;
    create: HospitalRatingCreateInput;
    update: HospitalRatingUpdateInput;
  }) => HospitalRatingPromise;
  deleteHospitalRating: (
    where: HospitalRatingWhereUniqueInput
  ) => HospitalRatingPromise;
  deleteManyHospitalRatings: (
    where?: HospitalRatingWhereInput
  ) => BatchPayloadPromise;
  createIllness: (data: IllnessCreateInput) => IllnessPromise;
  updateIllness: (args: {
    data: IllnessUpdateInput;
    where: IllnessWhereUniqueInput;
  }) => IllnessPromise;
  updateManyIllnesses: (args: {
    data: IllnessUpdateManyMutationInput;
    where?: IllnessWhereInput;
  }) => BatchPayloadPromise;
  upsertIllness: (args: {
    where: IllnessWhereUniqueInput;
    create: IllnessCreateInput;
    update: IllnessUpdateInput;
  }) => IllnessPromise;
  deleteIllness: (where: IllnessWhereUniqueInput) => IllnessPromise;
  deleteManyIllnesses: (where?: IllnessWhereInput) => BatchPayloadPromise;
  createInsurance: (data: InsuranceCreateInput) => InsurancePromise;
  updateInsurance: (args: {
    data: InsuranceUpdateInput;
    where: InsuranceWhereUniqueInput;
  }) => InsurancePromise;
  updateManyInsurances: (args: {
    data: InsuranceUpdateManyMutationInput;
    where?: InsuranceWhereInput;
  }) => BatchPayloadPromise;
  upsertInsurance: (args: {
    where: InsuranceWhereUniqueInput;
    create: InsuranceCreateInput;
    update: InsuranceUpdateInput;
  }) => InsurancePromise;
  deleteInsurance: (where: InsuranceWhereUniqueInput) => InsurancePromise;
  deleteManyInsurances: (where?: InsuranceWhereInput) => BatchPayloadPromise;
  createInsuranceCategory: (
    data: InsuranceCategoryCreateInput
  ) => InsuranceCategoryPromise;
  updateInsuranceCategory: (args: {
    data: InsuranceCategoryUpdateInput;
    where: InsuranceCategoryWhereUniqueInput;
  }) => InsuranceCategoryPromise;
  updateManyInsuranceCategories: (args: {
    data: InsuranceCategoryUpdateManyMutationInput;
    where?: InsuranceCategoryWhereInput;
  }) => BatchPayloadPromise;
  upsertInsuranceCategory: (args: {
    where: InsuranceCategoryWhereUniqueInput;
    create: InsuranceCategoryCreateInput;
    update: InsuranceCategoryUpdateInput;
  }) => InsuranceCategoryPromise;
  deleteInsuranceCategory: (
    where: InsuranceCategoryWhereUniqueInput
  ) => InsuranceCategoryPromise;
  deleteManyInsuranceCategories: (
    where?: InsuranceCategoryWhereInput
  ) => BatchPayloadPromise;
  createJob: (data: JobCreateInput) => JobPromise;
  updateJob: (args: {
    data: JobUpdateInput;
    where: JobWhereUniqueInput;
  }) => JobPromise;
  updateManyJobs: (args: {
    data: JobUpdateManyMutationInput;
    where?: JobWhereInput;
  }) => BatchPayloadPromise;
  upsertJob: (args: {
    where: JobWhereUniqueInput;
    create: JobCreateInput;
    update: JobUpdateInput;
  }) => JobPromise;
  deleteJob: (where: JobWhereUniqueInput) => JobPromise;
  deleteManyJobs: (where?: JobWhereInput) => BatchPayloadPromise;
  createLanguage: (data: LanguageCreateInput) => LanguagePromise;
  updateLanguage: (args: {
    data: LanguageUpdateInput;
    where: LanguageWhereUniqueInput;
  }) => LanguagePromise;
  updateManyLanguages: (args: {
    data: LanguageUpdateManyMutationInput;
    where?: LanguageWhereInput;
  }) => BatchPayloadPromise;
  upsertLanguage: (args: {
    where: LanguageWhereUniqueInput;
    create: LanguageCreateInput;
    update: LanguageUpdateInput;
  }) => LanguagePromise;
  deleteLanguage: (where: LanguageWhereUniqueInput) => LanguagePromise;
  deleteManyLanguages: (where?: LanguageWhereInput) => BatchPayloadPromise;
  createMessage: (data: MessageCreateInput) => MessagePromise;
  updateMessage: (args: {
    data: MessageUpdateInput;
    where: MessageWhereUniqueInput;
  }) => MessagePromise;
  updateManyMessages: (args: {
    data: MessageUpdateManyMutationInput;
    where?: MessageWhereInput;
  }) => BatchPayloadPromise;
  upsertMessage: (args: {
    where: MessageWhereUniqueInput;
    create: MessageCreateInput;
    update: MessageUpdateInput;
  }) => MessagePromise;
  deleteMessage: (where: MessageWhereUniqueInput) => MessagePromise;
  deleteManyMessages: (where?: MessageWhereInput) => BatchPayloadPromise;
  createMigration: (data: MigrationCreateInput) => MigrationPromise;
  updateMigration: (args: {
    data: MigrationUpdateInput;
    where: MigrationWhereUniqueInput;
  }) => MigrationPromise;
  updateManyMigrations: (args: {
    data: MigrationUpdateManyMutationInput;
    where?: MigrationWhereInput;
  }) => BatchPayloadPromise;
  upsertMigration: (args: {
    where: MigrationWhereUniqueInput;
    create: MigrationCreateInput;
    update: MigrationUpdateInput;
  }) => MigrationPromise;
  deleteMigration: (where: MigrationWhereUniqueInput) => MigrationPromise;
  deleteManyMigrations: (where?: MigrationWhereInput) => BatchPayloadPromise;
  createOffer: (data: OfferCreateInput) => OfferPromise;
  updateOffer: (args: {
    data: OfferUpdateInput;
    where: OfferWhereUniqueInput;
  }) => OfferPromise;
  updateManyOffers: (args: {
    data: OfferUpdateManyMutationInput;
    where?: OfferWhereInput;
  }) => BatchPayloadPromise;
  upsertOffer: (args: {
    where: OfferWhereUniqueInput;
    create: OfferCreateInput;
    update: OfferUpdateInput;
  }) => OfferPromise;
  deleteOffer: (where: OfferWhereUniqueInput) => OfferPromise;
  deleteManyOffers: (where?: OfferWhereInput) => BatchPayloadPromise;
  createOnlineAppointment: (
    data: OnlineAppointmentCreateInput
  ) => OnlineAppointmentPromise;
  updateOnlineAppointment: (args: {
    data: OnlineAppointmentUpdateInput;
    where: OnlineAppointmentWhereUniqueInput;
  }) => OnlineAppointmentPromise;
  updateManyOnlineAppointments: (args: {
    data: OnlineAppointmentUpdateManyMutationInput;
    where?: OnlineAppointmentWhereInput;
  }) => BatchPayloadPromise;
  upsertOnlineAppointment: (args: {
    where: OnlineAppointmentWhereUniqueInput;
    create: OnlineAppointmentCreateInput;
    update: OnlineAppointmentUpdateInput;
  }) => OnlineAppointmentPromise;
  deleteOnlineAppointment: (
    where: OnlineAppointmentWhereUniqueInput
  ) => OnlineAppointmentPromise;
  deleteManyOnlineAppointments: (
    where?: OnlineAppointmentWhereInput
  ) => BatchPayloadPromise;
  createOnlineDoctor: (data: OnlineDoctorCreateInput) => OnlineDoctorPromise;
  updateOnlineDoctor: (args: {
    data: OnlineDoctorUpdateInput;
    where: OnlineDoctorWhereUniqueInput;
  }) => OnlineDoctorPromise;
  updateManyOnlineDoctors: (args: {
    data: OnlineDoctorUpdateManyMutationInput;
    where?: OnlineDoctorWhereInput;
  }) => BatchPayloadPromise;
  upsertOnlineDoctor: (args: {
    where: OnlineDoctorWhereUniqueInput;
    create: OnlineDoctorCreateInput;
    update: OnlineDoctorUpdateInput;
  }) => OnlineDoctorPromise;
  deleteOnlineDoctor: (
    where: OnlineDoctorWhereUniqueInput
  ) => OnlineDoctorPromise;
  deleteManyOnlineDoctors: (
    where?: OnlineDoctorWhereInput
  ) => BatchPayloadPromise;
  createOnlineRating: (data: OnlineRatingCreateInput) => OnlineRatingPromise;
  updateOnlineRating: (args: {
    data: OnlineRatingUpdateInput;
    where: OnlineRatingWhereUniqueInput;
  }) => OnlineRatingPromise;
  updateManyOnlineRatings: (args: {
    data: OnlineRatingUpdateManyMutationInput;
    where?: OnlineRatingWhereInput;
  }) => BatchPayloadPromise;
  upsertOnlineRating: (args: {
    where: OnlineRatingWhereUniqueInput;
    create: OnlineRatingCreateInput;
    update: OnlineRatingUpdateInput;
  }) => OnlineRatingPromise;
  deleteOnlineRating: (
    where: OnlineRatingWhereUniqueInput
  ) => OnlineRatingPromise;
  deleteManyOnlineRatings: (
    where?: OnlineRatingWhereInput
  ) => BatchPayloadPromise;
  createOptTime: (data: OptTimeCreateInput) => OptTimePromise;
  updateOptTime: (args: {
    data: OptTimeUpdateInput;
    where: OptTimeWhereUniqueInput;
  }) => OptTimePromise;
  updateManyOptTimes: (args: {
    data: OptTimeUpdateManyMutationInput;
    where?: OptTimeWhereInput;
  }) => BatchPayloadPromise;
  upsertOptTime: (args: {
    where: OptTimeWhereUniqueInput;
    create: OptTimeCreateInput;
    update: OptTimeUpdateInput;
  }) => OptTimePromise;
  deleteOptTime: (where: OptTimeWhereUniqueInput) => OptTimePromise;
  deleteManyOptTimes: (where?: OptTimeWhereInput) => BatchPayloadPromise;
  createPage: (data: PageCreateInput) => PagePromise;
  updatePage: (args: {
    data: PageUpdateInput;
    where: PageWhereUniqueInput;
  }) => PagePromise;
  updateManyPages: (args: {
    data: PageUpdateManyMutationInput;
    where?: PageWhereInput;
  }) => BatchPayloadPromise;
  upsertPage: (args: {
    where: PageWhereUniqueInput;
    create: PageCreateInput;
    update: PageUpdateInput;
  }) => PagePromise;
  deletePage: (where: PageWhereUniqueInput) => PagePromise;
  deleteManyPages: (where?: PageWhereInput) => BatchPayloadPromise;
  createPasswordReset: (data: PasswordResetCreateInput) => PasswordResetPromise;
  updatePasswordReset: (args: {
    data: PasswordResetUpdateInput;
    where: PasswordResetWhereUniqueInput;
  }) => PasswordResetPromise;
  updateManyPasswordResets: (args: {
    data: PasswordResetUpdateManyMutationInput;
    where?: PasswordResetWhereInput;
  }) => BatchPayloadPromise;
  upsertPasswordReset: (args: {
    where: PasswordResetWhereUniqueInput;
    create: PasswordResetCreateInput;
    update: PasswordResetUpdateInput;
  }) => PasswordResetPromise;
  deletePasswordReset: (
    where: PasswordResetWhereUniqueInput
  ) => PasswordResetPromise;
  deleteManyPasswordResets: (
    where?: PasswordResetWhereInput
  ) => BatchPayloadPromise;
  createPatient: (data: PatientCreateInput) => PatientPromise;
  updatePatient: (args: {
    data: PatientUpdateInput;
    where: PatientWhereUniqueInput;
  }) => PatientPromise;
  updateManyPatients: (args: {
    data: PatientUpdateManyMutationInput;
    where?: PatientWhereInput;
  }) => BatchPayloadPromise;
  upsertPatient: (args: {
    where: PatientWhereUniqueInput;
    create: PatientCreateInput;
    update: PatientUpdateInput;
  }) => PatientPromise;
  deletePatient: (where: PatientWhereUniqueInput) => PatientPromise;
  deleteManyPatients: (where?: PatientWhereInput) => BatchPayloadPromise;
  createPostImage: (data: PostImageCreateInput) => PostImagePromise;
  updatePostImage: (args: {
    data: PostImageUpdateInput;
    where: PostImageWhereUniqueInput;
  }) => PostImagePromise;
  updateManyPostImages: (args: {
    data: PostImageUpdateManyMutationInput;
    where?: PostImageWhereInput;
  }) => BatchPayloadPromise;
  upsertPostImage: (args: {
    where: PostImageWhereUniqueInput;
    create: PostImageCreateInput;
    update: PostImageUpdateInput;
  }) => PostImagePromise;
  deletePostImage: (where: PostImageWhereUniqueInput) => PostImagePromise;
  deleteManyPostImages: (where?: PostImageWhereInput) => BatchPayloadPromise;
  createSearchDesign: (data: SearchDesignCreateInput) => SearchDesignPromise;
  updateSearchDesign: (args: {
    data: SearchDesignUpdateInput;
    where: SearchDesignWhereUniqueInput;
  }) => SearchDesignPromise;
  updateManySearchDesigns: (args: {
    data: SearchDesignUpdateManyMutationInput;
    where?: SearchDesignWhereInput;
  }) => BatchPayloadPromise;
  upsertSearchDesign: (args: {
    where: SearchDesignWhereUniqueInput;
    create: SearchDesignCreateInput;
    update: SearchDesignUpdateInput;
  }) => SearchDesignPromise;
  deleteSearchDesign: (
    where: SearchDesignWhereUniqueInput
  ) => SearchDesignPromise;
  deleteManySearchDesigns: (
    where?: SearchDesignWhereInput
  ) => BatchPayloadPromise;
  createSheduleTime: (data: SheduleTimeCreateInput) => SheduleTimePromise;
  updateSheduleTime: (args: {
    data: SheduleTimeUpdateInput;
    where: SheduleTimeWhereUniqueInput;
  }) => SheduleTimePromise;
  updateManySheduleTimes: (args: {
    data: SheduleTimeUpdateManyMutationInput;
    where?: SheduleTimeWhereInput;
  }) => BatchPayloadPromise;
  upsertSheduleTime: (args: {
    where: SheduleTimeWhereUniqueInput;
    create: SheduleTimeCreateInput;
    update: SheduleTimeUpdateInput;
  }) => SheduleTimePromise;
  deleteSheduleTime: (where: SheduleTimeWhereUniqueInput) => SheduleTimePromise;
  deleteManySheduleTimes: (
    where?: SheduleTimeWhereInput
  ) => BatchPayloadPromise;
  createSlider: (data: SliderCreateInput) => SliderPromise;
  updateSlider: (args: {
    data: SliderUpdateInput;
    where: SliderWhereUniqueInput;
  }) => SliderPromise;
  updateManySliders: (args: {
    data: SliderUpdateManyMutationInput;
    where?: SliderWhereInput;
  }) => BatchPayloadPromise;
  upsertSlider: (args: {
    where: SliderWhereUniqueInput;
    create: SliderCreateInput;
    update: SliderUpdateInput;
  }) => SliderPromise;
  deleteSlider: (where: SliderWhereUniqueInput) => SliderPromise;
  deleteManySliders: (where?: SliderWhereInput) => BatchPayloadPromise;
  createSpeciality: (data: SpecialityCreateInput) => SpecialityPromise;
  updateSpeciality: (args: {
    data: SpecialityUpdateInput;
    where: SpecialityWhereUniqueInput;
  }) => SpecialityPromise;
  updateManySpecialities: (args: {
    data: SpecialityUpdateManyMutationInput;
    where?: SpecialityWhereInput;
  }) => BatchPayloadPromise;
  upsertSpeciality: (args: {
    where: SpecialityWhereUniqueInput;
    create: SpecialityCreateInput;
    update: SpecialityUpdateInput;
  }) => SpecialityPromise;
  deleteSpeciality: (where: SpecialityWhereUniqueInput) => SpecialityPromise;
  deleteManySpecialities: (where?: SpecialityWhereInput) => BatchPayloadPromise;
  createTranslation: (data: TranslationCreateInput) => TranslationPromise;
  updateTranslation: (args: {
    data: TranslationUpdateInput;
    where: TranslationWhereUniqueInput;
  }) => TranslationPromise;
  updateManyTranslations: (args: {
    data: TranslationUpdateManyMutationInput;
    where?: TranslationWhereInput;
  }) => BatchPayloadPromise;
  upsertTranslation: (args: {
    where: TranslationWhereUniqueInput;
    create: TranslationCreateInput;
    update: TranslationUpdateInput;
  }) => TranslationPromise;
  deleteTranslation: (where: TranslationWhereUniqueInput) => TranslationPromise;
  deleteManyTranslations: (
    where?: TranslationWhereInput
  ) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;
  createVideoRequest: (data: VideoRequestCreateInput) => VideoRequestPromise;
  updateVideoRequest: (args: {
    data: VideoRequestUpdateInput;
    where: VideoRequestWhereUniqueInput;
  }) => VideoRequestPromise;
  updateManyVideoRequests: (args: {
    data: VideoRequestUpdateManyMutationInput;
    where?: VideoRequestWhereInput;
  }) => BatchPayloadPromise;
  upsertVideoRequest: (args: {
    where: VideoRequestWhereUniqueInput;
    create: VideoRequestCreateInput;
    update: VideoRequestUpdateInput;
  }) => VideoRequestPromise;
  deleteVideoRequest: (
    where: VideoRequestWhereUniqueInput
  ) => VideoRequestPromise;
  deleteManyVideoRequests: (
    where?: VideoRequestWhereInput
  ) => BatchPayloadPromise;
  createVisitor: (data: VisitorCreateInput) => VisitorPromise;
  updateVisitor: (args: {
    data: VisitorUpdateInput;
    where: VisitorWhereUniqueInput;
  }) => VisitorPromise;
  updateManyVisitors: (args: {
    data: VisitorUpdateManyMutationInput;
    where?: VisitorWhereInput;
  }) => BatchPayloadPromise;
  upsertVisitor: (args: {
    where: VisitorWhereUniqueInput;
    create: VisitorCreateInput;
    update: VisitorUpdateInput;
  }) => VisitorPromise;
  deleteVisitor: (where: VisitorWhereUniqueInput) => VisitorPromise;
  deleteManyVisitors: (where?: VisitorWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  aboutUs: (
    where?: AboutUsSubscriptionWhereInput
  ) => AboutUsSubscriptionPayloadSubscription;
  admin: (
    where?: AdminSubscriptionWhereInput
  ) => AdminSubscriptionPayloadSubscription;
  appointment: (
    where?: AppointmentSubscriptionWhereInput
  ) => AppointmentSubscriptionPayloadSubscription;
  blog: (
    where?: BlogSubscriptionWhereInput
  ) => BlogSubscriptionPayloadSubscription;
  blogComment: (
    where?: BlogCommentSubscriptionWhereInput
  ) => BlogCommentSubscriptionPayloadSubscription;
  blogPost: (
    where?: BlogPostSubscriptionWhereInput
  ) => BlogPostSubscriptionPayloadSubscription;
  city: (
    where?: CitySubscriptionWhereInput
  ) => CitySubscriptionPayloadSubscription;
  contactUs: (
    where?: ContactUsSubscriptionWhereInput
  ) => ContactUsSubscriptionPayloadSubscription;
  country: (
    where?: CountrySubscriptionWhereInput
  ) => CountrySubscriptionPayloadSubscription;
  disease: (
    where?: DiseaseSubscriptionWhereInput
  ) => DiseaseSubscriptionPayloadSubscription;
  diseaseCovered: (
    where?: DiseaseCoveredSubscriptionWhereInput
  ) => DiseaseCoveredSubscriptionPayloadSubscription;
  doctor: (
    where?: DoctorSubscriptionWhereInput
  ) => DoctorSubscriptionPayloadSubscription;
  doctorOld: (
    where?: DoctorOldSubscriptionWhereInput
  ) => DoctorOldSubscriptionPayloadSubscription;
  doctorShedule: (
    where?: DoctorSheduleSubscriptionWhereInput
  ) => DoctorSheduleSubscriptionPayloadSubscription;
  doctorSheduleTime: (
    where?: DoctorSheduleTimeSubscriptionWhereInput
  ) => DoctorSheduleTimeSubscriptionPayloadSubscription;
  doctorsRating: (
    where?: DoctorsRatingSubscriptionWhereInput
  ) => DoctorsRatingSubscriptionPayloadSubscription;
  drShedule: (
    where?: DrSheduleSubscriptionWhereInput
  ) => DrSheduleSubscriptionPayloadSubscription;
  emailSubscription: (
    where?: EmailSubscriptionSubscriptionWhereInput
  ) => EmailSubscriptionSubscriptionPayloadSubscription;
  facility: (
    where?: FacilitySubscriptionWhereInput
  ) => FacilitySubscriptionPayloadSubscription;
  hospital: (
    where?: HospitalSubscriptionWhereInput
  ) => HospitalSubscriptionPayloadSubscription;
  hospitalFacility: (
    where?: HospitalFacilitySubscriptionWhereInput
  ) => HospitalFacilitySubscriptionPayloadSubscription;
  hospitalRating: (
    where?: HospitalRatingSubscriptionWhereInput
  ) => HospitalRatingSubscriptionPayloadSubscription;
  illness: (
    where?: IllnessSubscriptionWhereInput
  ) => IllnessSubscriptionPayloadSubscription;
  insurance: (
    where?: InsuranceSubscriptionWhereInput
  ) => InsuranceSubscriptionPayloadSubscription;
  insuranceCategory: (
    where?: InsuranceCategorySubscriptionWhereInput
  ) => InsuranceCategorySubscriptionPayloadSubscription;
  job: (
    where?: JobSubscriptionWhereInput
  ) => JobSubscriptionPayloadSubscription;
  language: (
    where?: LanguageSubscriptionWhereInput
  ) => LanguageSubscriptionPayloadSubscription;
  message: (
    where?: MessageSubscriptionWhereInput
  ) => MessageSubscriptionPayloadSubscription;
  migration: (
    where?: MigrationSubscriptionWhereInput
  ) => MigrationSubscriptionPayloadSubscription;
  offer: (
    where?: OfferSubscriptionWhereInput
  ) => OfferSubscriptionPayloadSubscription;
  onlineAppointment: (
    where?: OnlineAppointmentSubscriptionWhereInput
  ) => OnlineAppointmentSubscriptionPayloadSubscription;
  onlineDoctor: (
    where?: OnlineDoctorSubscriptionWhereInput
  ) => OnlineDoctorSubscriptionPayloadSubscription;
  onlineRating: (
    where?: OnlineRatingSubscriptionWhereInput
  ) => OnlineRatingSubscriptionPayloadSubscription;
  optTime: (
    where?: OptTimeSubscriptionWhereInput
  ) => OptTimeSubscriptionPayloadSubscription;
  page: (
    where?: PageSubscriptionWhereInput
  ) => PageSubscriptionPayloadSubscription;
  passwordReset: (
    where?: PasswordResetSubscriptionWhereInput
  ) => PasswordResetSubscriptionPayloadSubscription;
  patient: (
    where?: PatientSubscriptionWhereInput
  ) => PatientSubscriptionPayloadSubscription;
  postImage: (
    where?: PostImageSubscriptionWhereInput
  ) => PostImageSubscriptionPayloadSubscription;
  searchDesign: (
    where?: SearchDesignSubscriptionWhereInput
  ) => SearchDesignSubscriptionPayloadSubscription;
  sheduleTime: (
    where?: SheduleTimeSubscriptionWhereInput
  ) => SheduleTimeSubscriptionPayloadSubscription;
  slider: (
    where?: SliderSubscriptionWhereInput
  ) => SliderSubscriptionPayloadSubscription;
  speciality: (
    where?: SpecialitySubscriptionWhereInput
  ) => SpecialitySubscriptionPayloadSubscription;
  translation: (
    where?: TranslationSubscriptionWhereInput
  ) => TranslationSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
  videoRequest: (
    where?: VideoRequestSubscriptionWhereInput
  ) => VideoRequestSubscriptionPayloadSubscription;
  visitor: (
    where?: VisitorSubscriptionWhereInput
  ) => VisitorSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type AboutUsOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "arabicContent_ASC"
  | "arabicContent_DESC"
  | "englishContent_ASC"
  | "englishContent_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type AdminOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "email_ASC"
  | "email_DESC"
  | "pass_ASC"
  | "pass_DESC"
  | "superAdmin_ASC"
  | "superAdmin_DESC"
  | "user_ASC"
  | "user_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type DoctorOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "apiKey_ASC"
  | "apiKey_DESC"
  | "designation_ASC"
  | "designation_DESC"
  | "doctorCv_ASC"
  | "doctorCv_DESC"
  | "email_ASC"
  | "email_DESC"
  | "gender_ASC"
  | "gender_DESC"
  | "mohcard_ASC"
  | "mohcard_DESC"
  | "mohId_ASC"
  | "mohId_DESC"
  | "name_ASC"
  | "name_DESC"
  | "nameArabic_ASC"
  | "nameArabic_DESC"
  | "password_ASC"
  | "password_DESC"
  | "phone_ASC"
  | "phone_DESC"
  | "fees_ASC"
  | "fees_DESC"
  | "picture_ASC"
  | "picture_DESC"
  | "specialityId_ASC"
  | "specialityId_DESC"
  | "status_ASC"
  | "status_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "createdDate_ASC"
  | "createdDate_DESC";

export type HospitalOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "address_ASC"
  | "address_DESC"
  | "addressArabic_ASC"
  | "addressArabic_DESC"
  | "apiKey_ASC"
  | "apiKey_DESC"
  | "email_ASC"
  | "email_DESC"
  | "hospital_ASC"
  | "hospital_DESC"
  | "hospitalArabic_ASC"
  | "hospitalArabic_DESC"
  | "language_ASC"
  | "language_DESC"
  | "latitude_ASC"
  | "latitude_DESC"
  | "location_ASC"
  | "location_DESC"
  | "logo_ASC"
  | "logo_DESC"
  | "longitude_ASC"
  | "longitude_DESC"
  | "password_ASC"
  | "password_DESC"
  | "phone_ASC"
  | "phone_DESC"
  | "phone1_ASC"
  | "phone1_DESC"
  | "status_ASC"
  | "status_DESC"
  | "type_ASC"
  | "type_DESC"
  | "uniqeId_ASC"
  | "uniqeId_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "createdDate_ASC"
  | "createdDate_DESC";

export type InsuranceOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "countryId_ASC"
  | "countryId_DESC"
  | "insurance_ASC"
  | "insurance_DESC"
  | "insuranceArabic_ASC"
  | "insuranceArabic_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type AppointmentOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "apointmentDate_ASC"
  | "apointmentDate_DESC"
  | "apointmentFulldate_ASC"
  | "apointmentFulldate_DESC"
  | "apointmentTime_ASC"
  | "apointmentTime_DESC"
  | "doctorArabic_ASC"
  | "doctorArabic_DESC"
  | "doctorName_ASC"
  | "doctorName_DESC"
  | "gender_ASC"
  | "gender_DESC"
  | "isRead_ASC"
  | "isRead_DESC"
  | "phone_ASC"
  | "phone_DESC"
  | "phoneCode_ASC"
  | "phoneCode_DESC"
  | "status_ASC"
  | "status_DESC";

export type BlogOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "bannerImage_ASC"
  | "bannerImage_DESC"
  | "createdDate_ASC"
  | "createdDate_DESC"
  | "name_ASC"
  | "name_DESC"
  | "status_ASC"
  | "status_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type PostImageOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "isDefault_ASC"
  | "isDefault_DESC"
  | "pic_ASC"
  | "pic_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type BlogCommentOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "commentator_ASC"
  | "commentator_DESC"
  | "commentatorName_ASC"
  | "commentatorName_DESC"
  | "comments_ASC"
  | "comments_DESC"
  | "logCreated_ASC"
  | "logCreated_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type BlogPostOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "logCreated_ASC"
  | "logCreated_DESC"
  | "postContent_ASC"
  | "postContent_DESC"
  | "postTitle_ASC"
  | "postTitle_DESC"
  | "status_ASC"
  | "status_DESC"
  | "totalViewers_ASC"
  | "totalViewers_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CityOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "city_ASC"
  | "city_DESC"
  | "cityArabic_ASC"
  | "cityArabic_DESC"
  | "countryId_ASC"
  | "countryId_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ContactUsOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "address_ASC"
  | "address_DESC"
  | "email_ASC"
  | "email_DESC"
  | "lat_ASC"
  | "lat_DESC"
  | "lon_ASC"
  | "lon_DESC"
  | "phone_ASC"
  | "phone_DESC"
  | "pobox_ASC"
  | "pobox_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CountryOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "country_ASC"
  | "country_DESC"
  | "countryArabic_ASC"
  | "countryArabic_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type DiseaseOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "disease_ASC"
  | "disease_DESC"
  | "diseaseArabic_ASC"
  | "diseaseArabic_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type DiseaseCoveredOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "diseaseId_ASC"
  | "diseaseId_DESC"
  | "insuranceCatId_ASC"
  | "insuranceCatId_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type DoctorsRatingOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "rating_ASC"
  | "rating_DESC"
  | "systemIp_ASC"
  | "systemIp_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type DoctorOldOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "apiKey_ASC"
  | "apiKey_DESC"
  | "createdDate_ASC"
  | "createdDate_DESC"
  | "designation_ASC"
  | "designation_DESC"
  | "doctorCv_ASC"
  | "doctorCv_DESC"
  | "email_ASC"
  | "email_DESC"
  | "gender_ASC"
  | "gender_DESC"
  | "mohcard_ASC"
  | "mohcard_DESC"
  | "mohId_ASC"
  | "mohId_DESC"
  | "name_ASC"
  | "name_DESC"
  | "nameArabic_ASC"
  | "nameArabic_DESC"
  | "password_ASC"
  | "password_DESC"
  | "phone_ASC"
  | "phone_DESC"
  | "fees_ASC"
  | "fees_DESC"
  | "picture_ASC"
  | "picture_DESC"
  | "status_ASC"
  | "status_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type DoctorSheduleOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "date_ASC"
  | "date_DESC"
  | "doctorId_ASC"
  | "doctorId_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type DoctorSheduleTimeOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "drSheduleId_ASC"
  | "drSheduleId_DESC"
  | "scheduleTime_ASC"
  | "scheduleTime_DESC"
  | "status_ASC"
  | "status_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type DrSheduleOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "date_ASC"
  | "date_DESC"
  | "doctorId_ASC"
  | "doctorId_DESC"
  | "hospitalId_ASC"
  | "hospitalId_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type EmailSubscriptionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "email_ASC"
  | "email_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type FacilityOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "facility_ASC"
  | "facility_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type HospitalFacilityOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "facilityId_ASC"
  | "facilityId_DESC"
  | "hospitalId_ASC"
  | "hospitalId_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type HospitalRatingOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "hospitalId_ASC"
  | "hospitalId_DESC"
  | "rating_ASC"
  | "rating_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type IllnessOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "illness_ASC"
  | "illness_DESC"
  | "illnessArabic_ASC"
  | "illnessArabic_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type InsuranceCategoryOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "category_ASC"
  | "category_DESC"
  | "insuranceId_ASC"
  | "insuranceId_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type JobOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "position_ASC"
  | "position_DESC"
  | "positionArabic_ASC"
  | "positionArabic_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type LanguageOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "language_ASC"
  | "language_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MessageOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "fromUser_ASC"
  | "fromUser_DESC"
  | "isDelete_ASC"
  | "isDelete_DESC"
  | "isRead_ASC"
  | "isRead_DESC"
  | "logCreate_ASC"
  | "logCreate_DESC"
  | "message_ASC"
  | "message_DESC"
  | "sentBy_ASC"
  | "sentBy_DESC"
  | "toUser_ASC"
  | "toUser_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MigrationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "batch_ASC"
  | "batch_DESC"
  | "migration_ASC"
  | "migration_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type OfferOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "description_ASC"
  | "description_DESC"
  | "descriptionArabic_ASC"
  | "descriptionArabic_DESC"
  | "endDate_ASC"
  | "endDate_DESC"
  | "heading_ASC"
  | "heading_DESC"
  | "headingArabic_ASC"
  | "headingArabic_DESC"
  | "hospitalId_ASC"
  | "hospitalId_DESC"
  | "offerImage_ASC"
  | "offerImage_DESC"
  | "position_ASC"
  | "position_DESC"
  | "startDate_ASC"
  | "startDate_DESC"
  | "status_ASC"
  | "status_DESC"
  | "type_ASC"
  | "type_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type OnlineAppointmentOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "apointmentDate_ASC"
  | "apointmentDate_DESC"
  | "apointmentFulldate_ASC"
  | "apointmentFulldate_DESC"
  | "apointmentTime_ASC"
  | "apointmentTime_DESC"
  | "diseaseId_ASC"
  | "diseaseId_DESC"
  | "doctorArabic_ASC"
  | "doctorArabic_DESC"
  | "doctorId_ASC"
  | "doctorId_DESC"
  | "doctorName_ASC"
  | "doctorName_DESC"
  | "dtId_ASC"
  | "dtId_DESC"
  | "gender_ASC"
  | "gender_DESC"
  | "optId_ASC"
  | "optId_DESC"
  | "patientId_ASC"
  | "patientId_DESC"
  | "phone_ASC"
  | "phone_DESC"
  | "phoneCode_ASC"
  | "phoneCode_DESC"
  | "scheduleTimeId_ASC"
  | "scheduleTimeId_DESC"
  | "status_ASC"
  | "status_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type OnlineDoctorOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "apiKey_ASC"
  | "apiKey_DESC"
  | "createdDate_ASC"
  | "createdDate_DESC"
  | "designation_ASC"
  | "designation_DESC"
  | "doctorCv_ASC"
  | "doctorCv_DESC"
  | "email_ASC"
  | "email_DESC"
  | "gender_ASC"
  | "gender_DESC"
  | "lastSeen_ASC"
  | "lastSeen_DESC"
  | "mohcard_ASC"
  | "mohcard_DESC"
  | "mohId_ASC"
  | "mohId_DESC"
  | "name_ASC"
  | "name_DESC"
  | "nameArabic_ASC"
  | "nameArabic_DESC"
  | "password_ASC"
  | "password_DESC"
  | "phone_ASC"
  | "phone_DESC"
  | "picture_ASC"
  | "picture_DESC"
  | "specialityId_ASC"
  | "specialityId_DESC"
  | "status_ASC"
  | "status_DESC";

export type OnlineRatingOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "doctorsId_ASC"
  | "doctorsId_DESC"
  | "rating_ASC"
  | "rating_DESC"
  | "systemIp_ASC"
  | "systemIp_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type OptTimeOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "fifteenMins_ASC"
  | "fifteenMins_DESC"
  | "thirtyMins_ASC"
  | "thirtyMins_DESC"
  | "twentyMins_ASC"
  | "twentyMins_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type PageOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "slug_ASC"
  | "slug_DESC"
  | "slug_ar_ASC"
  | "slug_ar_DESC"
  | "title_ASC"
  | "title_DESC"
  | "title_ar_ASC"
  | "title_ar_DESC"
  | "content_ASC"
  | "content_DESC"
  | "content_ar_ASC"
  | "content_ar_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type PasswordResetOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "email_ASC"
  | "email_DESC"
  | "token_ASC"
  | "token_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type PatientOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "age_ASC"
  | "age_DESC"
  | "apiKey_ASC"
  | "apiKey_DESC"
  | "createdDate_ASC"
  | "createdDate_DESC"
  | "dob_ASC"
  | "dob_DESC"
  | "email_ASC"
  | "email_DESC"
  | "gender_ASC"
  | "gender_DESC"
  | "lastAction_ASC"
  | "lastAction_DESC"
  | "lastSeen_ASC"
  | "lastSeen_DESC"
  | "mailSubs_ASC"
  | "mailSubs_DESC"
  | "mobile_ASC"
  | "mobile_DESC"
  | "name_ASC"
  | "name_DESC"
  | "password_ASC"
  | "password_DESC"
  | "status_ASC"
  | "status_DESC"
  | "uniqeId_ASC"
  | "uniqeId_DESC";

export type SearchDesignOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "addressColor_ASC"
  | "addressColor_DESC"
  | "addressFamily_ASC"
  | "addressFamily_DESC"
  | "addressStyle_ASC"
  | "addressStyle_DESC"
  | "designationColor_ASC"
  | "designationColor_DESC"
  | "designationFamily_ASC"
  | "designationFamily_DESC"
  | "designationStyle_ASC"
  | "designationStyle_DESC"
  | "doctorColor_ASC"
  | "doctorColor_DESC"
  | "doctorFamily_ASC"
  | "doctorFamily_DESC"
  | "doctorStyle_ASC"
  | "doctorStyle_DESC"
  | "emailColor_ASC"
  | "emailColor_DESC"
  | "emailFamily_ASC"
  | "emailFamily_DESC"
  | "emailStyle_ASC"
  | "emailStyle_DESC"
  | "nameColor_ASC"
  | "nameColor_DESC"
  | "nameFamily_ASC"
  | "nameFamily_DESC"
  | "nameStyle_ASC"
  | "nameStyle_DESC"
  | "phoneColor_ASC"
  | "phoneColor_DESC"
  | "phoneFamily_ASC"
  | "phoneFamily_DESC"
  | "phoneStyle_ASC"
  | "phoneStyle_DESC"
  | "ratingColor_ASC"
  | "ratingColor_DESC"
  | "ratingFamily_ASC"
  | "ratingFamily_DESC"
  | "ratingStyle_ASC"
  | "ratingStyle_DESC"
  | "specialityColor_ASC"
  | "specialityColor_DESC"
  | "specialityFamily_ASC"
  | "specialityFamily_DESC"
  | "specialityStyle_ASC"
  | "specialityStyle_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type SheduleTimeOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "drSheduleId_ASC"
  | "drSheduleId_DESC"
  | "scheduleFullDate_ASC"
  | "scheduleFullDate_DESC"
  | "sheduleTime_ASC"
  | "sheduleTime_DESC"
  | "status_ASC"
  | "status_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type SliderOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "arabicHeading_ASC"
  | "arabicHeading_DESC"
  | "banner_ASC"
  | "banner_DESC"
  | "heading_ASC"
  | "heading_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type SpecialityOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "speciality_ASC"
  | "speciality_DESC"
  | "specialityArabic_ASC"
  | "specialityArabic_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type TranslationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "arabi_ASC"
  | "arabi_DESC"
  | "english_ASC"
  | "english_DESC"
  | "index_ASC"
  | "index_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "email_ASC"
  | "email_DESC"
  | "name_ASC"
  | "name_DESC"
  | "password_ASC"
  | "password_DESC"
  | "rememberToken_ASC"
  | "rememberToken_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type VideoRequestOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "doctorId_ASC"
  | "doctorId_DESC"
  | "joinCall_ASC"
  | "joinCall_DESC"
  | "patientId_ASC"
  | "patientId_DESC"
  | "requestDate_ASC"
  | "requestDate_DESC"
  | "videoCode_ASC"
  | "videoCode_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type VisitorOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "country_ASC"
  | "country_DESC"
  | "hits_ASC"
  | "hits_DESC"
  | "ipAddress_ASC"
  | "ipAddress_DESC"
  | "visitDate_ASC"
  | "visitDate_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type AboutUsWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export interface AboutUsWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  arabicContent?: Maybe<String>;
  arabicContent_not?: Maybe<String>;
  arabicContent_in?: Maybe<String[] | String>;
  arabicContent_not_in?: Maybe<String[] | String>;
  arabicContent_lt?: Maybe<String>;
  arabicContent_lte?: Maybe<String>;
  arabicContent_gt?: Maybe<String>;
  arabicContent_gte?: Maybe<String>;
  arabicContent_contains?: Maybe<String>;
  arabicContent_not_contains?: Maybe<String>;
  arabicContent_starts_with?: Maybe<String>;
  arabicContent_not_starts_with?: Maybe<String>;
  arabicContent_ends_with?: Maybe<String>;
  arabicContent_not_ends_with?: Maybe<String>;
  englishContent?: Maybe<String>;
  englishContent_not?: Maybe<String>;
  englishContent_in?: Maybe<String[] | String>;
  englishContent_not_in?: Maybe<String[] | String>;
  englishContent_lt?: Maybe<String>;
  englishContent_lte?: Maybe<String>;
  englishContent_gt?: Maybe<String>;
  englishContent_gte?: Maybe<String>;
  englishContent_contains?: Maybe<String>;
  englishContent_not_contains?: Maybe<String>;
  englishContent_starts_with?: Maybe<String>;
  englishContent_not_starts_with?: Maybe<String>;
  englishContent_ends_with?: Maybe<String>;
  englishContent_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<AboutUsWhereInput[] | AboutUsWhereInput>;
  OR?: Maybe<AboutUsWhereInput[] | AboutUsWhereInput>;
  NOT?: Maybe<AboutUsWhereInput[] | AboutUsWhereInput>;
}

export type AdminWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
  email?: Maybe<String>;
  user?: Maybe<String>;
}>;

export interface AdminWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  pass?: Maybe<String>;
  pass_not?: Maybe<String>;
  pass_in?: Maybe<String[] | String>;
  pass_not_in?: Maybe<String[] | String>;
  pass_lt?: Maybe<String>;
  pass_lte?: Maybe<String>;
  pass_gt?: Maybe<String>;
  pass_gte?: Maybe<String>;
  pass_contains?: Maybe<String>;
  pass_not_contains?: Maybe<String>;
  pass_starts_with?: Maybe<String>;
  pass_not_starts_with?: Maybe<String>;
  pass_ends_with?: Maybe<String>;
  pass_not_ends_with?: Maybe<String>;
  superAdmin?: Maybe<Int>;
  superAdmin_not?: Maybe<Int>;
  superAdmin_in?: Maybe<Int[] | Int>;
  superAdmin_not_in?: Maybe<Int[] | Int>;
  superAdmin_lt?: Maybe<Int>;
  superAdmin_lte?: Maybe<Int>;
  superAdmin_gt?: Maybe<Int>;
  superAdmin_gte?: Maybe<Int>;
  user?: Maybe<String>;
  user_not?: Maybe<String>;
  user_in?: Maybe<String[] | String>;
  user_not_in?: Maybe<String[] | String>;
  user_lt?: Maybe<String>;
  user_lte?: Maybe<String>;
  user_gt?: Maybe<String>;
  user_gte?: Maybe<String>;
  user_contains?: Maybe<String>;
  user_not_contains?: Maybe<String>;
  user_starts_with?: Maybe<String>;
  user_not_starts_with?: Maybe<String>;
  user_ends_with?: Maybe<String>;
  user_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<AdminWhereInput[] | AdminWhereInput>;
  OR?: Maybe<AdminWhereInput[] | AdminWhereInput>;
  NOT?: Maybe<AdminWhereInput[] | AdminWhereInput>;
}

export type AppointmentWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export interface DoctorWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  apiKey?: Maybe<String>;
  apiKey_not?: Maybe<String>;
  apiKey_in?: Maybe<String[] | String>;
  apiKey_not_in?: Maybe<String[] | String>;
  apiKey_lt?: Maybe<String>;
  apiKey_lte?: Maybe<String>;
  apiKey_gt?: Maybe<String>;
  apiKey_gte?: Maybe<String>;
  apiKey_contains?: Maybe<String>;
  apiKey_not_contains?: Maybe<String>;
  apiKey_starts_with?: Maybe<String>;
  apiKey_not_starts_with?: Maybe<String>;
  apiKey_ends_with?: Maybe<String>;
  apiKey_not_ends_with?: Maybe<String>;
  designation?: Maybe<String>;
  designation_not?: Maybe<String>;
  designation_in?: Maybe<String[] | String>;
  designation_not_in?: Maybe<String[] | String>;
  designation_lt?: Maybe<String>;
  designation_lte?: Maybe<String>;
  designation_gt?: Maybe<String>;
  designation_gte?: Maybe<String>;
  designation_contains?: Maybe<String>;
  designation_not_contains?: Maybe<String>;
  designation_starts_with?: Maybe<String>;
  designation_not_starts_with?: Maybe<String>;
  designation_ends_with?: Maybe<String>;
  designation_not_ends_with?: Maybe<String>;
  doctorCv?: Maybe<String>;
  doctorCv_not?: Maybe<String>;
  doctorCv_in?: Maybe<String[] | String>;
  doctorCv_not_in?: Maybe<String[] | String>;
  doctorCv_lt?: Maybe<String>;
  doctorCv_lte?: Maybe<String>;
  doctorCv_gt?: Maybe<String>;
  doctorCv_gte?: Maybe<String>;
  doctorCv_contains?: Maybe<String>;
  doctorCv_not_contains?: Maybe<String>;
  doctorCv_starts_with?: Maybe<String>;
  doctorCv_not_starts_with?: Maybe<String>;
  doctorCv_ends_with?: Maybe<String>;
  doctorCv_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  gender?: Maybe<String>;
  gender_not?: Maybe<String>;
  gender_in?: Maybe<String[] | String>;
  gender_not_in?: Maybe<String[] | String>;
  gender_lt?: Maybe<String>;
  gender_lte?: Maybe<String>;
  gender_gt?: Maybe<String>;
  gender_gte?: Maybe<String>;
  gender_contains?: Maybe<String>;
  gender_not_contains?: Maybe<String>;
  gender_starts_with?: Maybe<String>;
  gender_not_starts_with?: Maybe<String>;
  gender_ends_with?: Maybe<String>;
  gender_not_ends_with?: Maybe<String>;
  mohcard?: Maybe<String>;
  mohcard_not?: Maybe<String>;
  mohcard_in?: Maybe<String[] | String>;
  mohcard_not_in?: Maybe<String[] | String>;
  mohcard_lt?: Maybe<String>;
  mohcard_lte?: Maybe<String>;
  mohcard_gt?: Maybe<String>;
  mohcard_gte?: Maybe<String>;
  mohcard_contains?: Maybe<String>;
  mohcard_not_contains?: Maybe<String>;
  mohcard_starts_with?: Maybe<String>;
  mohcard_not_starts_with?: Maybe<String>;
  mohcard_ends_with?: Maybe<String>;
  mohcard_not_ends_with?: Maybe<String>;
  mohId?: Maybe<String>;
  mohId_not?: Maybe<String>;
  mohId_in?: Maybe<String[] | String>;
  mohId_not_in?: Maybe<String[] | String>;
  mohId_lt?: Maybe<String>;
  mohId_lte?: Maybe<String>;
  mohId_gt?: Maybe<String>;
  mohId_gte?: Maybe<String>;
  mohId_contains?: Maybe<String>;
  mohId_not_contains?: Maybe<String>;
  mohId_starts_with?: Maybe<String>;
  mohId_not_starts_with?: Maybe<String>;
  mohId_ends_with?: Maybe<String>;
  mohId_not_ends_with?: Maybe<String>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  nameArabic?: Maybe<String>;
  nameArabic_not?: Maybe<String>;
  nameArabic_in?: Maybe<String[] | String>;
  nameArabic_not_in?: Maybe<String[] | String>;
  nameArabic_lt?: Maybe<String>;
  nameArabic_lte?: Maybe<String>;
  nameArabic_gt?: Maybe<String>;
  nameArabic_gte?: Maybe<String>;
  nameArabic_contains?: Maybe<String>;
  nameArabic_not_contains?: Maybe<String>;
  nameArabic_starts_with?: Maybe<String>;
  nameArabic_not_starts_with?: Maybe<String>;
  nameArabic_ends_with?: Maybe<String>;
  nameArabic_not_ends_with?: Maybe<String>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  phone?: Maybe<String>;
  phone_not?: Maybe<String>;
  phone_in?: Maybe<String[] | String>;
  phone_not_in?: Maybe<String[] | String>;
  phone_lt?: Maybe<String>;
  phone_lte?: Maybe<String>;
  phone_gt?: Maybe<String>;
  phone_gte?: Maybe<String>;
  phone_contains?: Maybe<String>;
  phone_not_contains?: Maybe<String>;
  phone_starts_with?: Maybe<String>;
  phone_not_starts_with?: Maybe<String>;
  phone_ends_with?: Maybe<String>;
  phone_not_ends_with?: Maybe<String>;
  fees?: Maybe<String>;
  fees_not?: Maybe<String>;
  fees_in?: Maybe<String[] | String>;
  fees_not_in?: Maybe<String[] | String>;
  fees_lt?: Maybe<String>;
  fees_lte?: Maybe<String>;
  fees_gt?: Maybe<String>;
  fees_gte?: Maybe<String>;
  fees_contains?: Maybe<String>;
  fees_not_contains?: Maybe<String>;
  fees_starts_with?: Maybe<String>;
  fees_not_starts_with?: Maybe<String>;
  fees_ends_with?: Maybe<String>;
  fees_not_ends_with?: Maybe<String>;
  picture?: Maybe<String>;
  picture_not?: Maybe<String>;
  picture_in?: Maybe<String[] | String>;
  picture_not_in?: Maybe<String[] | String>;
  picture_lt?: Maybe<String>;
  picture_lte?: Maybe<String>;
  picture_gt?: Maybe<String>;
  picture_gte?: Maybe<String>;
  picture_contains?: Maybe<String>;
  picture_not_contains?: Maybe<String>;
  picture_starts_with?: Maybe<String>;
  picture_not_starts_with?: Maybe<String>;
  picture_ends_with?: Maybe<String>;
  picture_not_ends_with?: Maybe<String>;
  specialityId?: Maybe<Int>;
  specialityId_not?: Maybe<Int>;
  specialityId_in?: Maybe<Int[] | Int>;
  specialityId_not_in?: Maybe<Int[] | Int>;
  specialityId_lt?: Maybe<Int>;
  specialityId_lte?: Maybe<Int>;
  specialityId_gt?: Maybe<Int>;
  specialityId_gte?: Maybe<Int>;
  specialities?: Maybe<SpecialityWhereInput>;
  hospital_every?: Maybe<HospitalWhereInput>;
  hospital_some?: Maybe<HospitalWhereInput>;
  hospital_none?: Maybe<HospitalWhereInput>;
  status?: Maybe<Int>;
  status_not?: Maybe<Int>;
  status_in?: Maybe<Int[] | Int>;
  status_not_in?: Maybe<Int[] | Int>;
  status_lt?: Maybe<Int>;
  status_lte?: Maybe<Int>;
  status_gt?: Maybe<Int>;
  status_gte?: Maybe<Int>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  createdDate?: Maybe<DateTimeInput>;
  createdDate_not?: Maybe<DateTimeInput>;
  createdDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdDate_lt?: Maybe<DateTimeInput>;
  createdDate_lte?: Maybe<DateTimeInput>;
  createdDate_gt?: Maybe<DateTimeInput>;
  createdDate_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<DoctorWhereInput[] | DoctorWhereInput>;
  OR?: Maybe<DoctorWhereInput[] | DoctorWhereInput>;
  NOT?: Maybe<DoctorWhereInput[] | DoctorWhereInput>;
}

export interface SpecialityWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  doctors_every?: Maybe<DoctorWhereInput>;
  doctors_some?: Maybe<DoctorWhereInput>;
  doctors_none?: Maybe<DoctorWhereInput>;
  speciality?: Maybe<String>;
  speciality_not?: Maybe<String>;
  speciality_in?: Maybe<String[] | String>;
  speciality_not_in?: Maybe<String[] | String>;
  speciality_lt?: Maybe<String>;
  speciality_lte?: Maybe<String>;
  speciality_gt?: Maybe<String>;
  speciality_gte?: Maybe<String>;
  speciality_contains?: Maybe<String>;
  speciality_not_contains?: Maybe<String>;
  speciality_starts_with?: Maybe<String>;
  speciality_not_starts_with?: Maybe<String>;
  speciality_ends_with?: Maybe<String>;
  speciality_not_ends_with?: Maybe<String>;
  specialityArabic?: Maybe<String>;
  specialityArabic_not?: Maybe<String>;
  specialityArabic_in?: Maybe<String[] | String>;
  specialityArabic_not_in?: Maybe<String[] | String>;
  specialityArabic_lt?: Maybe<String>;
  specialityArabic_lte?: Maybe<String>;
  specialityArabic_gt?: Maybe<String>;
  specialityArabic_gte?: Maybe<String>;
  specialityArabic_contains?: Maybe<String>;
  specialityArabic_not_contains?: Maybe<String>;
  specialityArabic_starts_with?: Maybe<String>;
  specialityArabic_not_starts_with?: Maybe<String>;
  specialityArabic_ends_with?: Maybe<String>;
  specialityArabic_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<SpecialityWhereInput[] | SpecialityWhereInput>;
  OR?: Maybe<SpecialityWhereInput[] | SpecialityWhereInput>;
  NOT?: Maybe<SpecialityWhereInput[] | SpecialityWhereInput>;
}

export interface HospitalWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  address?: Maybe<String>;
  address_not?: Maybe<String>;
  address_in?: Maybe<String[] | String>;
  address_not_in?: Maybe<String[] | String>;
  address_lt?: Maybe<String>;
  address_lte?: Maybe<String>;
  address_gt?: Maybe<String>;
  address_gte?: Maybe<String>;
  address_contains?: Maybe<String>;
  address_not_contains?: Maybe<String>;
  address_starts_with?: Maybe<String>;
  address_not_starts_with?: Maybe<String>;
  address_ends_with?: Maybe<String>;
  address_not_ends_with?: Maybe<String>;
  addressArabic?: Maybe<String>;
  addressArabic_not?: Maybe<String>;
  addressArabic_in?: Maybe<String[] | String>;
  addressArabic_not_in?: Maybe<String[] | String>;
  addressArabic_lt?: Maybe<String>;
  addressArabic_lte?: Maybe<String>;
  addressArabic_gt?: Maybe<String>;
  addressArabic_gte?: Maybe<String>;
  addressArabic_contains?: Maybe<String>;
  addressArabic_not_contains?: Maybe<String>;
  addressArabic_starts_with?: Maybe<String>;
  addressArabic_not_starts_with?: Maybe<String>;
  addressArabic_ends_with?: Maybe<String>;
  addressArabic_not_ends_with?: Maybe<String>;
  apiKey?: Maybe<String>;
  apiKey_not?: Maybe<String>;
  apiKey_in?: Maybe<String[] | String>;
  apiKey_not_in?: Maybe<String[] | String>;
  apiKey_lt?: Maybe<String>;
  apiKey_lte?: Maybe<String>;
  apiKey_gt?: Maybe<String>;
  apiKey_gte?: Maybe<String>;
  apiKey_contains?: Maybe<String>;
  apiKey_not_contains?: Maybe<String>;
  apiKey_starts_with?: Maybe<String>;
  apiKey_not_starts_with?: Maybe<String>;
  apiKey_ends_with?: Maybe<String>;
  apiKey_not_ends_with?: Maybe<String>;
  city?: Maybe<CityWhereInput>;
  countryId?: Maybe<CountryWhereInput>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  hospital?: Maybe<String>;
  hospital_not?: Maybe<String>;
  hospital_in?: Maybe<String[] | String>;
  hospital_not_in?: Maybe<String[] | String>;
  hospital_lt?: Maybe<String>;
  hospital_lte?: Maybe<String>;
  hospital_gt?: Maybe<String>;
  hospital_gte?: Maybe<String>;
  hospital_contains?: Maybe<String>;
  hospital_not_contains?: Maybe<String>;
  hospital_starts_with?: Maybe<String>;
  hospital_not_starts_with?: Maybe<String>;
  hospital_ends_with?: Maybe<String>;
  hospital_not_ends_with?: Maybe<String>;
  hospitalArabic?: Maybe<String>;
  hospitalArabic_not?: Maybe<String>;
  hospitalArabic_in?: Maybe<String[] | String>;
  hospitalArabic_not_in?: Maybe<String[] | String>;
  hospitalArabic_lt?: Maybe<String>;
  hospitalArabic_lte?: Maybe<String>;
  hospitalArabic_gt?: Maybe<String>;
  hospitalArabic_gte?: Maybe<String>;
  hospitalArabic_contains?: Maybe<String>;
  hospitalArabic_not_contains?: Maybe<String>;
  hospitalArabic_starts_with?: Maybe<String>;
  hospitalArabic_not_starts_with?: Maybe<String>;
  hospitalArabic_ends_with?: Maybe<String>;
  hospitalArabic_not_ends_with?: Maybe<String>;
  doctors_every?: Maybe<DoctorWhereInput>;
  doctors_some?: Maybe<DoctorWhereInput>;
  doctors_none?: Maybe<DoctorWhereInput>;
  language?: Maybe<String>;
  language_not?: Maybe<String>;
  language_in?: Maybe<String[] | String>;
  language_not_in?: Maybe<String[] | String>;
  language_lt?: Maybe<String>;
  language_lte?: Maybe<String>;
  language_gt?: Maybe<String>;
  language_gte?: Maybe<String>;
  language_contains?: Maybe<String>;
  language_not_contains?: Maybe<String>;
  language_starts_with?: Maybe<String>;
  language_not_starts_with?: Maybe<String>;
  language_ends_with?: Maybe<String>;
  language_not_ends_with?: Maybe<String>;
  latitude?: Maybe<String>;
  latitude_not?: Maybe<String>;
  latitude_in?: Maybe<String[] | String>;
  latitude_not_in?: Maybe<String[] | String>;
  latitude_lt?: Maybe<String>;
  latitude_lte?: Maybe<String>;
  latitude_gt?: Maybe<String>;
  latitude_gte?: Maybe<String>;
  latitude_contains?: Maybe<String>;
  latitude_not_contains?: Maybe<String>;
  latitude_starts_with?: Maybe<String>;
  latitude_not_starts_with?: Maybe<String>;
  latitude_ends_with?: Maybe<String>;
  latitude_not_ends_with?: Maybe<String>;
  location?: Maybe<String>;
  location_not?: Maybe<String>;
  location_in?: Maybe<String[] | String>;
  location_not_in?: Maybe<String[] | String>;
  location_lt?: Maybe<String>;
  location_lte?: Maybe<String>;
  location_gt?: Maybe<String>;
  location_gte?: Maybe<String>;
  location_contains?: Maybe<String>;
  location_not_contains?: Maybe<String>;
  location_starts_with?: Maybe<String>;
  location_not_starts_with?: Maybe<String>;
  location_ends_with?: Maybe<String>;
  location_not_ends_with?: Maybe<String>;
  logo?: Maybe<String>;
  logo_not?: Maybe<String>;
  logo_in?: Maybe<String[] | String>;
  logo_not_in?: Maybe<String[] | String>;
  logo_lt?: Maybe<String>;
  logo_lte?: Maybe<String>;
  logo_gt?: Maybe<String>;
  logo_gte?: Maybe<String>;
  logo_contains?: Maybe<String>;
  logo_not_contains?: Maybe<String>;
  logo_starts_with?: Maybe<String>;
  logo_not_starts_with?: Maybe<String>;
  logo_ends_with?: Maybe<String>;
  logo_not_ends_with?: Maybe<String>;
  longitude?: Maybe<String>;
  longitude_not?: Maybe<String>;
  longitude_in?: Maybe<String[] | String>;
  longitude_not_in?: Maybe<String[] | String>;
  longitude_lt?: Maybe<String>;
  longitude_lte?: Maybe<String>;
  longitude_gt?: Maybe<String>;
  longitude_gte?: Maybe<String>;
  longitude_contains?: Maybe<String>;
  longitude_not_contains?: Maybe<String>;
  longitude_starts_with?: Maybe<String>;
  longitude_not_starts_with?: Maybe<String>;
  longitude_ends_with?: Maybe<String>;
  longitude_not_ends_with?: Maybe<String>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  phone?: Maybe<String>;
  phone_not?: Maybe<String>;
  phone_in?: Maybe<String[] | String>;
  phone_not_in?: Maybe<String[] | String>;
  phone_lt?: Maybe<String>;
  phone_lte?: Maybe<String>;
  phone_gt?: Maybe<String>;
  phone_gte?: Maybe<String>;
  phone_contains?: Maybe<String>;
  phone_not_contains?: Maybe<String>;
  phone_starts_with?: Maybe<String>;
  phone_not_starts_with?: Maybe<String>;
  phone_ends_with?: Maybe<String>;
  phone_not_ends_with?: Maybe<String>;
  phone1?: Maybe<String>;
  phone1_not?: Maybe<String>;
  phone1_in?: Maybe<String[] | String>;
  phone1_not_in?: Maybe<String[] | String>;
  phone1_lt?: Maybe<String>;
  phone1_lte?: Maybe<String>;
  phone1_gt?: Maybe<String>;
  phone1_gte?: Maybe<String>;
  phone1_contains?: Maybe<String>;
  phone1_not_contains?: Maybe<String>;
  phone1_starts_with?: Maybe<String>;
  phone1_not_starts_with?: Maybe<String>;
  phone1_ends_with?: Maybe<String>;
  phone1_not_ends_with?: Maybe<String>;
  status?: Maybe<Int>;
  status_not?: Maybe<Int>;
  status_in?: Maybe<Int[] | Int>;
  status_not_in?: Maybe<Int[] | Int>;
  status_lt?: Maybe<Int>;
  status_lte?: Maybe<Int>;
  status_gt?: Maybe<Int>;
  status_gte?: Maybe<Int>;
  type?: Maybe<String>;
  type_not?: Maybe<String>;
  type_in?: Maybe<String[] | String>;
  type_not_in?: Maybe<String[] | String>;
  type_lt?: Maybe<String>;
  type_lte?: Maybe<String>;
  type_gt?: Maybe<String>;
  type_gte?: Maybe<String>;
  type_contains?: Maybe<String>;
  type_not_contains?: Maybe<String>;
  type_starts_with?: Maybe<String>;
  type_not_starts_with?: Maybe<String>;
  type_ends_with?: Maybe<String>;
  type_not_ends_with?: Maybe<String>;
  uniqeId?: Maybe<String>;
  uniqeId_not?: Maybe<String>;
  uniqeId_in?: Maybe<String[] | String>;
  uniqeId_not_in?: Maybe<String[] | String>;
  uniqeId_lt?: Maybe<String>;
  uniqeId_lte?: Maybe<String>;
  uniqeId_gt?: Maybe<String>;
  uniqeId_gte?: Maybe<String>;
  uniqeId_contains?: Maybe<String>;
  uniqeId_not_contains?: Maybe<String>;
  uniqeId_starts_with?: Maybe<String>;
  uniqeId_not_starts_with?: Maybe<String>;
  uniqeId_ends_with?: Maybe<String>;
  uniqeId_not_ends_with?: Maybe<String>;
  insurances_every?: Maybe<InsuranceWhereInput>;
  insurances_some?: Maybe<InsuranceWhereInput>;
  insurances_none?: Maybe<InsuranceWhereInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  createdDate?: Maybe<DateTimeInput>;
  createdDate_not?: Maybe<DateTimeInput>;
  createdDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdDate_lt?: Maybe<DateTimeInput>;
  createdDate_lte?: Maybe<DateTimeInput>;
  createdDate_gt?: Maybe<DateTimeInput>;
  createdDate_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<HospitalWhereInput[] | HospitalWhereInput>;
  OR?: Maybe<HospitalWhereInput[] | HospitalWhereInput>;
  NOT?: Maybe<HospitalWhereInput[] | HospitalWhereInput>;
}

export interface CityWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  city?: Maybe<String>;
  city_not?: Maybe<String>;
  city_in?: Maybe<String[] | String>;
  city_not_in?: Maybe<String[] | String>;
  city_lt?: Maybe<String>;
  city_lte?: Maybe<String>;
  city_gt?: Maybe<String>;
  city_gte?: Maybe<String>;
  city_contains?: Maybe<String>;
  city_not_contains?: Maybe<String>;
  city_starts_with?: Maybe<String>;
  city_not_starts_with?: Maybe<String>;
  city_ends_with?: Maybe<String>;
  city_not_ends_with?: Maybe<String>;
  cityArabic?: Maybe<String>;
  cityArabic_not?: Maybe<String>;
  cityArabic_in?: Maybe<String[] | String>;
  cityArabic_not_in?: Maybe<String[] | String>;
  cityArabic_lt?: Maybe<String>;
  cityArabic_lte?: Maybe<String>;
  cityArabic_gt?: Maybe<String>;
  cityArabic_gte?: Maybe<String>;
  cityArabic_contains?: Maybe<String>;
  cityArabic_not_contains?: Maybe<String>;
  cityArabic_starts_with?: Maybe<String>;
  cityArabic_not_starts_with?: Maybe<String>;
  cityArabic_ends_with?: Maybe<String>;
  cityArabic_not_ends_with?: Maybe<String>;
  countryId?: Maybe<Int>;
  countryId_not?: Maybe<Int>;
  countryId_in?: Maybe<Int[] | Int>;
  countryId_not_in?: Maybe<Int[] | Int>;
  countryId_lt?: Maybe<Int>;
  countryId_lte?: Maybe<Int>;
  countryId_gt?: Maybe<Int>;
  countryId_gte?: Maybe<Int>;
  hospital_every?: Maybe<HospitalWhereInput>;
  hospital_some?: Maybe<HospitalWhereInput>;
  hospital_none?: Maybe<HospitalWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<CityWhereInput[] | CityWhereInput>;
  OR?: Maybe<CityWhereInput[] | CityWhereInput>;
  NOT?: Maybe<CityWhereInput[] | CityWhereInput>;
}

export interface CountryWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  country?: Maybe<String>;
  country_not?: Maybe<String>;
  country_in?: Maybe<String[] | String>;
  country_not_in?: Maybe<String[] | String>;
  country_lt?: Maybe<String>;
  country_lte?: Maybe<String>;
  country_gt?: Maybe<String>;
  country_gte?: Maybe<String>;
  country_contains?: Maybe<String>;
  country_not_contains?: Maybe<String>;
  country_starts_with?: Maybe<String>;
  country_not_starts_with?: Maybe<String>;
  country_ends_with?: Maybe<String>;
  country_not_ends_with?: Maybe<String>;
  countryArabic?: Maybe<String>;
  countryArabic_not?: Maybe<String>;
  countryArabic_in?: Maybe<String[] | String>;
  countryArabic_not_in?: Maybe<String[] | String>;
  countryArabic_lt?: Maybe<String>;
  countryArabic_lte?: Maybe<String>;
  countryArabic_gt?: Maybe<String>;
  countryArabic_gte?: Maybe<String>;
  countryArabic_contains?: Maybe<String>;
  countryArabic_not_contains?: Maybe<String>;
  countryArabic_starts_with?: Maybe<String>;
  countryArabic_not_starts_with?: Maybe<String>;
  countryArabic_ends_with?: Maybe<String>;
  countryArabic_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<CountryWhereInput[] | CountryWhereInput>;
  OR?: Maybe<CountryWhereInput[] | CountryWhereInput>;
  NOT?: Maybe<CountryWhereInput[] | CountryWhereInput>;
}

export interface InsuranceWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  countryId?: Maybe<Int>;
  countryId_not?: Maybe<Int>;
  countryId_in?: Maybe<Int[] | Int>;
  countryId_not_in?: Maybe<Int[] | Int>;
  countryId_lt?: Maybe<Int>;
  countryId_lte?: Maybe<Int>;
  countryId_gt?: Maybe<Int>;
  countryId_gte?: Maybe<Int>;
  hospitals_every?: Maybe<HospitalWhereInput>;
  hospitals_some?: Maybe<HospitalWhereInput>;
  hospitals_none?: Maybe<HospitalWhereInput>;
  insurance?: Maybe<String>;
  insurance_not?: Maybe<String>;
  insurance_in?: Maybe<String[] | String>;
  insurance_not_in?: Maybe<String[] | String>;
  insurance_lt?: Maybe<String>;
  insurance_lte?: Maybe<String>;
  insurance_gt?: Maybe<String>;
  insurance_gte?: Maybe<String>;
  insurance_contains?: Maybe<String>;
  insurance_not_contains?: Maybe<String>;
  insurance_starts_with?: Maybe<String>;
  insurance_not_starts_with?: Maybe<String>;
  insurance_ends_with?: Maybe<String>;
  insurance_not_ends_with?: Maybe<String>;
  insuranceArabic?: Maybe<String>;
  insuranceArabic_not?: Maybe<String>;
  insuranceArabic_in?: Maybe<String[] | String>;
  insuranceArabic_not_in?: Maybe<String[] | String>;
  insuranceArabic_lt?: Maybe<String>;
  insuranceArabic_lte?: Maybe<String>;
  insuranceArabic_gt?: Maybe<String>;
  insuranceArabic_gte?: Maybe<String>;
  insuranceArabic_contains?: Maybe<String>;
  insuranceArabic_not_contains?: Maybe<String>;
  insuranceArabic_starts_with?: Maybe<String>;
  insuranceArabic_not_starts_with?: Maybe<String>;
  insuranceArabic_ends_with?: Maybe<String>;
  insuranceArabic_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<InsuranceWhereInput[] | InsuranceWhereInput>;
  OR?: Maybe<InsuranceWhereInput[] | InsuranceWhereInput>;
  NOT?: Maybe<InsuranceWhereInput[] | InsuranceWhereInput>;
}

export interface AppointmentWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  apointmentDate?: Maybe<String>;
  apointmentDate_not?: Maybe<String>;
  apointmentDate_in?: Maybe<String[] | String>;
  apointmentDate_not_in?: Maybe<String[] | String>;
  apointmentDate_lt?: Maybe<String>;
  apointmentDate_lte?: Maybe<String>;
  apointmentDate_gt?: Maybe<String>;
  apointmentDate_gte?: Maybe<String>;
  apointmentDate_contains?: Maybe<String>;
  apointmentDate_not_contains?: Maybe<String>;
  apointmentDate_starts_with?: Maybe<String>;
  apointmentDate_not_starts_with?: Maybe<String>;
  apointmentDate_ends_with?: Maybe<String>;
  apointmentDate_not_ends_with?: Maybe<String>;
  apointmentFulldate?: Maybe<Int>;
  apointmentFulldate_not?: Maybe<Int>;
  apointmentFulldate_in?: Maybe<Int[] | Int>;
  apointmentFulldate_not_in?: Maybe<Int[] | Int>;
  apointmentFulldate_lt?: Maybe<Int>;
  apointmentFulldate_lte?: Maybe<Int>;
  apointmentFulldate_gt?: Maybe<Int>;
  apointmentFulldate_gte?: Maybe<Int>;
  apointmentTime?: Maybe<String>;
  apointmentTime_not?: Maybe<String>;
  apointmentTime_in?: Maybe<String[] | String>;
  apointmentTime_not_in?: Maybe<String[] | String>;
  apointmentTime_lt?: Maybe<String>;
  apointmentTime_lte?: Maybe<String>;
  apointmentTime_gt?: Maybe<String>;
  apointmentTime_gte?: Maybe<String>;
  apointmentTime_contains?: Maybe<String>;
  apointmentTime_not_contains?: Maybe<String>;
  apointmentTime_starts_with?: Maybe<String>;
  apointmentTime_not_starts_with?: Maybe<String>;
  apointmentTime_ends_with?: Maybe<String>;
  apointmentTime_not_ends_with?: Maybe<String>;
  diseaseId?: Maybe<DiseaseWhereInput>;
  doctorArabic?: Maybe<String>;
  doctorArabic_not?: Maybe<String>;
  doctorArabic_in?: Maybe<String[] | String>;
  doctorArabic_not_in?: Maybe<String[] | String>;
  doctorArabic_lt?: Maybe<String>;
  doctorArabic_lte?: Maybe<String>;
  doctorArabic_gt?: Maybe<String>;
  doctorArabic_gte?: Maybe<String>;
  doctorArabic_contains?: Maybe<String>;
  doctorArabic_not_contains?: Maybe<String>;
  doctorArabic_starts_with?: Maybe<String>;
  doctorArabic_not_starts_with?: Maybe<String>;
  doctorArabic_ends_with?: Maybe<String>;
  doctorArabic_not_ends_with?: Maybe<String>;
  doctorId?: Maybe<DoctorWhereInput>;
  doctorName?: Maybe<String>;
  doctorName_not?: Maybe<String>;
  doctorName_in?: Maybe<String[] | String>;
  doctorName_not_in?: Maybe<String[] | String>;
  doctorName_lt?: Maybe<String>;
  doctorName_lte?: Maybe<String>;
  doctorName_gt?: Maybe<String>;
  doctorName_gte?: Maybe<String>;
  doctorName_contains?: Maybe<String>;
  doctorName_not_contains?: Maybe<String>;
  doctorName_starts_with?: Maybe<String>;
  doctorName_not_starts_with?: Maybe<String>;
  doctorName_ends_with?: Maybe<String>;
  doctorName_not_ends_with?: Maybe<String>;
  dtId?: Maybe<DoctorSheduleTimeWhereInput>;
  gender?: Maybe<String>;
  gender_not?: Maybe<String>;
  gender_in?: Maybe<String[] | String>;
  gender_not_in?: Maybe<String[] | String>;
  gender_lt?: Maybe<String>;
  gender_lte?: Maybe<String>;
  gender_gt?: Maybe<String>;
  gender_gte?: Maybe<String>;
  gender_contains?: Maybe<String>;
  gender_not_contains?: Maybe<String>;
  gender_starts_with?: Maybe<String>;
  gender_not_starts_with?: Maybe<String>;
  gender_ends_with?: Maybe<String>;
  gender_not_ends_with?: Maybe<String>;
  hospitalId?: Maybe<HospitalWhereInput>;
  isRead?: Maybe<Int>;
  isRead_not?: Maybe<Int>;
  isRead_in?: Maybe<Int[] | Int>;
  isRead_not_in?: Maybe<Int[] | Int>;
  isRead_lt?: Maybe<Int>;
  isRead_lte?: Maybe<Int>;
  isRead_gt?: Maybe<Int>;
  isRead_gte?: Maybe<Int>;
  optId?: Maybe<OptTimeWhereInput>;
  patientId?: Maybe<PatientWhereInput>;
  phone?: Maybe<String>;
  phone_not?: Maybe<String>;
  phone_in?: Maybe<String[] | String>;
  phone_not_in?: Maybe<String[] | String>;
  phone_lt?: Maybe<String>;
  phone_lte?: Maybe<String>;
  phone_gt?: Maybe<String>;
  phone_gte?: Maybe<String>;
  phone_contains?: Maybe<String>;
  phone_not_contains?: Maybe<String>;
  phone_starts_with?: Maybe<String>;
  phone_not_starts_with?: Maybe<String>;
  phone_ends_with?: Maybe<String>;
  phone_not_ends_with?: Maybe<String>;
  phoneCode?: Maybe<String>;
  phoneCode_not?: Maybe<String>;
  phoneCode_in?: Maybe<String[] | String>;
  phoneCode_not_in?: Maybe<String[] | String>;
  phoneCode_lt?: Maybe<String>;
  phoneCode_lte?: Maybe<String>;
  phoneCode_gt?: Maybe<String>;
  phoneCode_gte?: Maybe<String>;
  phoneCode_contains?: Maybe<String>;
  phoneCode_not_contains?: Maybe<String>;
  phoneCode_starts_with?: Maybe<String>;
  phoneCode_not_starts_with?: Maybe<String>;
  phoneCode_ends_with?: Maybe<String>;
  phoneCode_not_ends_with?: Maybe<String>;
  scheduleTimeId?: Maybe<SheduleTimeWhereInput>;
  status?: Maybe<Int>;
  status_not?: Maybe<Int>;
  status_in?: Maybe<Int[] | Int>;
  status_not_in?: Maybe<Int[] | Int>;
  status_lt?: Maybe<Int>;
  status_lte?: Maybe<Int>;
  status_gt?: Maybe<Int>;
  status_gte?: Maybe<Int>;
  AND?: Maybe<AppointmentWhereInput[] | AppointmentWhereInput>;
  OR?: Maybe<AppointmentWhereInput[] | AppointmentWhereInput>;
  NOT?: Maybe<AppointmentWhereInput[] | AppointmentWhereInput>;
}

export interface DiseaseWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  disease?: Maybe<String>;
  disease_not?: Maybe<String>;
  disease_in?: Maybe<String[] | String>;
  disease_not_in?: Maybe<String[] | String>;
  disease_lt?: Maybe<String>;
  disease_lte?: Maybe<String>;
  disease_gt?: Maybe<String>;
  disease_gte?: Maybe<String>;
  disease_contains?: Maybe<String>;
  disease_not_contains?: Maybe<String>;
  disease_starts_with?: Maybe<String>;
  disease_not_starts_with?: Maybe<String>;
  disease_ends_with?: Maybe<String>;
  disease_not_ends_with?: Maybe<String>;
  diseaseArabic?: Maybe<String>;
  diseaseArabic_not?: Maybe<String>;
  diseaseArabic_in?: Maybe<String[] | String>;
  diseaseArabic_not_in?: Maybe<String[] | String>;
  diseaseArabic_lt?: Maybe<String>;
  diseaseArabic_lte?: Maybe<String>;
  diseaseArabic_gt?: Maybe<String>;
  diseaseArabic_gte?: Maybe<String>;
  diseaseArabic_contains?: Maybe<String>;
  diseaseArabic_not_contains?: Maybe<String>;
  diseaseArabic_starts_with?: Maybe<String>;
  diseaseArabic_not_starts_with?: Maybe<String>;
  diseaseArabic_ends_with?: Maybe<String>;
  diseaseArabic_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<DiseaseWhereInput[] | DiseaseWhereInput>;
  OR?: Maybe<DiseaseWhereInput[] | DiseaseWhereInput>;
  NOT?: Maybe<DiseaseWhereInput[] | DiseaseWhereInput>;
}

export interface DoctorSheduleTimeWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  drSheduleId?: Maybe<Int>;
  drSheduleId_not?: Maybe<Int>;
  drSheduleId_in?: Maybe<Int[] | Int>;
  drSheduleId_not_in?: Maybe<Int[] | Int>;
  drSheduleId_lt?: Maybe<Int>;
  drSheduleId_lte?: Maybe<Int>;
  drSheduleId_gt?: Maybe<Int>;
  drSheduleId_gte?: Maybe<Int>;
  scheduleTime?: Maybe<Int>;
  scheduleTime_not?: Maybe<Int>;
  scheduleTime_in?: Maybe<Int[] | Int>;
  scheduleTime_not_in?: Maybe<Int[] | Int>;
  scheduleTime_lt?: Maybe<Int>;
  scheduleTime_lte?: Maybe<Int>;
  scheduleTime_gt?: Maybe<Int>;
  scheduleTime_gte?: Maybe<Int>;
  status?: Maybe<Int>;
  status_not?: Maybe<Int>;
  status_in?: Maybe<Int[] | Int>;
  status_not_in?: Maybe<Int[] | Int>;
  status_lt?: Maybe<Int>;
  status_lte?: Maybe<Int>;
  status_gt?: Maybe<Int>;
  status_gte?: Maybe<Int>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<DoctorSheduleTimeWhereInput[] | DoctorSheduleTimeWhereInput>;
  OR?: Maybe<DoctorSheduleTimeWhereInput[] | DoctorSheduleTimeWhereInput>;
  NOT?: Maybe<DoctorSheduleTimeWhereInput[] | DoctorSheduleTimeWhereInput>;
}

export interface OptTimeWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  fifteenMins?: Maybe<String>;
  fifteenMins_not?: Maybe<String>;
  fifteenMins_in?: Maybe<String[] | String>;
  fifteenMins_not_in?: Maybe<String[] | String>;
  fifteenMins_lt?: Maybe<String>;
  fifteenMins_lte?: Maybe<String>;
  fifteenMins_gt?: Maybe<String>;
  fifteenMins_gte?: Maybe<String>;
  fifteenMins_contains?: Maybe<String>;
  fifteenMins_not_contains?: Maybe<String>;
  fifteenMins_starts_with?: Maybe<String>;
  fifteenMins_not_starts_with?: Maybe<String>;
  fifteenMins_ends_with?: Maybe<String>;
  fifteenMins_not_ends_with?: Maybe<String>;
  thirtyMins?: Maybe<String>;
  thirtyMins_not?: Maybe<String>;
  thirtyMins_in?: Maybe<String[] | String>;
  thirtyMins_not_in?: Maybe<String[] | String>;
  thirtyMins_lt?: Maybe<String>;
  thirtyMins_lte?: Maybe<String>;
  thirtyMins_gt?: Maybe<String>;
  thirtyMins_gte?: Maybe<String>;
  thirtyMins_contains?: Maybe<String>;
  thirtyMins_not_contains?: Maybe<String>;
  thirtyMins_starts_with?: Maybe<String>;
  thirtyMins_not_starts_with?: Maybe<String>;
  thirtyMins_ends_with?: Maybe<String>;
  thirtyMins_not_ends_with?: Maybe<String>;
  twentyMins?: Maybe<String>;
  twentyMins_not?: Maybe<String>;
  twentyMins_in?: Maybe<String[] | String>;
  twentyMins_not_in?: Maybe<String[] | String>;
  twentyMins_lt?: Maybe<String>;
  twentyMins_lte?: Maybe<String>;
  twentyMins_gt?: Maybe<String>;
  twentyMins_gte?: Maybe<String>;
  twentyMins_contains?: Maybe<String>;
  twentyMins_not_contains?: Maybe<String>;
  twentyMins_starts_with?: Maybe<String>;
  twentyMins_not_starts_with?: Maybe<String>;
  twentyMins_ends_with?: Maybe<String>;
  twentyMins_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<OptTimeWhereInput[] | OptTimeWhereInput>;
  OR?: Maybe<OptTimeWhereInput[] | OptTimeWhereInput>;
  NOT?: Maybe<OptTimeWhereInput[] | OptTimeWhereInput>;
}

export interface PatientWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  age?: Maybe<Int>;
  age_not?: Maybe<Int>;
  age_in?: Maybe<Int[] | Int>;
  age_not_in?: Maybe<Int[] | Int>;
  age_lt?: Maybe<Int>;
  age_lte?: Maybe<Int>;
  age_gt?: Maybe<Int>;
  age_gte?: Maybe<Int>;
  apiKey?: Maybe<String>;
  apiKey_not?: Maybe<String>;
  apiKey_in?: Maybe<String[] | String>;
  apiKey_not_in?: Maybe<String[] | String>;
  apiKey_lt?: Maybe<String>;
  apiKey_lte?: Maybe<String>;
  apiKey_gt?: Maybe<String>;
  apiKey_gte?: Maybe<String>;
  apiKey_contains?: Maybe<String>;
  apiKey_not_contains?: Maybe<String>;
  apiKey_starts_with?: Maybe<String>;
  apiKey_not_starts_with?: Maybe<String>;
  apiKey_ends_with?: Maybe<String>;
  apiKey_not_ends_with?: Maybe<String>;
  createdDate?: Maybe<DateTimeInput>;
  createdDate_not?: Maybe<DateTimeInput>;
  createdDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdDate_lt?: Maybe<DateTimeInput>;
  createdDate_lte?: Maybe<DateTimeInput>;
  createdDate_gt?: Maybe<DateTimeInput>;
  createdDate_gte?: Maybe<DateTimeInput>;
  dob?: Maybe<String>;
  dob_not?: Maybe<String>;
  dob_in?: Maybe<String[] | String>;
  dob_not_in?: Maybe<String[] | String>;
  dob_lt?: Maybe<String>;
  dob_lte?: Maybe<String>;
  dob_gt?: Maybe<String>;
  dob_gte?: Maybe<String>;
  dob_contains?: Maybe<String>;
  dob_not_contains?: Maybe<String>;
  dob_starts_with?: Maybe<String>;
  dob_not_starts_with?: Maybe<String>;
  dob_ends_with?: Maybe<String>;
  dob_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  gender?: Maybe<String>;
  gender_not?: Maybe<String>;
  gender_in?: Maybe<String[] | String>;
  gender_not_in?: Maybe<String[] | String>;
  gender_lt?: Maybe<String>;
  gender_lte?: Maybe<String>;
  gender_gt?: Maybe<String>;
  gender_gte?: Maybe<String>;
  gender_contains?: Maybe<String>;
  gender_not_contains?: Maybe<String>;
  gender_starts_with?: Maybe<String>;
  gender_not_starts_with?: Maybe<String>;
  gender_ends_with?: Maybe<String>;
  gender_not_ends_with?: Maybe<String>;
  lastAction?: Maybe<String>;
  lastAction_not?: Maybe<String>;
  lastAction_in?: Maybe<String[] | String>;
  lastAction_not_in?: Maybe<String[] | String>;
  lastAction_lt?: Maybe<String>;
  lastAction_lte?: Maybe<String>;
  lastAction_gt?: Maybe<String>;
  lastAction_gte?: Maybe<String>;
  lastAction_contains?: Maybe<String>;
  lastAction_not_contains?: Maybe<String>;
  lastAction_starts_with?: Maybe<String>;
  lastAction_not_starts_with?: Maybe<String>;
  lastAction_ends_with?: Maybe<String>;
  lastAction_not_ends_with?: Maybe<String>;
  lastSeen?: Maybe<DateTimeInput>;
  lastSeen_not?: Maybe<DateTimeInput>;
  lastSeen_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  lastSeen_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  lastSeen_lt?: Maybe<DateTimeInput>;
  lastSeen_lte?: Maybe<DateTimeInput>;
  lastSeen_gt?: Maybe<DateTimeInput>;
  lastSeen_gte?: Maybe<DateTimeInput>;
  mailSubs?: Maybe<Int>;
  mailSubs_not?: Maybe<Int>;
  mailSubs_in?: Maybe<Int[] | Int>;
  mailSubs_not_in?: Maybe<Int[] | Int>;
  mailSubs_lt?: Maybe<Int>;
  mailSubs_lte?: Maybe<Int>;
  mailSubs_gt?: Maybe<Int>;
  mailSubs_gte?: Maybe<Int>;
  mobile?: Maybe<String>;
  mobile_not?: Maybe<String>;
  mobile_in?: Maybe<String[] | String>;
  mobile_not_in?: Maybe<String[] | String>;
  mobile_lt?: Maybe<String>;
  mobile_lte?: Maybe<String>;
  mobile_gt?: Maybe<String>;
  mobile_gte?: Maybe<String>;
  mobile_contains?: Maybe<String>;
  mobile_not_contains?: Maybe<String>;
  mobile_starts_with?: Maybe<String>;
  mobile_not_starts_with?: Maybe<String>;
  mobile_ends_with?: Maybe<String>;
  mobile_not_ends_with?: Maybe<String>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  status?: Maybe<Int>;
  status_not?: Maybe<Int>;
  status_in?: Maybe<Int[] | Int>;
  status_not_in?: Maybe<Int[] | Int>;
  status_lt?: Maybe<Int>;
  status_lte?: Maybe<Int>;
  status_gt?: Maybe<Int>;
  status_gte?: Maybe<Int>;
  uniqeId?: Maybe<String>;
  uniqeId_not?: Maybe<String>;
  uniqeId_in?: Maybe<String[] | String>;
  uniqeId_not_in?: Maybe<String[] | String>;
  uniqeId_lt?: Maybe<String>;
  uniqeId_lte?: Maybe<String>;
  uniqeId_gt?: Maybe<String>;
  uniqeId_gte?: Maybe<String>;
  uniqeId_contains?: Maybe<String>;
  uniqeId_not_contains?: Maybe<String>;
  uniqeId_starts_with?: Maybe<String>;
  uniqeId_not_starts_with?: Maybe<String>;
  uniqeId_ends_with?: Maybe<String>;
  uniqeId_not_ends_with?: Maybe<String>;
  AND?: Maybe<PatientWhereInput[] | PatientWhereInput>;
  OR?: Maybe<PatientWhereInput[] | PatientWhereInput>;
  NOT?: Maybe<PatientWhereInput[] | PatientWhereInput>;
}

export interface SheduleTimeWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  drSheduleId?: Maybe<Int>;
  drSheduleId_not?: Maybe<Int>;
  drSheduleId_in?: Maybe<Int[] | Int>;
  drSheduleId_not_in?: Maybe<Int[] | Int>;
  drSheduleId_lt?: Maybe<Int>;
  drSheduleId_lte?: Maybe<Int>;
  drSheduleId_gt?: Maybe<Int>;
  drSheduleId_gte?: Maybe<Int>;
  scheduleFullDate?: Maybe<Int>;
  scheduleFullDate_not?: Maybe<Int>;
  scheduleFullDate_in?: Maybe<Int[] | Int>;
  scheduleFullDate_not_in?: Maybe<Int[] | Int>;
  scheduleFullDate_lt?: Maybe<Int>;
  scheduleFullDate_lte?: Maybe<Int>;
  scheduleFullDate_gt?: Maybe<Int>;
  scheduleFullDate_gte?: Maybe<Int>;
  sheduleTime?: Maybe<String>;
  sheduleTime_not?: Maybe<String>;
  sheduleTime_in?: Maybe<String[] | String>;
  sheduleTime_not_in?: Maybe<String[] | String>;
  sheduleTime_lt?: Maybe<String>;
  sheduleTime_lte?: Maybe<String>;
  sheduleTime_gt?: Maybe<String>;
  sheduleTime_gte?: Maybe<String>;
  sheduleTime_contains?: Maybe<String>;
  sheduleTime_not_contains?: Maybe<String>;
  sheduleTime_starts_with?: Maybe<String>;
  sheduleTime_not_starts_with?: Maybe<String>;
  sheduleTime_ends_with?: Maybe<String>;
  sheduleTime_not_ends_with?: Maybe<String>;
  status?: Maybe<Int>;
  status_not?: Maybe<Int>;
  status_in?: Maybe<Int[] | Int>;
  status_not_in?: Maybe<Int[] | Int>;
  status_lt?: Maybe<Int>;
  status_lte?: Maybe<Int>;
  status_gt?: Maybe<Int>;
  status_gte?: Maybe<Int>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<SheduleTimeWhereInput[] | SheduleTimeWhereInput>;
  OR?: Maybe<SheduleTimeWhereInput[] | SheduleTimeWhereInput>;
  NOT?: Maybe<SheduleTimeWhereInput[] | SheduleTimeWhereInput>;
}

export type BlogWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export interface BlogWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  bannerImage?: Maybe<String>;
  bannerImage_not?: Maybe<String>;
  bannerImage_in?: Maybe<String[] | String>;
  bannerImage_not_in?: Maybe<String[] | String>;
  bannerImage_lt?: Maybe<String>;
  bannerImage_lte?: Maybe<String>;
  bannerImage_gt?: Maybe<String>;
  bannerImage_gte?: Maybe<String>;
  bannerImage_contains?: Maybe<String>;
  bannerImage_not_contains?: Maybe<String>;
  bannerImage_starts_with?: Maybe<String>;
  bannerImage_not_starts_with?: Maybe<String>;
  bannerImage_ends_with?: Maybe<String>;
  bannerImage_not_ends_with?: Maybe<String>;
  createdDate?: Maybe<DateTimeInput>;
  createdDate_not?: Maybe<DateTimeInput>;
  createdDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdDate_lt?: Maybe<DateTimeInput>;
  createdDate_lte?: Maybe<DateTimeInput>;
  createdDate_gt?: Maybe<DateTimeInput>;
  createdDate_gte?: Maybe<DateTimeInput>;
  hospitalId?: Maybe<HospitalWhereInput>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  status?: Maybe<Int>;
  status_not?: Maybe<Int>;
  status_in?: Maybe<Int[] | Int>;
  status_not_in?: Maybe<Int[] | Int>;
  status_lt?: Maybe<Int>;
  status_lte?: Maybe<Int>;
  status_gt?: Maybe<Int>;
  status_gte?: Maybe<Int>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<BlogWhereInput[] | BlogWhereInput>;
  OR?: Maybe<BlogWhereInput[] | BlogWhereInput>;
  NOT?: Maybe<BlogWhereInput[] | BlogWhereInput>;
}

export type BlogCommentWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export interface PostImageWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  isDefault?: Maybe<Int>;
  isDefault_not?: Maybe<Int>;
  isDefault_in?: Maybe<Int[] | Int>;
  isDefault_not_in?: Maybe<Int[] | Int>;
  isDefault_lt?: Maybe<Int>;
  isDefault_lte?: Maybe<Int>;
  isDefault_gt?: Maybe<Int>;
  isDefault_gte?: Maybe<Int>;
  pic?: Maybe<String>;
  pic_not?: Maybe<String>;
  pic_in?: Maybe<String[] | String>;
  pic_not_in?: Maybe<String[] | String>;
  pic_lt?: Maybe<String>;
  pic_lte?: Maybe<String>;
  pic_gt?: Maybe<String>;
  pic_gte?: Maybe<String>;
  pic_contains?: Maybe<String>;
  pic_not_contains?: Maybe<String>;
  pic_starts_with?: Maybe<String>;
  pic_not_starts_with?: Maybe<String>;
  pic_ends_with?: Maybe<String>;
  pic_not_ends_with?: Maybe<String>;
  postId?: Maybe<BlogPostWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<PostImageWhereInput[] | PostImageWhereInput>;
  OR?: Maybe<PostImageWhereInput[] | PostImageWhereInput>;
  NOT?: Maybe<PostImageWhereInput[] | PostImageWhereInput>;
}

export interface BlogPostWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  blogId?: Maybe<BlogWhereInput>;
  hospitalId?: Maybe<HospitalWhereInput>;
  logCreated?: Maybe<DateTimeInput>;
  logCreated_not?: Maybe<DateTimeInput>;
  logCreated_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  logCreated_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  logCreated_lt?: Maybe<DateTimeInput>;
  logCreated_lte?: Maybe<DateTimeInput>;
  logCreated_gt?: Maybe<DateTimeInput>;
  logCreated_gte?: Maybe<DateTimeInput>;
  postContent?: Maybe<String>;
  postContent_not?: Maybe<String>;
  postContent_in?: Maybe<String[] | String>;
  postContent_not_in?: Maybe<String[] | String>;
  postContent_lt?: Maybe<String>;
  postContent_lte?: Maybe<String>;
  postContent_gt?: Maybe<String>;
  postContent_gte?: Maybe<String>;
  postContent_contains?: Maybe<String>;
  postContent_not_contains?: Maybe<String>;
  postContent_starts_with?: Maybe<String>;
  postContent_not_starts_with?: Maybe<String>;
  postContent_ends_with?: Maybe<String>;
  postContent_not_ends_with?: Maybe<String>;
  postTitle?: Maybe<String>;
  postTitle_not?: Maybe<String>;
  postTitle_in?: Maybe<String[] | String>;
  postTitle_not_in?: Maybe<String[] | String>;
  postTitle_lt?: Maybe<String>;
  postTitle_lte?: Maybe<String>;
  postTitle_gt?: Maybe<String>;
  postTitle_gte?: Maybe<String>;
  postTitle_contains?: Maybe<String>;
  postTitle_not_contains?: Maybe<String>;
  postTitle_starts_with?: Maybe<String>;
  postTitle_not_starts_with?: Maybe<String>;
  postTitle_ends_with?: Maybe<String>;
  postTitle_not_ends_with?: Maybe<String>;
  status?: Maybe<Int>;
  status_not?: Maybe<Int>;
  status_in?: Maybe<Int[] | Int>;
  status_not_in?: Maybe<Int[] | Int>;
  status_lt?: Maybe<Int>;
  status_lte?: Maybe<Int>;
  status_gt?: Maybe<Int>;
  status_gte?: Maybe<Int>;
  totalViewers?: Maybe<Int>;
  totalViewers_not?: Maybe<Int>;
  totalViewers_in?: Maybe<Int[] | Int>;
  totalViewers_not_in?: Maybe<Int[] | Int>;
  totalViewers_lt?: Maybe<Int>;
  totalViewers_lte?: Maybe<Int>;
  totalViewers_gt?: Maybe<Int>;
  totalViewers_gte?: Maybe<Int>;
  images_every?: Maybe<PostImageWhereInput>;
  images_some?: Maybe<PostImageWhereInput>;
  images_none?: Maybe<PostImageWhereInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<BlogPostWhereInput[] | BlogPostWhereInput>;
  OR?: Maybe<BlogPostWhereInput[] | BlogPostWhereInput>;
  NOT?: Maybe<BlogPostWhereInput[] | BlogPostWhereInput>;
}

export interface BlogCommentWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  commentator?: Maybe<Int>;
  commentator_not?: Maybe<Int>;
  commentator_in?: Maybe<Int[] | Int>;
  commentator_not_in?: Maybe<Int[] | Int>;
  commentator_lt?: Maybe<Int>;
  commentator_lte?: Maybe<Int>;
  commentator_gt?: Maybe<Int>;
  commentator_gte?: Maybe<Int>;
  commentatorName?: Maybe<String>;
  commentatorName_not?: Maybe<String>;
  commentatorName_in?: Maybe<String[] | String>;
  commentatorName_not_in?: Maybe<String[] | String>;
  commentatorName_lt?: Maybe<String>;
  commentatorName_lte?: Maybe<String>;
  commentatorName_gt?: Maybe<String>;
  commentatorName_gte?: Maybe<String>;
  commentatorName_contains?: Maybe<String>;
  commentatorName_not_contains?: Maybe<String>;
  commentatorName_starts_with?: Maybe<String>;
  commentatorName_not_starts_with?: Maybe<String>;
  commentatorName_ends_with?: Maybe<String>;
  commentatorName_not_ends_with?: Maybe<String>;
  comments?: Maybe<String>;
  comments_not?: Maybe<String>;
  comments_in?: Maybe<String[] | String>;
  comments_not_in?: Maybe<String[] | String>;
  comments_lt?: Maybe<String>;
  comments_lte?: Maybe<String>;
  comments_gt?: Maybe<String>;
  comments_gte?: Maybe<String>;
  comments_contains?: Maybe<String>;
  comments_not_contains?: Maybe<String>;
  comments_starts_with?: Maybe<String>;
  comments_not_starts_with?: Maybe<String>;
  comments_ends_with?: Maybe<String>;
  comments_not_ends_with?: Maybe<String>;
  logCreated?: Maybe<DateTimeInput>;
  logCreated_not?: Maybe<DateTimeInput>;
  logCreated_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  logCreated_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  logCreated_lt?: Maybe<DateTimeInput>;
  logCreated_lte?: Maybe<DateTimeInput>;
  logCreated_gt?: Maybe<DateTimeInput>;
  logCreated_gte?: Maybe<DateTimeInput>;
  postId?: Maybe<BlogPostWhereInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<BlogCommentWhereInput[] | BlogCommentWhereInput>;
  OR?: Maybe<BlogCommentWhereInput[] | BlogCommentWhereInput>;
  NOT?: Maybe<BlogCommentWhereInput[] | BlogCommentWhereInput>;
}

export type BlogPostWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export type CityWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export type ContactUsWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export interface ContactUsWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  address?: Maybe<String>;
  address_not?: Maybe<String>;
  address_in?: Maybe<String[] | String>;
  address_not_in?: Maybe<String[] | String>;
  address_lt?: Maybe<String>;
  address_lte?: Maybe<String>;
  address_gt?: Maybe<String>;
  address_gte?: Maybe<String>;
  address_contains?: Maybe<String>;
  address_not_contains?: Maybe<String>;
  address_starts_with?: Maybe<String>;
  address_not_starts_with?: Maybe<String>;
  address_ends_with?: Maybe<String>;
  address_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  lat?: Maybe<String>;
  lat_not?: Maybe<String>;
  lat_in?: Maybe<String[] | String>;
  lat_not_in?: Maybe<String[] | String>;
  lat_lt?: Maybe<String>;
  lat_lte?: Maybe<String>;
  lat_gt?: Maybe<String>;
  lat_gte?: Maybe<String>;
  lat_contains?: Maybe<String>;
  lat_not_contains?: Maybe<String>;
  lat_starts_with?: Maybe<String>;
  lat_not_starts_with?: Maybe<String>;
  lat_ends_with?: Maybe<String>;
  lat_not_ends_with?: Maybe<String>;
  lon?: Maybe<String>;
  lon_not?: Maybe<String>;
  lon_in?: Maybe<String[] | String>;
  lon_not_in?: Maybe<String[] | String>;
  lon_lt?: Maybe<String>;
  lon_lte?: Maybe<String>;
  lon_gt?: Maybe<String>;
  lon_gte?: Maybe<String>;
  lon_contains?: Maybe<String>;
  lon_not_contains?: Maybe<String>;
  lon_starts_with?: Maybe<String>;
  lon_not_starts_with?: Maybe<String>;
  lon_ends_with?: Maybe<String>;
  lon_not_ends_with?: Maybe<String>;
  phone?: Maybe<String>;
  phone_not?: Maybe<String>;
  phone_in?: Maybe<String[] | String>;
  phone_not_in?: Maybe<String[] | String>;
  phone_lt?: Maybe<String>;
  phone_lte?: Maybe<String>;
  phone_gt?: Maybe<String>;
  phone_gte?: Maybe<String>;
  phone_contains?: Maybe<String>;
  phone_not_contains?: Maybe<String>;
  phone_starts_with?: Maybe<String>;
  phone_not_starts_with?: Maybe<String>;
  phone_ends_with?: Maybe<String>;
  phone_not_ends_with?: Maybe<String>;
  pobox?: Maybe<String>;
  pobox_not?: Maybe<String>;
  pobox_in?: Maybe<String[] | String>;
  pobox_not_in?: Maybe<String[] | String>;
  pobox_lt?: Maybe<String>;
  pobox_lte?: Maybe<String>;
  pobox_gt?: Maybe<String>;
  pobox_gte?: Maybe<String>;
  pobox_contains?: Maybe<String>;
  pobox_not_contains?: Maybe<String>;
  pobox_starts_with?: Maybe<String>;
  pobox_not_starts_with?: Maybe<String>;
  pobox_ends_with?: Maybe<String>;
  pobox_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ContactUsWhereInput[] | ContactUsWhereInput>;
  OR?: Maybe<ContactUsWhereInput[] | ContactUsWhereInput>;
  NOT?: Maybe<ContactUsWhereInput[] | ContactUsWhereInput>;
}

export type CountryWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export type DiseaseWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export type DiseaseCoveredWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export interface DiseaseCoveredWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  diseaseId?: Maybe<Int>;
  diseaseId_not?: Maybe<Int>;
  diseaseId_in?: Maybe<Int[] | Int>;
  diseaseId_not_in?: Maybe<Int[] | Int>;
  diseaseId_lt?: Maybe<Int>;
  diseaseId_lte?: Maybe<Int>;
  diseaseId_gt?: Maybe<Int>;
  diseaseId_gte?: Maybe<Int>;
  insuranceCatId?: Maybe<Int>;
  insuranceCatId_not?: Maybe<Int>;
  insuranceCatId_in?: Maybe<Int[] | Int>;
  insuranceCatId_not_in?: Maybe<Int[] | Int>;
  insuranceCatId_lt?: Maybe<Int>;
  insuranceCatId_lte?: Maybe<Int>;
  insuranceCatId_gt?: Maybe<Int>;
  insuranceCatId_gte?: Maybe<Int>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<DiseaseCoveredWhereInput[] | DiseaseCoveredWhereInput>;
  OR?: Maybe<DiseaseCoveredWhereInput[] | DiseaseCoveredWhereInput>;
  NOT?: Maybe<DiseaseCoveredWhereInput[] | DiseaseCoveredWhereInput>;
}

export type DoctorWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export type DoctorOldWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export interface DoctorsRatingWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  doctors?: Maybe<DoctorOldWhereInput>;
  rating?: Maybe<String>;
  rating_not?: Maybe<String>;
  rating_in?: Maybe<String[] | String>;
  rating_not_in?: Maybe<String[] | String>;
  rating_lt?: Maybe<String>;
  rating_lte?: Maybe<String>;
  rating_gt?: Maybe<String>;
  rating_gte?: Maybe<String>;
  rating_contains?: Maybe<String>;
  rating_not_contains?: Maybe<String>;
  rating_starts_with?: Maybe<String>;
  rating_not_starts_with?: Maybe<String>;
  rating_ends_with?: Maybe<String>;
  rating_not_ends_with?: Maybe<String>;
  systemIp?: Maybe<String>;
  systemIp_not?: Maybe<String>;
  systemIp_in?: Maybe<String[] | String>;
  systemIp_not_in?: Maybe<String[] | String>;
  systemIp_lt?: Maybe<String>;
  systemIp_lte?: Maybe<String>;
  systemIp_gt?: Maybe<String>;
  systemIp_gte?: Maybe<String>;
  systemIp_contains?: Maybe<String>;
  systemIp_not_contains?: Maybe<String>;
  systemIp_starts_with?: Maybe<String>;
  systemIp_not_starts_with?: Maybe<String>;
  systemIp_ends_with?: Maybe<String>;
  systemIp_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<DoctorsRatingWhereInput[] | DoctorsRatingWhereInput>;
  OR?: Maybe<DoctorsRatingWhereInput[] | DoctorsRatingWhereInput>;
  NOT?: Maybe<DoctorsRatingWhereInput[] | DoctorsRatingWhereInput>;
}

export interface DoctorOldWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  apiKey?: Maybe<String>;
  apiKey_not?: Maybe<String>;
  apiKey_in?: Maybe<String[] | String>;
  apiKey_not_in?: Maybe<String[] | String>;
  apiKey_lt?: Maybe<String>;
  apiKey_lte?: Maybe<String>;
  apiKey_gt?: Maybe<String>;
  apiKey_gte?: Maybe<String>;
  apiKey_contains?: Maybe<String>;
  apiKey_not_contains?: Maybe<String>;
  apiKey_starts_with?: Maybe<String>;
  apiKey_not_starts_with?: Maybe<String>;
  apiKey_ends_with?: Maybe<String>;
  apiKey_not_ends_with?: Maybe<String>;
  createdDate?: Maybe<DateTimeInput>;
  createdDate_not?: Maybe<DateTimeInput>;
  createdDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdDate_lt?: Maybe<DateTimeInput>;
  createdDate_lte?: Maybe<DateTimeInput>;
  createdDate_gt?: Maybe<DateTimeInput>;
  createdDate_gte?: Maybe<DateTimeInput>;
  designation?: Maybe<String>;
  designation_not?: Maybe<String>;
  designation_in?: Maybe<String[] | String>;
  designation_not_in?: Maybe<String[] | String>;
  designation_lt?: Maybe<String>;
  designation_lte?: Maybe<String>;
  designation_gt?: Maybe<String>;
  designation_gte?: Maybe<String>;
  designation_contains?: Maybe<String>;
  designation_not_contains?: Maybe<String>;
  designation_starts_with?: Maybe<String>;
  designation_not_starts_with?: Maybe<String>;
  designation_ends_with?: Maybe<String>;
  designation_not_ends_with?: Maybe<String>;
  doctorCv?: Maybe<String>;
  doctorCv_not?: Maybe<String>;
  doctorCv_in?: Maybe<String[] | String>;
  doctorCv_not_in?: Maybe<String[] | String>;
  doctorCv_lt?: Maybe<String>;
  doctorCv_lte?: Maybe<String>;
  doctorCv_gt?: Maybe<String>;
  doctorCv_gte?: Maybe<String>;
  doctorCv_contains?: Maybe<String>;
  doctorCv_not_contains?: Maybe<String>;
  doctorCv_starts_with?: Maybe<String>;
  doctorCv_not_starts_with?: Maybe<String>;
  doctorCv_ends_with?: Maybe<String>;
  doctorCv_not_ends_with?: Maybe<String>;
  doctorsRating_every?: Maybe<DoctorsRatingWhereInput>;
  doctorsRating_some?: Maybe<DoctorsRatingWhereInput>;
  doctorsRating_none?: Maybe<DoctorsRatingWhereInput>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  gender?: Maybe<String>;
  gender_not?: Maybe<String>;
  gender_in?: Maybe<String[] | String>;
  gender_not_in?: Maybe<String[] | String>;
  gender_lt?: Maybe<String>;
  gender_lte?: Maybe<String>;
  gender_gt?: Maybe<String>;
  gender_gte?: Maybe<String>;
  gender_contains?: Maybe<String>;
  gender_not_contains?: Maybe<String>;
  gender_starts_with?: Maybe<String>;
  gender_not_starts_with?: Maybe<String>;
  gender_ends_with?: Maybe<String>;
  gender_not_ends_with?: Maybe<String>;
  mohcard?: Maybe<String>;
  mohcard_not?: Maybe<String>;
  mohcard_in?: Maybe<String[] | String>;
  mohcard_not_in?: Maybe<String[] | String>;
  mohcard_lt?: Maybe<String>;
  mohcard_lte?: Maybe<String>;
  mohcard_gt?: Maybe<String>;
  mohcard_gte?: Maybe<String>;
  mohcard_contains?: Maybe<String>;
  mohcard_not_contains?: Maybe<String>;
  mohcard_starts_with?: Maybe<String>;
  mohcard_not_starts_with?: Maybe<String>;
  mohcard_ends_with?: Maybe<String>;
  mohcard_not_ends_with?: Maybe<String>;
  mohId?: Maybe<String>;
  mohId_not?: Maybe<String>;
  mohId_in?: Maybe<String[] | String>;
  mohId_not_in?: Maybe<String[] | String>;
  mohId_lt?: Maybe<String>;
  mohId_lte?: Maybe<String>;
  mohId_gt?: Maybe<String>;
  mohId_gte?: Maybe<String>;
  mohId_contains?: Maybe<String>;
  mohId_not_contains?: Maybe<String>;
  mohId_starts_with?: Maybe<String>;
  mohId_not_starts_with?: Maybe<String>;
  mohId_ends_with?: Maybe<String>;
  mohId_not_ends_with?: Maybe<String>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  nameArabic?: Maybe<String>;
  nameArabic_not?: Maybe<String>;
  nameArabic_in?: Maybe<String[] | String>;
  nameArabic_not_in?: Maybe<String[] | String>;
  nameArabic_lt?: Maybe<String>;
  nameArabic_lte?: Maybe<String>;
  nameArabic_gt?: Maybe<String>;
  nameArabic_gte?: Maybe<String>;
  nameArabic_contains?: Maybe<String>;
  nameArabic_not_contains?: Maybe<String>;
  nameArabic_starts_with?: Maybe<String>;
  nameArabic_not_starts_with?: Maybe<String>;
  nameArabic_ends_with?: Maybe<String>;
  nameArabic_not_ends_with?: Maybe<String>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  phone?: Maybe<String>;
  phone_not?: Maybe<String>;
  phone_in?: Maybe<String[] | String>;
  phone_not_in?: Maybe<String[] | String>;
  phone_lt?: Maybe<String>;
  phone_lte?: Maybe<String>;
  phone_gt?: Maybe<String>;
  phone_gte?: Maybe<String>;
  phone_contains?: Maybe<String>;
  phone_not_contains?: Maybe<String>;
  phone_starts_with?: Maybe<String>;
  phone_not_starts_with?: Maybe<String>;
  phone_ends_with?: Maybe<String>;
  phone_not_ends_with?: Maybe<String>;
  fees?: Maybe<String>;
  fees_not?: Maybe<String>;
  fees_in?: Maybe<String[] | String>;
  fees_not_in?: Maybe<String[] | String>;
  fees_lt?: Maybe<String>;
  fees_lte?: Maybe<String>;
  fees_gt?: Maybe<String>;
  fees_gte?: Maybe<String>;
  fees_contains?: Maybe<String>;
  fees_not_contains?: Maybe<String>;
  fees_starts_with?: Maybe<String>;
  fees_not_starts_with?: Maybe<String>;
  fees_ends_with?: Maybe<String>;
  fees_not_ends_with?: Maybe<String>;
  picture?: Maybe<String>;
  picture_not?: Maybe<String>;
  picture_in?: Maybe<String[] | String>;
  picture_not_in?: Maybe<String[] | String>;
  picture_lt?: Maybe<String>;
  picture_lte?: Maybe<String>;
  picture_gt?: Maybe<String>;
  picture_gte?: Maybe<String>;
  picture_contains?: Maybe<String>;
  picture_not_contains?: Maybe<String>;
  picture_starts_with?: Maybe<String>;
  picture_not_starts_with?: Maybe<String>;
  picture_ends_with?: Maybe<String>;
  picture_not_ends_with?: Maybe<String>;
  speciality?: Maybe<SpecialityWhereInput>;
  status?: Maybe<Int>;
  status_not?: Maybe<Int>;
  status_in?: Maybe<Int[] | Int>;
  status_not_in?: Maybe<Int[] | Int>;
  status_lt?: Maybe<Int>;
  status_lte?: Maybe<Int>;
  status_gt?: Maybe<Int>;
  status_gte?: Maybe<Int>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<DoctorOldWhereInput[] | DoctorOldWhereInput>;
  OR?: Maybe<DoctorOldWhereInput[] | DoctorOldWhereInput>;
  NOT?: Maybe<DoctorOldWhereInput[] | DoctorOldWhereInput>;
}

export type DoctorSheduleWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export interface DoctorSheduleWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  date?: Maybe<Int>;
  date_not?: Maybe<Int>;
  date_in?: Maybe<Int[] | Int>;
  date_not_in?: Maybe<Int[] | Int>;
  date_lt?: Maybe<Int>;
  date_lte?: Maybe<Int>;
  date_gt?: Maybe<Int>;
  date_gte?: Maybe<Int>;
  doctorId?: Maybe<Int>;
  doctorId_not?: Maybe<Int>;
  doctorId_in?: Maybe<Int[] | Int>;
  doctorId_not_in?: Maybe<Int[] | Int>;
  doctorId_lt?: Maybe<Int>;
  doctorId_lte?: Maybe<Int>;
  doctorId_gt?: Maybe<Int>;
  doctorId_gte?: Maybe<Int>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<DoctorSheduleWhereInput[] | DoctorSheduleWhereInput>;
  OR?: Maybe<DoctorSheduleWhereInput[] | DoctorSheduleWhereInput>;
  NOT?: Maybe<DoctorSheduleWhereInput[] | DoctorSheduleWhereInput>;
}

export type DoctorSheduleTimeWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export type DoctorsRatingWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export type DrSheduleWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export interface DrSheduleWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  date?: Maybe<DateTimeInput>;
  date_not?: Maybe<DateTimeInput>;
  date_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_lt?: Maybe<DateTimeInput>;
  date_lte?: Maybe<DateTimeInput>;
  date_gt?: Maybe<DateTimeInput>;
  date_gte?: Maybe<DateTimeInput>;
  doctorId?: Maybe<Int>;
  doctorId_not?: Maybe<Int>;
  doctorId_in?: Maybe<Int[] | Int>;
  doctorId_not_in?: Maybe<Int[] | Int>;
  doctorId_lt?: Maybe<Int>;
  doctorId_lte?: Maybe<Int>;
  doctorId_gt?: Maybe<Int>;
  doctorId_gte?: Maybe<Int>;
  hospitalId?: Maybe<Int>;
  hospitalId_not?: Maybe<Int>;
  hospitalId_in?: Maybe<Int[] | Int>;
  hospitalId_not_in?: Maybe<Int[] | Int>;
  hospitalId_lt?: Maybe<Int>;
  hospitalId_lte?: Maybe<Int>;
  hospitalId_gt?: Maybe<Int>;
  hospitalId_gte?: Maybe<Int>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<DrSheduleWhereInput[] | DrSheduleWhereInput>;
  OR?: Maybe<DrSheduleWhereInput[] | DrSheduleWhereInput>;
  NOT?: Maybe<DrSheduleWhereInput[] | DrSheduleWhereInput>;
}

export type EmailSubscriptionWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export interface EmailSubscriptionWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<EmailSubscriptionWhereInput[] | EmailSubscriptionWhereInput>;
  OR?: Maybe<EmailSubscriptionWhereInput[] | EmailSubscriptionWhereInput>;
  NOT?: Maybe<EmailSubscriptionWhereInput[] | EmailSubscriptionWhereInput>;
}

export type FacilityWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export interface FacilityWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  facility?: Maybe<String>;
  facility_not?: Maybe<String>;
  facility_in?: Maybe<String[] | String>;
  facility_not_in?: Maybe<String[] | String>;
  facility_lt?: Maybe<String>;
  facility_lte?: Maybe<String>;
  facility_gt?: Maybe<String>;
  facility_gte?: Maybe<String>;
  facility_contains?: Maybe<String>;
  facility_not_contains?: Maybe<String>;
  facility_starts_with?: Maybe<String>;
  facility_not_starts_with?: Maybe<String>;
  facility_ends_with?: Maybe<String>;
  facility_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<FacilityWhereInput[] | FacilityWhereInput>;
  OR?: Maybe<FacilityWhereInput[] | FacilityWhereInput>;
  NOT?: Maybe<FacilityWhereInput[] | FacilityWhereInput>;
}

export type HospitalWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export type HospitalFacilityWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export interface HospitalFacilityWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  facilityId?: Maybe<Int>;
  facilityId_not?: Maybe<Int>;
  facilityId_in?: Maybe<Int[] | Int>;
  facilityId_not_in?: Maybe<Int[] | Int>;
  facilityId_lt?: Maybe<Int>;
  facilityId_lte?: Maybe<Int>;
  facilityId_gt?: Maybe<Int>;
  facilityId_gte?: Maybe<Int>;
  hospitalId?: Maybe<Int>;
  hospitalId_not?: Maybe<Int>;
  hospitalId_in?: Maybe<Int[] | Int>;
  hospitalId_not_in?: Maybe<Int[] | Int>;
  hospitalId_lt?: Maybe<Int>;
  hospitalId_lte?: Maybe<Int>;
  hospitalId_gt?: Maybe<Int>;
  hospitalId_gte?: Maybe<Int>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<HospitalFacilityWhereInput[] | HospitalFacilityWhereInput>;
  OR?: Maybe<HospitalFacilityWhereInput[] | HospitalFacilityWhereInput>;
  NOT?: Maybe<HospitalFacilityWhereInput[] | HospitalFacilityWhereInput>;
}

export type HospitalRatingWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export interface HospitalRatingWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  hospitalId?: Maybe<Int>;
  hospitalId_not?: Maybe<Int>;
  hospitalId_in?: Maybe<Int[] | Int>;
  hospitalId_not_in?: Maybe<Int[] | Int>;
  hospitalId_lt?: Maybe<Int>;
  hospitalId_lte?: Maybe<Int>;
  hospitalId_gt?: Maybe<Int>;
  hospitalId_gte?: Maybe<Int>;
  rating?: Maybe<String>;
  rating_not?: Maybe<String>;
  rating_in?: Maybe<String[] | String>;
  rating_not_in?: Maybe<String[] | String>;
  rating_lt?: Maybe<String>;
  rating_lte?: Maybe<String>;
  rating_gt?: Maybe<String>;
  rating_gte?: Maybe<String>;
  rating_contains?: Maybe<String>;
  rating_not_contains?: Maybe<String>;
  rating_starts_with?: Maybe<String>;
  rating_not_starts_with?: Maybe<String>;
  rating_ends_with?: Maybe<String>;
  rating_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<HospitalRatingWhereInput[] | HospitalRatingWhereInput>;
  OR?: Maybe<HospitalRatingWhereInput[] | HospitalRatingWhereInput>;
  NOT?: Maybe<HospitalRatingWhereInput[] | HospitalRatingWhereInput>;
}

export type IllnessWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export interface IllnessWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  illness?: Maybe<String>;
  illness_not?: Maybe<String>;
  illness_in?: Maybe<String[] | String>;
  illness_not_in?: Maybe<String[] | String>;
  illness_lt?: Maybe<String>;
  illness_lte?: Maybe<String>;
  illness_gt?: Maybe<String>;
  illness_gte?: Maybe<String>;
  illness_contains?: Maybe<String>;
  illness_not_contains?: Maybe<String>;
  illness_starts_with?: Maybe<String>;
  illness_not_starts_with?: Maybe<String>;
  illness_ends_with?: Maybe<String>;
  illness_not_ends_with?: Maybe<String>;
  illnessArabic?: Maybe<String>;
  illnessArabic_not?: Maybe<String>;
  illnessArabic_in?: Maybe<String[] | String>;
  illnessArabic_not_in?: Maybe<String[] | String>;
  illnessArabic_lt?: Maybe<String>;
  illnessArabic_lte?: Maybe<String>;
  illnessArabic_gt?: Maybe<String>;
  illnessArabic_gte?: Maybe<String>;
  illnessArabic_contains?: Maybe<String>;
  illnessArabic_not_contains?: Maybe<String>;
  illnessArabic_starts_with?: Maybe<String>;
  illnessArabic_not_starts_with?: Maybe<String>;
  illnessArabic_ends_with?: Maybe<String>;
  illnessArabic_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<IllnessWhereInput[] | IllnessWhereInput>;
  OR?: Maybe<IllnessWhereInput[] | IllnessWhereInput>;
  NOT?: Maybe<IllnessWhereInput[] | IllnessWhereInput>;
}

export type InsuranceWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export type InsuranceCategoryWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export interface InsuranceCategoryWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  category?: Maybe<String>;
  category_not?: Maybe<String>;
  category_in?: Maybe<String[] | String>;
  category_not_in?: Maybe<String[] | String>;
  category_lt?: Maybe<String>;
  category_lte?: Maybe<String>;
  category_gt?: Maybe<String>;
  category_gte?: Maybe<String>;
  category_contains?: Maybe<String>;
  category_not_contains?: Maybe<String>;
  category_starts_with?: Maybe<String>;
  category_not_starts_with?: Maybe<String>;
  category_ends_with?: Maybe<String>;
  category_not_ends_with?: Maybe<String>;
  insuranceId?: Maybe<Int>;
  insuranceId_not?: Maybe<Int>;
  insuranceId_in?: Maybe<Int[] | Int>;
  insuranceId_not_in?: Maybe<Int[] | Int>;
  insuranceId_lt?: Maybe<Int>;
  insuranceId_lte?: Maybe<Int>;
  insuranceId_gt?: Maybe<Int>;
  insuranceId_gte?: Maybe<Int>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<InsuranceCategoryWhereInput[] | InsuranceCategoryWhereInput>;
  OR?: Maybe<InsuranceCategoryWhereInput[] | InsuranceCategoryWhereInput>;
  NOT?: Maybe<InsuranceCategoryWhereInput[] | InsuranceCategoryWhereInput>;
}

export type JobWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export interface JobWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  position?: Maybe<String>;
  position_not?: Maybe<String>;
  position_in?: Maybe<String[] | String>;
  position_not_in?: Maybe<String[] | String>;
  position_lt?: Maybe<String>;
  position_lte?: Maybe<String>;
  position_gt?: Maybe<String>;
  position_gte?: Maybe<String>;
  position_contains?: Maybe<String>;
  position_not_contains?: Maybe<String>;
  position_starts_with?: Maybe<String>;
  position_not_starts_with?: Maybe<String>;
  position_ends_with?: Maybe<String>;
  position_not_ends_with?: Maybe<String>;
  positionArabic?: Maybe<String>;
  positionArabic_not?: Maybe<String>;
  positionArabic_in?: Maybe<String[] | String>;
  positionArabic_not_in?: Maybe<String[] | String>;
  positionArabic_lt?: Maybe<String>;
  positionArabic_lte?: Maybe<String>;
  positionArabic_gt?: Maybe<String>;
  positionArabic_gte?: Maybe<String>;
  positionArabic_contains?: Maybe<String>;
  positionArabic_not_contains?: Maybe<String>;
  positionArabic_starts_with?: Maybe<String>;
  positionArabic_not_starts_with?: Maybe<String>;
  positionArabic_ends_with?: Maybe<String>;
  positionArabic_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<JobWhereInput[] | JobWhereInput>;
  OR?: Maybe<JobWhereInput[] | JobWhereInput>;
  NOT?: Maybe<JobWhereInput[] | JobWhereInput>;
}

export type LanguageWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export interface LanguageWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  language?: Maybe<String>;
  language_not?: Maybe<String>;
  language_in?: Maybe<String[] | String>;
  language_not_in?: Maybe<String[] | String>;
  language_lt?: Maybe<String>;
  language_lte?: Maybe<String>;
  language_gt?: Maybe<String>;
  language_gte?: Maybe<String>;
  language_contains?: Maybe<String>;
  language_not_contains?: Maybe<String>;
  language_starts_with?: Maybe<String>;
  language_not_starts_with?: Maybe<String>;
  language_ends_with?: Maybe<String>;
  language_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<LanguageWhereInput[] | LanguageWhereInput>;
  OR?: Maybe<LanguageWhereInput[] | LanguageWhereInput>;
  NOT?: Maybe<LanguageWhereInput[] | LanguageWhereInput>;
}

export type MessageWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export interface MessageWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  fromUser?: Maybe<Int>;
  fromUser_not?: Maybe<Int>;
  fromUser_in?: Maybe<Int[] | Int>;
  fromUser_not_in?: Maybe<Int[] | Int>;
  fromUser_lt?: Maybe<Int>;
  fromUser_lte?: Maybe<Int>;
  fromUser_gt?: Maybe<Int>;
  fromUser_gte?: Maybe<Int>;
  isDelete?: Maybe<Int>;
  isDelete_not?: Maybe<Int>;
  isDelete_in?: Maybe<Int[] | Int>;
  isDelete_not_in?: Maybe<Int[] | Int>;
  isDelete_lt?: Maybe<Int>;
  isDelete_lte?: Maybe<Int>;
  isDelete_gt?: Maybe<Int>;
  isDelete_gte?: Maybe<Int>;
  isRead?: Maybe<Int>;
  isRead_not?: Maybe<Int>;
  isRead_in?: Maybe<Int[] | Int>;
  isRead_not_in?: Maybe<Int[] | Int>;
  isRead_lt?: Maybe<Int>;
  isRead_lte?: Maybe<Int>;
  isRead_gt?: Maybe<Int>;
  isRead_gte?: Maybe<Int>;
  logCreate?: Maybe<DateTimeInput>;
  logCreate_not?: Maybe<DateTimeInput>;
  logCreate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  logCreate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  logCreate_lt?: Maybe<DateTimeInput>;
  logCreate_lte?: Maybe<DateTimeInput>;
  logCreate_gt?: Maybe<DateTimeInput>;
  logCreate_gte?: Maybe<DateTimeInput>;
  message?: Maybe<String>;
  message_not?: Maybe<String>;
  message_in?: Maybe<String[] | String>;
  message_not_in?: Maybe<String[] | String>;
  message_lt?: Maybe<String>;
  message_lte?: Maybe<String>;
  message_gt?: Maybe<String>;
  message_gte?: Maybe<String>;
  message_contains?: Maybe<String>;
  message_not_contains?: Maybe<String>;
  message_starts_with?: Maybe<String>;
  message_not_starts_with?: Maybe<String>;
  message_ends_with?: Maybe<String>;
  message_not_ends_with?: Maybe<String>;
  sentBy?: Maybe<Int>;
  sentBy_not?: Maybe<Int>;
  sentBy_in?: Maybe<Int[] | Int>;
  sentBy_not_in?: Maybe<Int[] | Int>;
  sentBy_lt?: Maybe<Int>;
  sentBy_lte?: Maybe<Int>;
  sentBy_gt?: Maybe<Int>;
  sentBy_gte?: Maybe<Int>;
  toUser?: Maybe<Int>;
  toUser_not?: Maybe<Int>;
  toUser_in?: Maybe<Int[] | Int>;
  toUser_not_in?: Maybe<Int[] | Int>;
  toUser_lt?: Maybe<Int>;
  toUser_lte?: Maybe<Int>;
  toUser_gt?: Maybe<Int>;
  toUser_gte?: Maybe<Int>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<MessageWhereInput[] | MessageWhereInput>;
  OR?: Maybe<MessageWhereInput[] | MessageWhereInput>;
  NOT?: Maybe<MessageWhereInput[] | MessageWhereInput>;
}

export type MigrationWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export interface MigrationWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  batch?: Maybe<Int>;
  batch_not?: Maybe<Int>;
  batch_in?: Maybe<Int[] | Int>;
  batch_not_in?: Maybe<Int[] | Int>;
  batch_lt?: Maybe<Int>;
  batch_lte?: Maybe<Int>;
  batch_gt?: Maybe<Int>;
  batch_gte?: Maybe<Int>;
  migration?: Maybe<String>;
  migration_not?: Maybe<String>;
  migration_in?: Maybe<String[] | String>;
  migration_not_in?: Maybe<String[] | String>;
  migration_lt?: Maybe<String>;
  migration_lte?: Maybe<String>;
  migration_gt?: Maybe<String>;
  migration_gte?: Maybe<String>;
  migration_contains?: Maybe<String>;
  migration_not_contains?: Maybe<String>;
  migration_starts_with?: Maybe<String>;
  migration_not_starts_with?: Maybe<String>;
  migration_ends_with?: Maybe<String>;
  migration_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<MigrationWhereInput[] | MigrationWhereInput>;
  OR?: Maybe<MigrationWhereInput[] | MigrationWhereInput>;
  NOT?: Maybe<MigrationWhereInput[] | MigrationWhereInput>;
}

export type OfferWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export interface OfferWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  descriptionArabic?: Maybe<String>;
  descriptionArabic_not?: Maybe<String>;
  descriptionArabic_in?: Maybe<String[] | String>;
  descriptionArabic_not_in?: Maybe<String[] | String>;
  descriptionArabic_lt?: Maybe<String>;
  descriptionArabic_lte?: Maybe<String>;
  descriptionArabic_gt?: Maybe<String>;
  descriptionArabic_gte?: Maybe<String>;
  descriptionArabic_contains?: Maybe<String>;
  descriptionArabic_not_contains?: Maybe<String>;
  descriptionArabic_starts_with?: Maybe<String>;
  descriptionArabic_not_starts_with?: Maybe<String>;
  descriptionArabic_ends_with?: Maybe<String>;
  descriptionArabic_not_ends_with?: Maybe<String>;
  endDate?: Maybe<DateTimeInput>;
  endDate_not?: Maybe<DateTimeInput>;
  endDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  endDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  endDate_lt?: Maybe<DateTimeInput>;
  endDate_lte?: Maybe<DateTimeInput>;
  endDate_gt?: Maybe<DateTimeInput>;
  endDate_gte?: Maybe<DateTimeInput>;
  heading?: Maybe<String>;
  heading_not?: Maybe<String>;
  heading_in?: Maybe<String[] | String>;
  heading_not_in?: Maybe<String[] | String>;
  heading_lt?: Maybe<String>;
  heading_lte?: Maybe<String>;
  heading_gt?: Maybe<String>;
  heading_gte?: Maybe<String>;
  heading_contains?: Maybe<String>;
  heading_not_contains?: Maybe<String>;
  heading_starts_with?: Maybe<String>;
  heading_not_starts_with?: Maybe<String>;
  heading_ends_with?: Maybe<String>;
  heading_not_ends_with?: Maybe<String>;
  headingArabic?: Maybe<String>;
  headingArabic_not?: Maybe<String>;
  headingArabic_in?: Maybe<String[] | String>;
  headingArabic_not_in?: Maybe<String[] | String>;
  headingArabic_lt?: Maybe<String>;
  headingArabic_lte?: Maybe<String>;
  headingArabic_gt?: Maybe<String>;
  headingArabic_gte?: Maybe<String>;
  headingArabic_contains?: Maybe<String>;
  headingArabic_not_contains?: Maybe<String>;
  headingArabic_starts_with?: Maybe<String>;
  headingArabic_not_starts_with?: Maybe<String>;
  headingArabic_ends_with?: Maybe<String>;
  headingArabic_not_ends_with?: Maybe<String>;
  hospitalId?: Maybe<Int>;
  hospitalId_not?: Maybe<Int>;
  hospitalId_in?: Maybe<Int[] | Int>;
  hospitalId_not_in?: Maybe<Int[] | Int>;
  hospitalId_lt?: Maybe<Int>;
  hospitalId_lte?: Maybe<Int>;
  hospitalId_gt?: Maybe<Int>;
  hospitalId_gte?: Maybe<Int>;
  offerImage?: Maybe<String>;
  offerImage_not?: Maybe<String>;
  offerImage_in?: Maybe<String[] | String>;
  offerImage_not_in?: Maybe<String[] | String>;
  offerImage_lt?: Maybe<String>;
  offerImage_lte?: Maybe<String>;
  offerImage_gt?: Maybe<String>;
  offerImage_gte?: Maybe<String>;
  offerImage_contains?: Maybe<String>;
  offerImage_not_contains?: Maybe<String>;
  offerImage_starts_with?: Maybe<String>;
  offerImage_not_starts_with?: Maybe<String>;
  offerImage_ends_with?: Maybe<String>;
  offerImage_not_ends_with?: Maybe<String>;
  position?: Maybe<Int>;
  position_not?: Maybe<Int>;
  position_in?: Maybe<Int[] | Int>;
  position_not_in?: Maybe<Int[] | Int>;
  position_lt?: Maybe<Int>;
  position_lte?: Maybe<Int>;
  position_gt?: Maybe<Int>;
  position_gte?: Maybe<Int>;
  startDate?: Maybe<DateTimeInput>;
  startDate_not?: Maybe<DateTimeInput>;
  startDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  startDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  startDate_lt?: Maybe<DateTimeInput>;
  startDate_lte?: Maybe<DateTimeInput>;
  startDate_gt?: Maybe<DateTimeInput>;
  startDate_gte?: Maybe<DateTimeInput>;
  status?: Maybe<Int>;
  status_not?: Maybe<Int>;
  status_in?: Maybe<Int[] | Int>;
  status_not_in?: Maybe<Int[] | Int>;
  status_lt?: Maybe<Int>;
  status_lte?: Maybe<Int>;
  status_gt?: Maybe<Int>;
  status_gte?: Maybe<Int>;
  type?: Maybe<Int>;
  type_not?: Maybe<Int>;
  type_in?: Maybe<Int[] | Int>;
  type_not_in?: Maybe<Int[] | Int>;
  type_lt?: Maybe<Int>;
  type_lte?: Maybe<Int>;
  type_gt?: Maybe<Int>;
  type_gte?: Maybe<Int>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<OfferWhereInput[] | OfferWhereInput>;
  OR?: Maybe<OfferWhereInput[] | OfferWhereInput>;
  NOT?: Maybe<OfferWhereInput[] | OfferWhereInput>;
}

export type OnlineAppointmentWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export interface OnlineAppointmentWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  apointmentDate?: Maybe<String>;
  apointmentDate_not?: Maybe<String>;
  apointmentDate_in?: Maybe<String[] | String>;
  apointmentDate_not_in?: Maybe<String[] | String>;
  apointmentDate_lt?: Maybe<String>;
  apointmentDate_lte?: Maybe<String>;
  apointmentDate_gt?: Maybe<String>;
  apointmentDate_gte?: Maybe<String>;
  apointmentDate_contains?: Maybe<String>;
  apointmentDate_not_contains?: Maybe<String>;
  apointmentDate_starts_with?: Maybe<String>;
  apointmentDate_not_starts_with?: Maybe<String>;
  apointmentDate_ends_with?: Maybe<String>;
  apointmentDate_not_ends_with?: Maybe<String>;
  apointmentFulldate?: Maybe<Int>;
  apointmentFulldate_not?: Maybe<Int>;
  apointmentFulldate_in?: Maybe<Int[] | Int>;
  apointmentFulldate_not_in?: Maybe<Int[] | Int>;
  apointmentFulldate_lt?: Maybe<Int>;
  apointmentFulldate_lte?: Maybe<Int>;
  apointmentFulldate_gt?: Maybe<Int>;
  apointmentFulldate_gte?: Maybe<Int>;
  apointmentTime?: Maybe<String>;
  apointmentTime_not?: Maybe<String>;
  apointmentTime_in?: Maybe<String[] | String>;
  apointmentTime_not_in?: Maybe<String[] | String>;
  apointmentTime_lt?: Maybe<String>;
  apointmentTime_lte?: Maybe<String>;
  apointmentTime_gt?: Maybe<String>;
  apointmentTime_gte?: Maybe<String>;
  apointmentTime_contains?: Maybe<String>;
  apointmentTime_not_contains?: Maybe<String>;
  apointmentTime_starts_with?: Maybe<String>;
  apointmentTime_not_starts_with?: Maybe<String>;
  apointmentTime_ends_with?: Maybe<String>;
  apointmentTime_not_ends_with?: Maybe<String>;
  diseaseId?: Maybe<Int>;
  diseaseId_not?: Maybe<Int>;
  diseaseId_in?: Maybe<Int[] | Int>;
  diseaseId_not_in?: Maybe<Int[] | Int>;
  diseaseId_lt?: Maybe<Int>;
  diseaseId_lte?: Maybe<Int>;
  diseaseId_gt?: Maybe<Int>;
  diseaseId_gte?: Maybe<Int>;
  doctorArabic?: Maybe<String>;
  doctorArabic_not?: Maybe<String>;
  doctorArabic_in?: Maybe<String[] | String>;
  doctorArabic_not_in?: Maybe<String[] | String>;
  doctorArabic_lt?: Maybe<String>;
  doctorArabic_lte?: Maybe<String>;
  doctorArabic_gt?: Maybe<String>;
  doctorArabic_gte?: Maybe<String>;
  doctorArabic_contains?: Maybe<String>;
  doctorArabic_not_contains?: Maybe<String>;
  doctorArabic_starts_with?: Maybe<String>;
  doctorArabic_not_starts_with?: Maybe<String>;
  doctorArabic_ends_with?: Maybe<String>;
  doctorArabic_not_ends_with?: Maybe<String>;
  doctorId?: Maybe<Int>;
  doctorId_not?: Maybe<Int>;
  doctorId_in?: Maybe<Int[] | Int>;
  doctorId_not_in?: Maybe<Int[] | Int>;
  doctorId_lt?: Maybe<Int>;
  doctorId_lte?: Maybe<Int>;
  doctorId_gt?: Maybe<Int>;
  doctorId_gte?: Maybe<Int>;
  doctorName?: Maybe<String>;
  doctorName_not?: Maybe<String>;
  doctorName_in?: Maybe<String[] | String>;
  doctorName_not_in?: Maybe<String[] | String>;
  doctorName_lt?: Maybe<String>;
  doctorName_lte?: Maybe<String>;
  doctorName_gt?: Maybe<String>;
  doctorName_gte?: Maybe<String>;
  doctorName_contains?: Maybe<String>;
  doctorName_not_contains?: Maybe<String>;
  doctorName_starts_with?: Maybe<String>;
  doctorName_not_starts_with?: Maybe<String>;
  doctorName_ends_with?: Maybe<String>;
  doctorName_not_ends_with?: Maybe<String>;
  dtId?: Maybe<Int>;
  dtId_not?: Maybe<Int>;
  dtId_in?: Maybe<Int[] | Int>;
  dtId_not_in?: Maybe<Int[] | Int>;
  dtId_lt?: Maybe<Int>;
  dtId_lte?: Maybe<Int>;
  dtId_gt?: Maybe<Int>;
  dtId_gte?: Maybe<Int>;
  gender?: Maybe<String>;
  gender_not?: Maybe<String>;
  gender_in?: Maybe<String[] | String>;
  gender_not_in?: Maybe<String[] | String>;
  gender_lt?: Maybe<String>;
  gender_lte?: Maybe<String>;
  gender_gt?: Maybe<String>;
  gender_gte?: Maybe<String>;
  gender_contains?: Maybe<String>;
  gender_not_contains?: Maybe<String>;
  gender_starts_with?: Maybe<String>;
  gender_not_starts_with?: Maybe<String>;
  gender_ends_with?: Maybe<String>;
  gender_not_ends_with?: Maybe<String>;
  optId?: Maybe<Int>;
  optId_not?: Maybe<Int>;
  optId_in?: Maybe<Int[] | Int>;
  optId_not_in?: Maybe<Int[] | Int>;
  optId_lt?: Maybe<Int>;
  optId_lte?: Maybe<Int>;
  optId_gt?: Maybe<Int>;
  optId_gte?: Maybe<Int>;
  patientId?: Maybe<Int>;
  patientId_not?: Maybe<Int>;
  patientId_in?: Maybe<Int[] | Int>;
  patientId_not_in?: Maybe<Int[] | Int>;
  patientId_lt?: Maybe<Int>;
  patientId_lte?: Maybe<Int>;
  patientId_gt?: Maybe<Int>;
  patientId_gte?: Maybe<Int>;
  phone?: Maybe<String>;
  phone_not?: Maybe<String>;
  phone_in?: Maybe<String[] | String>;
  phone_not_in?: Maybe<String[] | String>;
  phone_lt?: Maybe<String>;
  phone_lte?: Maybe<String>;
  phone_gt?: Maybe<String>;
  phone_gte?: Maybe<String>;
  phone_contains?: Maybe<String>;
  phone_not_contains?: Maybe<String>;
  phone_starts_with?: Maybe<String>;
  phone_not_starts_with?: Maybe<String>;
  phone_ends_with?: Maybe<String>;
  phone_not_ends_with?: Maybe<String>;
  phoneCode?: Maybe<String>;
  phoneCode_not?: Maybe<String>;
  phoneCode_in?: Maybe<String[] | String>;
  phoneCode_not_in?: Maybe<String[] | String>;
  phoneCode_lt?: Maybe<String>;
  phoneCode_lte?: Maybe<String>;
  phoneCode_gt?: Maybe<String>;
  phoneCode_gte?: Maybe<String>;
  phoneCode_contains?: Maybe<String>;
  phoneCode_not_contains?: Maybe<String>;
  phoneCode_starts_with?: Maybe<String>;
  phoneCode_not_starts_with?: Maybe<String>;
  phoneCode_ends_with?: Maybe<String>;
  phoneCode_not_ends_with?: Maybe<String>;
  scheduleTimeId?: Maybe<Int>;
  scheduleTimeId_not?: Maybe<Int>;
  scheduleTimeId_in?: Maybe<Int[] | Int>;
  scheduleTimeId_not_in?: Maybe<Int[] | Int>;
  scheduleTimeId_lt?: Maybe<Int>;
  scheduleTimeId_lte?: Maybe<Int>;
  scheduleTimeId_gt?: Maybe<Int>;
  scheduleTimeId_gte?: Maybe<Int>;
  status?: Maybe<Int>;
  status_not?: Maybe<Int>;
  status_in?: Maybe<Int[] | Int>;
  status_not_in?: Maybe<Int[] | Int>;
  status_lt?: Maybe<Int>;
  status_lte?: Maybe<Int>;
  status_gt?: Maybe<Int>;
  status_gte?: Maybe<Int>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<OnlineAppointmentWhereInput[] | OnlineAppointmentWhereInput>;
  OR?: Maybe<OnlineAppointmentWhereInput[] | OnlineAppointmentWhereInput>;
  NOT?: Maybe<OnlineAppointmentWhereInput[] | OnlineAppointmentWhereInput>;
}

export type OnlineDoctorWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export interface OnlineDoctorWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  apiKey?: Maybe<String>;
  apiKey_not?: Maybe<String>;
  apiKey_in?: Maybe<String[] | String>;
  apiKey_not_in?: Maybe<String[] | String>;
  apiKey_lt?: Maybe<String>;
  apiKey_lte?: Maybe<String>;
  apiKey_gt?: Maybe<String>;
  apiKey_gte?: Maybe<String>;
  apiKey_contains?: Maybe<String>;
  apiKey_not_contains?: Maybe<String>;
  apiKey_starts_with?: Maybe<String>;
  apiKey_not_starts_with?: Maybe<String>;
  apiKey_ends_with?: Maybe<String>;
  apiKey_not_ends_with?: Maybe<String>;
  createdDate?: Maybe<DateTimeInput>;
  createdDate_not?: Maybe<DateTimeInput>;
  createdDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdDate_lt?: Maybe<DateTimeInput>;
  createdDate_lte?: Maybe<DateTimeInput>;
  createdDate_gt?: Maybe<DateTimeInput>;
  createdDate_gte?: Maybe<DateTimeInput>;
  designation?: Maybe<String>;
  designation_not?: Maybe<String>;
  designation_in?: Maybe<String[] | String>;
  designation_not_in?: Maybe<String[] | String>;
  designation_lt?: Maybe<String>;
  designation_lte?: Maybe<String>;
  designation_gt?: Maybe<String>;
  designation_gte?: Maybe<String>;
  designation_contains?: Maybe<String>;
  designation_not_contains?: Maybe<String>;
  designation_starts_with?: Maybe<String>;
  designation_not_starts_with?: Maybe<String>;
  designation_ends_with?: Maybe<String>;
  designation_not_ends_with?: Maybe<String>;
  doctorCv?: Maybe<String>;
  doctorCv_not?: Maybe<String>;
  doctorCv_in?: Maybe<String[] | String>;
  doctorCv_not_in?: Maybe<String[] | String>;
  doctorCv_lt?: Maybe<String>;
  doctorCv_lte?: Maybe<String>;
  doctorCv_gt?: Maybe<String>;
  doctorCv_gte?: Maybe<String>;
  doctorCv_contains?: Maybe<String>;
  doctorCv_not_contains?: Maybe<String>;
  doctorCv_starts_with?: Maybe<String>;
  doctorCv_not_starts_with?: Maybe<String>;
  doctorCv_ends_with?: Maybe<String>;
  doctorCv_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  gender?: Maybe<String>;
  gender_not?: Maybe<String>;
  gender_in?: Maybe<String[] | String>;
  gender_not_in?: Maybe<String[] | String>;
  gender_lt?: Maybe<String>;
  gender_lte?: Maybe<String>;
  gender_gt?: Maybe<String>;
  gender_gte?: Maybe<String>;
  gender_contains?: Maybe<String>;
  gender_not_contains?: Maybe<String>;
  gender_starts_with?: Maybe<String>;
  gender_not_starts_with?: Maybe<String>;
  gender_ends_with?: Maybe<String>;
  gender_not_ends_with?: Maybe<String>;
  lastSeen?: Maybe<DateTimeInput>;
  lastSeen_not?: Maybe<DateTimeInput>;
  lastSeen_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  lastSeen_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  lastSeen_lt?: Maybe<DateTimeInput>;
  lastSeen_lte?: Maybe<DateTimeInput>;
  lastSeen_gt?: Maybe<DateTimeInput>;
  lastSeen_gte?: Maybe<DateTimeInput>;
  mohcard?: Maybe<String>;
  mohcard_not?: Maybe<String>;
  mohcard_in?: Maybe<String[] | String>;
  mohcard_not_in?: Maybe<String[] | String>;
  mohcard_lt?: Maybe<String>;
  mohcard_lte?: Maybe<String>;
  mohcard_gt?: Maybe<String>;
  mohcard_gte?: Maybe<String>;
  mohcard_contains?: Maybe<String>;
  mohcard_not_contains?: Maybe<String>;
  mohcard_starts_with?: Maybe<String>;
  mohcard_not_starts_with?: Maybe<String>;
  mohcard_ends_with?: Maybe<String>;
  mohcard_not_ends_with?: Maybe<String>;
  mohId?: Maybe<String>;
  mohId_not?: Maybe<String>;
  mohId_in?: Maybe<String[] | String>;
  mohId_not_in?: Maybe<String[] | String>;
  mohId_lt?: Maybe<String>;
  mohId_lte?: Maybe<String>;
  mohId_gt?: Maybe<String>;
  mohId_gte?: Maybe<String>;
  mohId_contains?: Maybe<String>;
  mohId_not_contains?: Maybe<String>;
  mohId_starts_with?: Maybe<String>;
  mohId_not_starts_with?: Maybe<String>;
  mohId_ends_with?: Maybe<String>;
  mohId_not_ends_with?: Maybe<String>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  nameArabic?: Maybe<String>;
  nameArabic_not?: Maybe<String>;
  nameArabic_in?: Maybe<String[] | String>;
  nameArabic_not_in?: Maybe<String[] | String>;
  nameArabic_lt?: Maybe<String>;
  nameArabic_lte?: Maybe<String>;
  nameArabic_gt?: Maybe<String>;
  nameArabic_gte?: Maybe<String>;
  nameArabic_contains?: Maybe<String>;
  nameArabic_not_contains?: Maybe<String>;
  nameArabic_starts_with?: Maybe<String>;
  nameArabic_not_starts_with?: Maybe<String>;
  nameArabic_ends_with?: Maybe<String>;
  nameArabic_not_ends_with?: Maybe<String>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  phone?: Maybe<String>;
  phone_not?: Maybe<String>;
  phone_in?: Maybe<String[] | String>;
  phone_not_in?: Maybe<String[] | String>;
  phone_lt?: Maybe<String>;
  phone_lte?: Maybe<String>;
  phone_gt?: Maybe<String>;
  phone_gte?: Maybe<String>;
  phone_contains?: Maybe<String>;
  phone_not_contains?: Maybe<String>;
  phone_starts_with?: Maybe<String>;
  phone_not_starts_with?: Maybe<String>;
  phone_ends_with?: Maybe<String>;
  phone_not_ends_with?: Maybe<String>;
  picture?: Maybe<String>;
  picture_not?: Maybe<String>;
  picture_in?: Maybe<String[] | String>;
  picture_not_in?: Maybe<String[] | String>;
  picture_lt?: Maybe<String>;
  picture_lte?: Maybe<String>;
  picture_gt?: Maybe<String>;
  picture_gte?: Maybe<String>;
  picture_contains?: Maybe<String>;
  picture_not_contains?: Maybe<String>;
  picture_starts_with?: Maybe<String>;
  picture_not_starts_with?: Maybe<String>;
  picture_ends_with?: Maybe<String>;
  picture_not_ends_with?: Maybe<String>;
  specialityId?: Maybe<Int>;
  specialityId_not?: Maybe<Int>;
  specialityId_in?: Maybe<Int[] | Int>;
  specialityId_not_in?: Maybe<Int[] | Int>;
  specialityId_lt?: Maybe<Int>;
  specialityId_lte?: Maybe<Int>;
  specialityId_gt?: Maybe<Int>;
  specialityId_gte?: Maybe<Int>;
  status?: Maybe<Int>;
  status_not?: Maybe<Int>;
  status_in?: Maybe<Int[] | Int>;
  status_not_in?: Maybe<Int[] | Int>;
  status_lt?: Maybe<Int>;
  status_lte?: Maybe<Int>;
  status_gt?: Maybe<Int>;
  status_gte?: Maybe<Int>;
  AND?: Maybe<OnlineDoctorWhereInput[] | OnlineDoctorWhereInput>;
  OR?: Maybe<OnlineDoctorWhereInput[] | OnlineDoctorWhereInput>;
  NOT?: Maybe<OnlineDoctorWhereInput[] | OnlineDoctorWhereInput>;
}

export type OnlineRatingWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export interface OnlineRatingWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  doctorsId?: Maybe<Int>;
  doctorsId_not?: Maybe<Int>;
  doctorsId_in?: Maybe<Int[] | Int>;
  doctorsId_not_in?: Maybe<Int[] | Int>;
  doctorsId_lt?: Maybe<Int>;
  doctorsId_lte?: Maybe<Int>;
  doctorsId_gt?: Maybe<Int>;
  doctorsId_gte?: Maybe<Int>;
  rating?: Maybe<String>;
  rating_not?: Maybe<String>;
  rating_in?: Maybe<String[] | String>;
  rating_not_in?: Maybe<String[] | String>;
  rating_lt?: Maybe<String>;
  rating_lte?: Maybe<String>;
  rating_gt?: Maybe<String>;
  rating_gte?: Maybe<String>;
  rating_contains?: Maybe<String>;
  rating_not_contains?: Maybe<String>;
  rating_starts_with?: Maybe<String>;
  rating_not_starts_with?: Maybe<String>;
  rating_ends_with?: Maybe<String>;
  rating_not_ends_with?: Maybe<String>;
  systemIp?: Maybe<String>;
  systemIp_not?: Maybe<String>;
  systemIp_in?: Maybe<String[] | String>;
  systemIp_not_in?: Maybe<String[] | String>;
  systemIp_lt?: Maybe<String>;
  systemIp_lte?: Maybe<String>;
  systemIp_gt?: Maybe<String>;
  systemIp_gte?: Maybe<String>;
  systemIp_contains?: Maybe<String>;
  systemIp_not_contains?: Maybe<String>;
  systemIp_starts_with?: Maybe<String>;
  systemIp_not_starts_with?: Maybe<String>;
  systemIp_ends_with?: Maybe<String>;
  systemIp_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<OnlineRatingWhereInput[] | OnlineRatingWhereInput>;
  OR?: Maybe<OnlineRatingWhereInput[] | OnlineRatingWhereInput>;
  NOT?: Maybe<OnlineRatingWhereInput[] | OnlineRatingWhereInput>;
}

export type OptTimeWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export type PageWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
  slug?: Maybe<String>;
  slug_ar?: Maybe<String>;
}>;

export interface PageWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  slug?: Maybe<String>;
  slug_not?: Maybe<String>;
  slug_in?: Maybe<String[] | String>;
  slug_not_in?: Maybe<String[] | String>;
  slug_lt?: Maybe<String>;
  slug_lte?: Maybe<String>;
  slug_gt?: Maybe<String>;
  slug_gte?: Maybe<String>;
  slug_contains?: Maybe<String>;
  slug_not_contains?: Maybe<String>;
  slug_starts_with?: Maybe<String>;
  slug_not_starts_with?: Maybe<String>;
  slug_ends_with?: Maybe<String>;
  slug_not_ends_with?: Maybe<String>;
  slug_ar?: Maybe<String>;
  slug_ar_not?: Maybe<String>;
  slug_ar_in?: Maybe<String[] | String>;
  slug_ar_not_in?: Maybe<String[] | String>;
  slug_ar_lt?: Maybe<String>;
  slug_ar_lte?: Maybe<String>;
  slug_ar_gt?: Maybe<String>;
  slug_ar_gte?: Maybe<String>;
  slug_ar_contains?: Maybe<String>;
  slug_ar_not_contains?: Maybe<String>;
  slug_ar_starts_with?: Maybe<String>;
  slug_ar_not_starts_with?: Maybe<String>;
  slug_ar_ends_with?: Maybe<String>;
  slug_ar_not_ends_with?: Maybe<String>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  title_ar?: Maybe<String>;
  title_ar_not?: Maybe<String>;
  title_ar_in?: Maybe<String[] | String>;
  title_ar_not_in?: Maybe<String[] | String>;
  title_ar_lt?: Maybe<String>;
  title_ar_lte?: Maybe<String>;
  title_ar_gt?: Maybe<String>;
  title_ar_gte?: Maybe<String>;
  title_ar_contains?: Maybe<String>;
  title_ar_not_contains?: Maybe<String>;
  title_ar_starts_with?: Maybe<String>;
  title_ar_not_starts_with?: Maybe<String>;
  title_ar_ends_with?: Maybe<String>;
  title_ar_not_ends_with?: Maybe<String>;
  content?: Maybe<String>;
  content_not?: Maybe<String>;
  content_in?: Maybe<String[] | String>;
  content_not_in?: Maybe<String[] | String>;
  content_lt?: Maybe<String>;
  content_lte?: Maybe<String>;
  content_gt?: Maybe<String>;
  content_gte?: Maybe<String>;
  content_contains?: Maybe<String>;
  content_not_contains?: Maybe<String>;
  content_starts_with?: Maybe<String>;
  content_not_starts_with?: Maybe<String>;
  content_ends_with?: Maybe<String>;
  content_not_ends_with?: Maybe<String>;
  content_ar?: Maybe<String>;
  content_ar_not?: Maybe<String>;
  content_ar_in?: Maybe<String[] | String>;
  content_ar_not_in?: Maybe<String[] | String>;
  content_ar_lt?: Maybe<String>;
  content_ar_lte?: Maybe<String>;
  content_ar_gt?: Maybe<String>;
  content_ar_gte?: Maybe<String>;
  content_ar_contains?: Maybe<String>;
  content_ar_not_contains?: Maybe<String>;
  content_ar_starts_with?: Maybe<String>;
  content_ar_not_starts_with?: Maybe<String>;
  content_ar_ends_with?: Maybe<String>;
  content_ar_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<PageWhereInput[] | PageWhereInput>;
  OR?: Maybe<PageWhereInput[] | PageWhereInput>;
  NOT?: Maybe<PageWhereInput[] | PageWhereInput>;
}

export type PasswordResetWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export interface PasswordResetWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  token?: Maybe<String>;
  token_not?: Maybe<String>;
  token_in?: Maybe<String[] | String>;
  token_not_in?: Maybe<String[] | String>;
  token_lt?: Maybe<String>;
  token_lte?: Maybe<String>;
  token_gt?: Maybe<String>;
  token_gte?: Maybe<String>;
  token_contains?: Maybe<String>;
  token_not_contains?: Maybe<String>;
  token_starts_with?: Maybe<String>;
  token_not_starts_with?: Maybe<String>;
  token_ends_with?: Maybe<String>;
  token_not_ends_with?: Maybe<String>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<PasswordResetWhereInput[] | PasswordResetWhereInput>;
  OR?: Maybe<PasswordResetWhereInput[] | PasswordResetWhereInput>;
  NOT?: Maybe<PasswordResetWhereInput[] | PasswordResetWhereInput>;
}

export type PatientWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export type PostImageWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export type SearchDesignWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export interface SearchDesignWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  addressColor?: Maybe<String>;
  addressColor_not?: Maybe<String>;
  addressColor_in?: Maybe<String[] | String>;
  addressColor_not_in?: Maybe<String[] | String>;
  addressColor_lt?: Maybe<String>;
  addressColor_lte?: Maybe<String>;
  addressColor_gt?: Maybe<String>;
  addressColor_gte?: Maybe<String>;
  addressColor_contains?: Maybe<String>;
  addressColor_not_contains?: Maybe<String>;
  addressColor_starts_with?: Maybe<String>;
  addressColor_not_starts_with?: Maybe<String>;
  addressColor_ends_with?: Maybe<String>;
  addressColor_not_ends_with?: Maybe<String>;
  addressFamily?: Maybe<String>;
  addressFamily_not?: Maybe<String>;
  addressFamily_in?: Maybe<String[] | String>;
  addressFamily_not_in?: Maybe<String[] | String>;
  addressFamily_lt?: Maybe<String>;
  addressFamily_lte?: Maybe<String>;
  addressFamily_gt?: Maybe<String>;
  addressFamily_gte?: Maybe<String>;
  addressFamily_contains?: Maybe<String>;
  addressFamily_not_contains?: Maybe<String>;
  addressFamily_starts_with?: Maybe<String>;
  addressFamily_not_starts_with?: Maybe<String>;
  addressFamily_ends_with?: Maybe<String>;
  addressFamily_not_ends_with?: Maybe<String>;
  addressStyle?: Maybe<String>;
  addressStyle_not?: Maybe<String>;
  addressStyle_in?: Maybe<String[] | String>;
  addressStyle_not_in?: Maybe<String[] | String>;
  addressStyle_lt?: Maybe<String>;
  addressStyle_lte?: Maybe<String>;
  addressStyle_gt?: Maybe<String>;
  addressStyle_gte?: Maybe<String>;
  addressStyle_contains?: Maybe<String>;
  addressStyle_not_contains?: Maybe<String>;
  addressStyle_starts_with?: Maybe<String>;
  addressStyle_not_starts_with?: Maybe<String>;
  addressStyle_ends_with?: Maybe<String>;
  addressStyle_not_ends_with?: Maybe<String>;
  designationColor?: Maybe<String>;
  designationColor_not?: Maybe<String>;
  designationColor_in?: Maybe<String[] | String>;
  designationColor_not_in?: Maybe<String[] | String>;
  designationColor_lt?: Maybe<String>;
  designationColor_lte?: Maybe<String>;
  designationColor_gt?: Maybe<String>;
  designationColor_gte?: Maybe<String>;
  designationColor_contains?: Maybe<String>;
  designationColor_not_contains?: Maybe<String>;
  designationColor_starts_with?: Maybe<String>;
  designationColor_not_starts_with?: Maybe<String>;
  designationColor_ends_with?: Maybe<String>;
  designationColor_not_ends_with?: Maybe<String>;
  designationFamily?: Maybe<String>;
  designationFamily_not?: Maybe<String>;
  designationFamily_in?: Maybe<String[] | String>;
  designationFamily_not_in?: Maybe<String[] | String>;
  designationFamily_lt?: Maybe<String>;
  designationFamily_lte?: Maybe<String>;
  designationFamily_gt?: Maybe<String>;
  designationFamily_gte?: Maybe<String>;
  designationFamily_contains?: Maybe<String>;
  designationFamily_not_contains?: Maybe<String>;
  designationFamily_starts_with?: Maybe<String>;
  designationFamily_not_starts_with?: Maybe<String>;
  designationFamily_ends_with?: Maybe<String>;
  designationFamily_not_ends_with?: Maybe<String>;
  designationStyle?: Maybe<String>;
  designationStyle_not?: Maybe<String>;
  designationStyle_in?: Maybe<String[] | String>;
  designationStyle_not_in?: Maybe<String[] | String>;
  designationStyle_lt?: Maybe<String>;
  designationStyle_lte?: Maybe<String>;
  designationStyle_gt?: Maybe<String>;
  designationStyle_gte?: Maybe<String>;
  designationStyle_contains?: Maybe<String>;
  designationStyle_not_contains?: Maybe<String>;
  designationStyle_starts_with?: Maybe<String>;
  designationStyle_not_starts_with?: Maybe<String>;
  designationStyle_ends_with?: Maybe<String>;
  designationStyle_not_ends_with?: Maybe<String>;
  doctorColor?: Maybe<String>;
  doctorColor_not?: Maybe<String>;
  doctorColor_in?: Maybe<String[] | String>;
  doctorColor_not_in?: Maybe<String[] | String>;
  doctorColor_lt?: Maybe<String>;
  doctorColor_lte?: Maybe<String>;
  doctorColor_gt?: Maybe<String>;
  doctorColor_gte?: Maybe<String>;
  doctorColor_contains?: Maybe<String>;
  doctorColor_not_contains?: Maybe<String>;
  doctorColor_starts_with?: Maybe<String>;
  doctorColor_not_starts_with?: Maybe<String>;
  doctorColor_ends_with?: Maybe<String>;
  doctorColor_not_ends_with?: Maybe<String>;
  doctorFamily?: Maybe<String>;
  doctorFamily_not?: Maybe<String>;
  doctorFamily_in?: Maybe<String[] | String>;
  doctorFamily_not_in?: Maybe<String[] | String>;
  doctorFamily_lt?: Maybe<String>;
  doctorFamily_lte?: Maybe<String>;
  doctorFamily_gt?: Maybe<String>;
  doctorFamily_gte?: Maybe<String>;
  doctorFamily_contains?: Maybe<String>;
  doctorFamily_not_contains?: Maybe<String>;
  doctorFamily_starts_with?: Maybe<String>;
  doctorFamily_not_starts_with?: Maybe<String>;
  doctorFamily_ends_with?: Maybe<String>;
  doctorFamily_not_ends_with?: Maybe<String>;
  doctorStyle?: Maybe<String>;
  doctorStyle_not?: Maybe<String>;
  doctorStyle_in?: Maybe<String[] | String>;
  doctorStyle_not_in?: Maybe<String[] | String>;
  doctorStyle_lt?: Maybe<String>;
  doctorStyle_lte?: Maybe<String>;
  doctorStyle_gt?: Maybe<String>;
  doctorStyle_gte?: Maybe<String>;
  doctorStyle_contains?: Maybe<String>;
  doctorStyle_not_contains?: Maybe<String>;
  doctorStyle_starts_with?: Maybe<String>;
  doctorStyle_not_starts_with?: Maybe<String>;
  doctorStyle_ends_with?: Maybe<String>;
  doctorStyle_not_ends_with?: Maybe<String>;
  emailColor?: Maybe<String>;
  emailColor_not?: Maybe<String>;
  emailColor_in?: Maybe<String[] | String>;
  emailColor_not_in?: Maybe<String[] | String>;
  emailColor_lt?: Maybe<String>;
  emailColor_lte?: Maybe<String>;
  emailColor_gt?: Maybe<String>;
  emailColor_gte?: Maybe<String>;
  emailColor_contains?: Maybe<String>;
  emailColor_not_contains?: Maybe<String>;
  emailColor_starts_with?: Maybe<String>;
  emailColor_not_starts_with?: Maybe<String>;
  emailColor_ends_with?: Maybe<String>;
  emailColor_not_ends_with?: Maybe<String>;
  emailFamily?: Maybe<String>;
  emailFamily_not?: Maybe<String>;
  emailFamily_in?: Maybe<String[] | String>;
  emailFamily_not_in?: Maybe<String[] | String>;
  emailFamily_lt?: Maybe<String>;
  emailFamily_lte?: Maybe<String>;
  emailFamily_gt?: Maybe<String>;
  emailFamily_gte?: Maybe<String>;
  emailFamily_contains?: Maybe<String>;
  emailFamily_not_contains?: Maybe<String>;
  emailFamily_starts_with?: Maybe<String>;
  emailFamily_not_starts_with?: Maybe<String>;
  emailFamily_ends_with?: Maybe<String>;
  emailFamily_not_ends_with?: Maybe<String>;
  emailStyle?: Maybe<String>;
  emailStyle_not?: Maybe<String>;
  emailStyle_in?: Maybe<String[] | String>;
  emailStyle_not_in?: Maybe<String[] | String>;
  emailStyle_lt?: Maybe<String>;
  emailStyle_lte?: Maybe<String>;
  emailStyle_gt?: Maybe<String>;
  emailStyle_gte?: Maybe<String>;
  emailStyle_contains?: Maybe<String>;
  emailStyle_not_contains?: Maybe<String>;
  emailStyle_starts_with?: Maybe<String>;
  emailStyle_not_starts_with?: Maybe<String>;
  emailStyle_ends_with?: Maybe<String>;
  emailStyle_not_ends_with?: Maybe<String>;
  nameColor?: Maybe<String>;
  nameColor_not?: Maybe<String>;
  nameColor_in?: Maybe<String[] | String>;
  nameColor_not_in?: Maybe<String[] | String>;
  nameColor_lt?: Maybe<String>;
  nameColor_lte?: Maybe<String>;
  nameColor_gt?: Maybe<String>;
  nameColor_gte?: Maybe<String>;
  nameColor_contains?: Maybe<String>;
  nameColor_not_contains?: Maybe<String>;
  nameColor_starts_with?: Maybe<String>;
  nameColor_not_starts_with?: Maybe<String>;
  nameColor_ends_with?: Maybe<String>;
  nameColor_not_ends_with?: Maybe<String>;
  nameFamily?: Maybe<String>;
  nameFamily_not?: Maybe<String>;
  nameFamily_in?: Maybe<String[] | String>;
  nameFamily_not_in?: Maybe<String[] | String>;
  nameFamily_lt?: Maybe<String>;
  nameFamily_lte?: Maybe<String>;
  nameFamily_gt?: Maybe<String>;
  nameFamily_gte?: Maybe<String>;
  nameFamily_contains?: Maybe<String>;
  nameFamily_not_contains?: Maybe<String>;
  nameFamily_starts_with?: Maybe<String>;
  nameFamily_not_starts_with?: Maybe<String>;
  nameFamily_ends_with?: Maybe<String>;
  nameFamily_not_ends_with?: Maybe<String>;
  nameStyle?: Maybe<String>;
  nameStyle_not?: Maybe<String>;
  nameStyle_in?: Maybe<String[] | String>;
  nameStyle_not_in?: Maybe<String[] | String>;
  nameStyle_lt?: Maybe<String>;
  nameStyle_lte?: Maybe<String>;
  nameStyle_gt?: Maybe<String>;
  nameStyle_gte?: Maybe<String>;
  nameStyle_contains?: Maybe<String>;
  nameStyle_not_contains?: Maybe<String>;
  nameStyle_starts_with?: Maybe<String>;
  nameStyle_not_starts_with?: Maybe<String>;
  nameStyle_ends_with?: Maybe<String>;
  nameStyle_not_ends_with?: Maybe<String>;
  phoneColor?: Maybe<String>;
  phoneColor_not?: Maybe<String>;
  phoneColor_in?: Maybe<String[] | String>;
  phoneColor_not_in?: Maybe<String[] | String>;
  phoneColor_lt?: Maybe<String>;
  phoneColor_lte?: Maybe<String>;
  phoneColor_gt?: Maybe<String>;
  phoneColor_gte?: Maybe<String>;
  phoneColor_contains?: Maybe<String>;
  phoneColor_not_contains?: Maybe<String>;
  phoneColor_starts_with?: Maybe<String>;
  phoneColor_not_starts_with?: Maybe<String>;
  phoneColor_ends_with?: Maybe<String>;
  phoneColor_not_ends_with?: Maybe<String>;
  phoneFamily?: Maybe<String>;
  phoneFamily_not?: Maybe<String>;
  phoneFamily_in?: Maybe<String[] | String>;
  phoneFamily_not_in?: Maybe<String[] | String>;
  phoneFamily_lt?: Maybe<String>;
  phoneFamily_lte?: Maybe<String>;
  phoneFamily_gt?: Maybe<String>;
  phoneFamily_gte?: Maybe<String>;
  phoneFamily_contains?: Maybe<String>;
  phoneFamily_not_contains?: Maybe<String>;
  phoneFamily_starts_with?: Maybe<String>;
  phoneFamily_not_starts_with?: Maybe<String>;
  phoneFamily_ends_with?: Maybe<String>;
  phoneFamily_not_ends_with?: Maybe<String>;
  phoneStyle?: Maybe<String>;
  phoneStyle_not?: Maybe<String>;
  phoneStyle_in?: Maybe<String[] | String>;
  phoneStyle_not_in?: Maybe<String[] | String>;
  phoneStyle_lt?: Maybe<String>;
  phoneStyle_lte?: Maybe<String>;
  phoneStyle_gt?: Maybe<String>;
  phoneStyle_gte?: Maybe<String>;
  phoneStyle_contains?: Maybe<String>;
  phoneStyle_not_contains?: Maybe<String>;
  phoneStyle_starts_with?: Maybe<String>;
  phoneStyle_not_starts_with?: Maybe<String>;
  phoneStyle_ends_with?: Maybe<String>;
  phoneStyle_not_ends_with?: Maybe<String>;
  ratingColor?: Maybe<String>;
  ratingColor_not?: Maybe<String>;
  ratingColor_in?: Maybe<String[] | String>;
  ratingColor_not_in?: Maybe<String[] | String>;
  ratingColor_lt?: Maybe<String>;
  ratingColor_lte?: Maybe<String>;
  ratingColor_gt?: Maybe<String>;
  ratingColor_gte?: Maybe<String>;
  ratingColor_contains?: Maybe<String>;
  ratingColor_not_contains?: Maybe<String>;
  ratingColor_starts_with?: Maybe<String>;
  ratingColor_not_starts_with?: Maybe<String>;
  ratingColor_ends_with?: Maybe<String>;
  ratingColor_not_ends_with?: Maybe<String>;
  ratingFamily?: Maybe<String>;
  ratingFamily_not?: Maybe<String>;
  ratingFamily_in?: Maybe<String[] | String>;
  ratingFamily_not_in?: Maybe<String[] | String>;
  ratingFamily_lt?: Maybe<String>;
  ratingFamily_lte?: Maybe<String>;
  ratingFamily_gt?: Maybe<String>;
  ratingFamily_gte?: Maybe<String>;
  ratingFamily_contains?: Maybe<String>;
  ratingFamily_not_contains?: Maybe<String>;
  ratingFamily_starts_with?: Maybe<String>;
  ratingFamily_not_starts_with?: Maybe<String>;
  ratingFamily_ends_with?: Maybe<String>;
  ratingFamily_not_ends_with?: Maybe<String>;
  ratingStyle?: Maybe<String>;
  ratingStyle_not?: Maybe<String>;
  ratingStyle_in?: Maybe<String[] | String>;
  ratingStyle_not_in?: Maybe<String[] | String>;
  ratingStyle_lt?: Maybe<String>;
  ratingStyle_lte?: Maybe<String>;
  ratingStyle_gt?: Maybe<String>;
  ratingStyle_gte?: Maybe<String>;
  ratingStyle_contains?: Maybe<String>;
  ratingStyle_not_contains?: Maybe<String>;
  ratingStyle_starts_with?: Maybe<String>;
  ratingStyle_not_starts_with?: Maybe<String>;
  ratingStyle_ends_with?: Maybe<String>;
  ratingStyle_not_ends_with?: Maybe<String>;
  specialityColor?: Maybe<String>;
  specialityColor_not?: Maybe<String>;
  specialityColor_in?: Maybe<String[] | String>;
  specialityColor_not_in?: Maybe<String[] | String>;
  specialityColor_lt?: Maybe<String>;
  specialityColor_lte?: Maybe<String>;
  specialityColor_gt?: Maybe<String>;
  specialityColor_gte?: Maybe<String>;
  specialityColor_contains?: Maybe<String>;
  specialityColor_not_contains?: Maybe<String>;
  specialityColor_starts_with?: Maybe<String>;
  specialityColor_not_starts_with?: Maybe<String>;
  specialityColor_ends_with?: Maybe<String>;
  specialityColor_not_ends_with?: Maybe<String>;
  specialityFamily?: Maybe<String>;
  specialityFamily_not?: Maybe<String>;
  specialityFamily_in?: Maybe<String[] | String>;
  specialityFamily_not_in?: Maybe<String[] | String>;
  specialityFamily_lt?: Maybe<String>;
  specialityFamily_lte?: Maybe<String>;
  specialityFamily_gt?: Maybe<String>;
  specialityFamily_gte?: Maybe<String>;
  specialityFamily_contains?: Maybe<String>;
  specialityFamily_not_contains?: Maybe<String>;
  specialityFamily_starts_with?: Maybe<String>;
  specialityFamily_not_starts_with?: Maybe<String>;
  specialityFamily_ends_with?: Maybe<String>;
  specialityFamily_not_ends_with?: Maybe<String>;
  specialityStyle?: Maybe<String>;
  specialityStyle_not?: Maybe<String>;
  specialityStyle_in?: Maybe<String[] | String>;
  specialityStyle_not_in?: Maybe<String[] | String>;
  specialityStyle_lt?: Maybe<String>;
  specialityStyle_lte?: Maybe<String>;
  specialityStyle_gt?: Maybe<String>;
  specialityStyle_gte?: Maybe<String>;
  specialityStyle_contains?: Maybe<String>;
  specialityStyle_not_contains?: Maybe<String>;
  specialityStyle_starts_with?: Maybe<String>;
  specialityStyle_not_starts_with?: Maybe<String>;
  specialityStyle_ends_with?: Maybe<String>;
  specialityStyle_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<SearchDesignWhereInput[] | SearchDesignWhereInput>;
  OR?: Maybe<SearchDesignWhereInput[] | SearchDesignWhereInput>;
  NOT?: Maybe<SearchDesignWhereInput[] | SearchDesignWhereInput>;
}

export type SheduleTimeWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export type SliderWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export interface SliderWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  arabicHeading?: Maybe<String>;
  arabicHeading_not?: Maybe<String>;
  arabicHeading_in?: Maybe<String[] | String>;
  arabicHeading_not_in?: Maybe<String[] | String>;
  arabicHeading_lt?: Maybe<String>;
  arabicHeading_lte?: Maybe<String>;
  arabicHeading_gt?: Maybe<String>;
  arabicHeading_gte?: Maybe<String>;
  arabicHeading_contains?: Maybe<String>;
  arabicHeading_not_contains?: Maybe<String>;
  arabicHeading_starts_with?: Maybe<String>;
  arabicHeading_not_starts_with?: Maybe<String>;
  arabicHeading_ends_with?: Maybe<String>;
  arabicHeading_not_ends_with?: Maybe<String>;
  banner?: Maybe<String>;
  banner_not?: Maybe<String>;
  banner_in?: Maybe<String[] | String>;
  banner_not_in?: Maybe<String[] | String>;
  banner_lt?: Maybe<String>;
  banner_lte?: Maybe<String>;
  banner_gt?: Maybe<String>;
  banner_gte?: Maybe<String>;
  banner_contains?: Maybe<String>;
  banner_not_contains?: Maybe<String>;
  banner_starts_with?: Maybe<String>;
  banner_not_starts_with?: Maybe<String>;
  banner_ends_with?: Maybe<String>;
  banner_not_ends_with?: Maybe<String>;
  heading?: Maybe<String>;
  heading_not?: Maybe<String>;
  heading_in?: Maybe<String[] | String>;
  heading_not_in?: Maybe<String[] | String>;
  heading_lt?: Maybe<String>;
  heading_lte?: Maybe<String>;
  heading_gt?: Maybe<String>;
  heading_gte?: Maybe<String>;
  heading_contains?: Maybe<String>;
  heading_not_contains?: Maybe<String>;
  heading_starts_with?: Maybe<String>;
  heading_not_starts_with?: Maybe<String>;
  heading_ends_with?: Maybe<String>;
  heading_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<SliderWhereInput[] | SliderWhereInput>;
  OR?: Maybe<SliderWhereInput[] | SliderWhereInput>;
  NOT?: Maybe<SliderWhereInput[] | SliderWhereInput>;
}

export type SpecialityWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export type TranslationWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export interface TranslationWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  arabi?: Maybe<String>;
  arabi_not?: Maybe<String>;
  arabi_in?: Maybe<String[] | String>;
  arabi_not_in?: Maybe<String[] | String>;
  arabi_lt?: Maybe<String>;
  arabi_lte?: Maybe<String>;
  arabi_gt?: Maybe<String>;
  arabi_gte?: Maybe<String>;
  arabi_contains?: Maybe<String>;
  arabi_not_contains?: Maybe<String>;
  arabi_starts_with?: Maybe<String>;
  arabi_not_starts_with?: Maybe<String>;
  arabi_ends_with?: Maybe<String>;
  arabi_not_ends_with?: Maybe<String>;
  english?: Maybe<String>;
  english_not?: Maybe<String>;
  english_in?: Maybe<String[] | String>;
  english_not_in?: Maybe<String[] | String>;
  english_lt?: Maybe<String>;
  english_lte?: Maybe<String>;
  english_gt?: Maybe<String>;
  english_gte?: Maybe<String>;
  english_contains?: Maybe<String>;
  english_not_contains?: Maybe<String>;
  english_starts_with?: Maybe<String>;
  english_not_starts_with?: Maybe<String>;
  english_ends_with?: Maybe<String>;
  english_not_ends_with?: Maybe<String>;
  index?: Maybe<String>;
  index_not?: Maybe<String>;
  index_in?: Maybe<String[] | String>;
  index_not_in?: Maybe<String[] | String>;
  index_lt?: Maybe<String>;
  index_lte?: Maybe<String>;
  index_gt?: Maybe<String>;
  index_gte?: Maybe<String>;
  index_contains?: Maybe<String>;
  index_not_contains?: Maybe<String>;
  index_starts_with?: Maybe<String>;
  index_not_starts_with?: Maybe<String>;
  index_ends_with?: Maybe<String>;
  index_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<TranslationWhereInput[] | TranslationWhereInput>;
  OR?: Maybe<TranslationWhereInput[] | TranslationWhereInput>;
  NOT?: Maybe<TranslationWhereInput[] | TranslationWhereInput>;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
  email?: Maybe<String>;
}>;

export interface UserWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  rememberToken?: Maybe<String>;
  rememberToken_not?: Maybe<String>;
  rememberToken_in?: Maybe<String[] | String>;
  rememberToken_not_in?: Maybe<String[] | String>;
  rememberToken_lt?: Maybe<String>;
  rememberToken_lte?: Maybe<String>;
  rememberToken_gt?: Maybe<String>;
  rememberToken_gte?: Maybe<String>;
  rememberToken_contains?: Maybe<String>;
  rememberToken_not_contains?: Maybe<String>;
  rememberToken_starts_with?: Maybe<String>;
  rememberToken_not_starts_with?: Maybe<String>;
  rememberToken_ends_with?: Maybe<String>;
  rememberToken_not_ends_with?: Maybe<String>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<UserWhereInput[] | UserWhereInput>;
  OR?: Maybe<UserWhereInput[] | UserWhereInput>;
  NOT?: Maybe<UserWhereInput[] | UserWhereInput>;
}

export type VideoRequestWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export interface VideoRequestWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  doctorId?: Maybe<Int>;
  doctorId_not?: Maybe<Int>;
  doctorId_in?: Maybe<Int[] | Int>;
  doctorId_not_in?: Maybe<Int[] | Int>;
  doctorId_lt?: Maybe<Int>;
  doctorId_lte?: Maybe<Int>;
  doctorId_gt?: Maybe<Int>;
  doctorId_gte?: Maybe<Int>;
  joinCall?: Maybe<Int>;
  joinCall_not?: Maybe<Int>;
  joinCall_in?: Maybe<Int[] | Int>;
  joinCall_not_in?: Maybe<Int[] | Int>;
  joinCall_lt?: Maybe<Int>;
  joinCall_lte?: Maybe<Int>;
  joinCall_gt?: Maybe<Int>;
  joinCall_gte?: Maybe<Int>;
  patientId?: Maybe<Int>;
  patientId_not?: Maybe<Int>;
  patientId_in?: Maybe<Int[] | Int>;
  patientId_not_in?: Maybe<Int[] | Int>;
  patientId_lt?: Maybe<Int>;
  patientId_lte?: Maybe<Int>;
  patientId_gt?: Maybe<Int>;
  patientId_gte?: Maybe<Int>;
  requestDate?: Maybe<Int>;
  requestDate_not?: Maybe<Int>;
  requestDate_in?: Maybe<Int[] | Int>;
  requestDate_not_in?: Maybe<Int[] | Int>;
  requestDate_lt?: Maybe<Int>;
  requestDate_lte?: Maybe<Int>;
  requestDate_gt?: Maybe<Int>;
  requestDate_gte?: Maybe<Int>;
  videoCode?: Maybe<Int>;
  videoCode_not?: Maybe<Int>;
  videoCode_in?: Maybe<Int[] | Int>;
  videoCode_not_in?: Maybe<Int[] | Int>;
  videoCode_lt?: Maybe<Int>;
  videoCode_lte?: Maybe<Int>;
  videoCode_gt?: Maybe<Int>;
  videoCode_gte?: Maybe<Int>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<VideoRequestWhereInput[] | VideoRequestWhereInput>;
  OR?: Maybe<VideoRequestWhereInput[] | VideoRequestWhereInput>;
  NOT?: Maybe<VideoRequestWhereInput[] | VideoRequestWhereInput>;
}

export type VisitorWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export interface VisitorWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  country?: Maybe<String>;
  country_not?: Maybe<String>;
  country_in?: Maybe<String[] | String>;
  country_not_in?: Maybe<String[] | String>;
  country_lt?: Maybe<String>;
  country_lte?: Maybe<String>;
  country_gt?: Maybe<String>;
  country_gte?: Maybe<String>;
  country_contains?: Maybe<String>;
  country_not_contains?: Maybe<String>;
  country_starts_with?: Maybe<String>;
  country_not_starts_with?: Maybe<String>;
  country_ends_with?: Maybe<String>;
  country_not_ends_with?: Maybe<String>;
  hits?: Maybe<Int>;
  hits_not?: Maybe<Int>;
  hits_in?: Maybe<Int[] | Int>;
  hits_not_in?: Maybe<Int[] | Int>;
  hits_lt?: Maybe<Int>;
  hits_lte?: Maybe<Int>;
  hits_gt?: Maybe<Int>;
  hits_gte?: Maybe<Int>;
  ipAddress?: Maybe<String>;
  ipAddress_not?: Maybe<String>;
  ipAddress_in?: Maybe<String[] | String>;
  ipAddress_not_in?: Maybe<String[] | String>;
  ipAddress_lt?: Maybe<String>;
  ipAddress_lte?: Maybe<String>;
  ipAddress_gt?: Maybe<String>;
  ipAddress_gte?: Maybe<String>;
  ipAddress_contains?: Maybe<String>;
  ipAddress_not_contains?: Maybe<String>;
  ipAddress_starts_with?: Maybe<String>;
  ipAddress_not_starts_with?: Maybe<String>;
  ipAddress_ends_with?: Maybe<String>;
  ipAddress_not_ends_with?: Maybe<String>;
  visitDate?: Maybe<DateTimeInput>;
  visitDate_not?: Maybe<DateTimeInput>;
  visitDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  visitDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  visitDate_lt?: Maybe<DateTimeInput>;
  visitDate_lte?: Maybe<DateTimeInput>;
  visitDate_gt?: Maybe<DateTimeInput>;
  visitDate_gte?: Maybe<DateTimeInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<VisitorWhereInput[] | VisitorWhereInput>;
  OR?: Maybe<VisitorWhereInput[] | VisitorWhereInput>;
  NOT?: Maybe<VisitorWhereInput[] | VisitorWhereInput>;
}

export interface AboutUsCreateInput {
  id?: Maybe<Int>;
  arabicContent: String;
  englishContent: String;
}

export interface AboutUsUpdateInput {
  arabicContent?: Maybe<String>;
  englishContent?: Maybe<String>;
}

export interface AboutUsUpdateManyMutationInput {
  arabicContent?: Maybe<String>;
  englishContent?: Maybe<String>;
}

export interface AdminCreateInput {
  id?: Maybe<Int>;
  email: String;
  pass?: Maybe<String>;
  superAdmin?: Maybe<Int>;
  user?: Maybe<String>;
}

export interface AdminUpdateInput {
  email?: Maybe<String>;
  pass?: Maybe<String>;
  superAdmin?: Maybe<Int>;
  user?: Maybe<String>;
}

export interface AdminUpdateManyMutationInput {
  email?: Maybe<String>;
  pass?: Maybe<String>;
  superAdmin?: Maybe<Int>;
  user?: Maybe<String>;
}

export interface AppointmentCreateInput {
  id?: Maybe<Int>;
  apointmentDate: String;
  apointmentFulldate: Int;
  apointmentTime: String;
  diseaseId?: Maybe<DiseaseCreateOneInput>;
  doctorArabic: String;
  doctorId?: Maybe<DoctorCreateOneInput>;
  doctorName: String;
  dtId?: Maybe<DoctorSheduleTimeCreateOneInput>;
  gender: String;
  hospitalId?: Maybe<HospitalCreateOneInput>;
  isRead?: Maybe<Int>;
  optId?: Maybe<OptTimeCreateOneInput>;
  patientId?: Maybe<PatientCreateOneInput>;
  phone: String;
  phoneCode?: Maybe<String>;
  scheduleTimeId?: Maybe<SheduleTimeCreateOneInput>;
  status?: Maybe<Int>;
}

export interface DiseaseCreateOneInput {
  create?: Maybe<DiseaseCreateInput>;
  connect?: Maybe<DiseaseWhereUniqueInput>;
}

export interface DiseaseCreateInput {
  id?: Maybe<Int>;
  disease?: Maybe<String>;
  diseaseArabic: String;
}

export interface DoctorCreateOneInput {
  create?: Maybe<DoctorCreateInput>;
  connect?: Maybe<DoctorWhereUniqueInput>;
}

export interface DoctorCreateInput {
  id?: Maybe<Int>;
  apiKey: String;
  designation?: Maybe<String>;
  doctorCv: String;
  email?: Maybe<String>;
  gender?: Maybe<String>;
  mohcard?: Maybe<String>;
  mohId: String;
  name?: Maybe<String>;
  nameArabic?: Maybe<String>;
  password?: Maybe<String>;
  phone?: Maybe<String>;
  fees?: Maybe<String>;
  picture?: Maybe<String>;
  specialityId?: Maybe<Int>;
  specialities?: Maybe<SpecialityCreateOneWithoutDoctorsInput>;
  hospital?: Maybe<HospitalCreateManyWithoutDoctorsInput>;
  status?: Maybe<Int>;
}

export interface SpecialityCreateOneWithoutDoctorsInput {
  create?: Maybe<SpecialityCreateWithoutDoctorsInput>;
  connect?: Maybe<SpecialityWhereUniqueInput>;
}

export interface SpecialityCreateWithoutDoctorsInput {
  id?: Maybe<Int>;
  speciality?: Maybe<String>;
  specialityArabic?: Maybe<String>;
}

export interface HospitalCreateManyWithoutDoctorsInput {
  create?: Maybe<
    HospitalCreateWithoutDoctorsInput[] | HospitalCreateWithoutDoctorsInput
  >;
  connect?: Maybe<HospitalWhereUniqueInput[] | HospitalWhereUniqueInput>;
}

export interface HospitalCreateWithoutDoctorsInput {
  id?: Maybe<Int>;
  address: String;
  addressArabic: String;
  apiKey: String;
  city?: Maybe<CityCreateOneWithoutHospitalInput>;
  countryId?: Maybe<CountryCreateOneInput>;
  email?: Maybe<String>;
  hospital?: Maybe<String>;
  hospitalArabic: String;
  language: String;
  latitude: String;
  location: String;
  logo?: Maybe<String>;
  longitude: String;
  password?: Maybe<String>;
  phone?: Maybe<String>;
  phone1: String;
  status?: Maybe<Int>;
  type?: Maybe<String>;
  uniqeId: String;
  insurances?: Maybe<InsuranceCreateManyWithoutHospitalsInput>;
  createdDate: DateTimeInput;
}

export interface CityCreateOneWithoutHospitalInput {
  create?: Maybe<CityCreateWithoutHospitalInput>;
  connect?: Maybe<CityWhereUniqueInput>;
}

export interface CityCreateWithoutHospitalInput {
  id?: Maybe<Int>;
  city?: Maybe<String>;
  cityArabic: String;
  countryId?: Maybe<Int>;
}

export interface CountryCreateOneInput {
  create?: Maybe<CountryCreateInput>;
  connect?: Maybe<CountryWhereUniqueInput>;
}

export interface CountryCreateInput {
  id?: Maybe<Int>;
  country?: Maybe<String>;
  countryArabic: String;
}

export interface InsuranceCreateManyWithoutHospitalsInput {
  create?: Maybe<
    | InsuranceCreateWithoutHospitalsInput[]
    | InsuranceCreateWithoutHospitalsInput
  >;
  connect?: Maybe<InsuranceWhereUniqueInput[] | InsuranceWhereUniqueInput>;
}

export interface InsuranceCreateWithoutHospitalsInput {
  id?: Maybe<Int>;
  countryId: Int;
  insurance?: Maybe<String>;
  insuranceArabic?: Maybe<String>;
}

export interface DoctorSheduleTimeCreateOneInput {
  create?: Maybe<DoctorSheduleTimeCreateInput>;
  connect?: Maybe<DoctorSheduleTimeWhereUniqueInput>;
}

export interface DoctorSheduleTimeCreateInput {
  id?: Maybe<Int>;
  drSheduleId?: Maybe<Int>;
  scheduleTime?: Maybe<Int>;
  status?: Maybe<Int>;
}

export interface HospitalCreateOneInput {
  create?: Maybe<HospitalCreateInput>;
  connect?: Maybe<HospitalWhereUniqueInput>;
}

export interface HospitalCreateInput {
  id?: Maybe<Int>;
  address: String;
  addressArabic: String;
  apiKey: String;
  city?: Maybe<CityCreateOneWithoutHospitalInput>;
  countryId?: Maybe<CountryCreateOneInput>;
  email?: Maybe<String>;
  hospital?: Maybe<String>;
  hospitalArabic: String;
  doctors?: Maybe<DoctorCreateManyWithoutHospitalInput>;
  language: String;
  latitude: String;
  location: String;
  logo?: Maybe<String>;
  longitude: String;
  password?: Maybe<String>;
  phone?: Maybe<String>;
  phone1: String;
  status?: Maybe<Int>;
  type?: Maybe<String>;
  uniqeId: String;
  insurances?: Maybe<InsuranceCreateManyWithoutHospitalsInput>;
  createdDate: DateTimeInput;
}

export interface DoctorCreateManyWithoutHospitalInput {
  create?: Maybe<
    DoctorCreateWithoutHospitalInput[] | DoctorCreateWithoutHospitalInput
  >;
  connect?: Maybe<DoctorWhereUniqueInput[] | DoctorWhereUniqueInput>;
}

export interface DoctorCreateWithoutHospitalInput {
  id?: Maybe<Int>;
  apiKey: String;
  designation?: Maybe<String>;
  doctorCv: String;
  email?: Maybe<String>;
  gender?: Maybe<String>;
  mohcard?: Maybe<String>;
  mohId: String;
  name?: Maybe<String>;
  nameArabic?: Maybe<String>;
  password?: Maybe<String>;
  phone?: Maybe<String>;
  fees?: Maybe<String>;
  picture?: Maybe<String>;
  specialityId?: Maybe<Int>;
  specialities?: Maybe<SpecialityCreateOneWithoutDoctorsInput>;
  status?: Maybe<Int>;
}

export interface OptTimeCreateOneInput {
  create?: Maybe<OptTimeCreateInput>;
  connect?: Maybe<OptTimeWhereUniqueInput>;
}

export interface OptTimeCreateInput {
  id?: Maybe<Int>;
  fifteenMins?: Maybe<String>;
  thirtyMins?: Maybe<String>;
  twentyMins?: Maybe<String>;
}

export interface PatientCreateOneInput {
  create?: Maybe<PatientCreateInput>;
  connect?: Maybe<PatientWhereUniqueInput>;
}

export interface PatientCreateInput {
  id?: Maybe<Int>;
  age: Int;
  apiKey: String;
  dob?: Maybe<String>;
  email?: Maybe<String>;
  gender?: Maybe<String>;
  lastAction: String;
  mailSubs?: Maybe<Int>;
  mobile?: Maybe<String>;
  name?: Maybe<String>;
  password?: Maybe<String>;
  status?: Maybe<Int>;
  uniqeId: String;
}

export interface SheduleTimeCreateOneInput {
  create?: Maybe<SheduleTimeCreateInput>;
  connect?: Maybe<SheduleTimeWhereUniqueInput>;
}

export interface SheduleTimeCreateInput {
  id?: Maybe<Int>;
  drSheduleId?: Maybe<Int>;
  scheduleFullDate: Int;
  sheduleTime?: Maybe<String>;
  status?: Maybe<Int>;
}

export interface AppointmentUpdateInput {
  apointmentDate?: Maybe<String>;
  apointmentFulldate?: Maybe<Int>;
  apointmentTime?: Maybe<String>;
  diseaseId?: Maybe<DiseaseUpdateOneInput>;
  doctorArabic?: Maybe<String>;
  doctorId?: Maybe<DoctorUpdateOneInput>;
  doctorName?: Maybe<String>;
  dtId?: Maybe<DoctorSheduleTimeUpdateOneInput>;
  gender?: Maybe<String>;
  hospitalId?: Maybe<HospitalUpdateOneInput>;
  isRead?: Maybe<Int>;
  optId?: Maybe<OptTimeUpdateOneInput>;
  patientId?: Maybe<PatientUpdateOneInput>;
  phone?: Maybe<String>;
  phoneCode?: Maybe<String>;
  scheduleTimeId?: Maybe<SheduleTimeUpdateOneInput>;
  status?: Maybe<Int>;
}

export interface DiseaseUpdateOneInput {
  create?: Maybe<DiseaseCreateInput>;
  update?: Maybe<DiseaseUpdateDataInput>;
  upsert?: Maybe<DiseaseUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<DiseaseWhereUniqueInput>;
}

export interface DiseaseUpdateDataInput {
  disease?: Maybe<String>;
  diseaseArabic?: Maybe<String>;
}

export interface DiseaseUpsertNestedInput {
  update: DiseaseUpdateDataInput;
  create: DiseaseCreateInput;
}

export interface DoctorUpdateOneInput {
  create?: Maybe<DoctorCreateInput>;
  update?: Maybe<DoctorUpdateDataInput>;
  upsert?: Maybe<DoctorUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<DoctorWhereUniqueInput>;
}

export interface DoctorUpdateDataInput {
  apiKey?: Maybe<String>;
  designation?: Maybe<String>;
  doctorCv?: Maybe<String>;
  email?: Maybe<String>;
  gender?: Maybe<String>;
  mohcard?: Maybe<String>;
  mohId?: Maybe<String>;
  name?: Maybe<String>;
  nameArabic?: Maybe<String>;
  password?: Maybe<String>;
  phone?: Maybe<String>;
  fees?: Maybe<String>;
  picture?: Maybe<String>;
  specialityId?: Maybe<Int>;
  specialities?: Maybe<SpecialityUpdateOneWithoutDoctorsInput>;
  hospital?: Maybe<HospitalUpdateManyWithoutDoctorsInput>;
  status?: Maybe<Int>;
}

export interface SpecialityUpdateOneWithoutDoctorsInput {
  create?: Maybe<SpecialityCreateWithoutDoctorsInput>;
  update?: Maybe<SpecialityUpdateWithoutDoctorsDataInput>;
  upsert?: Maybe<SpecialityUpsertWithoutDoctorsInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<SpecialityWhereUniqueInput>;
}

export interface SpecialityUpdateWithoutDoctorsDataInput {
  speciality?: Maybe<String>;
  specialityArabic?: Maybe<String>;
}

export interface SpecialityUpsertWithoutDoctorsInput {
  update: SpecialityUpdateWithoutDoctorsDataInput;
  create: SpecialityCreateWithoutDoctorsInput;
}

export interface HospitalUpdateManyWithoutDoctorsInput {
  create?: Maybe<
    HospitalCreateWithoutDoctorsInput[] | HospitalCreateWithoutDoctorsInput
  >;
  delete?: Maybe<HospitalWhereUniqueInput[] | HospitalWhereUniqueInput>;
  connect?: Maybe<HospitalWhereUniqueInput[] | HospitalWhereUniqueInput>;
  set?: Maybe<HospitalWhereUniqueInput[] | HospitalWhereUniqueInput>;
  disconnect?: Maybe<HospitalWhereUniqueInput[] | HospitalWhereUniqueInput>;
  update?: Maybe<
    | HospitalUpdateWithWhereUniqueWithoutDoctorsInput[]
    | HospitalUpdateWithWhereUniqueWithoutDoctorsInput
  >;
  upsert?: Maybe<
    | HospitalUpsertWithWhereUniqueWithoutDoctorsInput[]
    | HospitalUpsertWithWhereUniqueWithoutDoctorsInput
  >;
  deleteMany?: Maybe<HospitalScalarWhereInput[] | HospitalScalarWhereInput>;
  updateMany?: Maybe<
    | HospitalUpdateManyWithWhereNestedInput[]
    | HospitalUpdateManyWithWhereNestedInput
  >;
}

export interface HospitalUpdateWithWhereUniqueWithoutDoctorsInput {
  where: HospitalWhereUniqueInput;
  data: HospitalUpdateWithoutDoctorsDataInput;
}

export interface HospitalUpdateWithoutDoctorsDataInput {
  address?: Maybe<String>;
  addressArabic?: Maybe<String>;
  apiKey?: Maybe<String>;
  city?: Maybe<CityUpdateOneWithoutHospitalInput>;
  countryId?: Maybe<CountryUpdateOneInput>;
  email?: Maybe<String>;
  hospital?: Maybe<String>;
  hospitalArabic?: Maybe<String>;
  language?: Maybe<String>;
  latitude?: Maybe<String>;
  location?: Maybe<String>;
  logo?: Maybe<String>;
  longitude?: Maybe<String>;
  password?: Maybe<String>;
  phone?: Maybe<String>;
  phone1?: Maybe<String>;
  status?: Maybe<Int>;
  type?: Maybe<String>;
  uniqeId?: Maybe<String>;
  insurances?: Maybe<InsuranceUpdateManyWithoutHospitalsInput>;
  createdDate?: Maybe<DateTimeInput>;
}

export interface CityUpdateOneWithoutHospitalInput {
  create?: Maybe<CityCreateWithoutHospitalInput>;
  update?: Maybe<CityUpdateWithoutHospitalDataInput>;
  upsert?: Maybe<CityUpsertWithoutHospitalInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<CityWhereUniqueInput>;
}

export interface CityUpdateWithoutHospitalDataInput {
  city?: Maybe<String>;
  cityArabic?: Maybe<String>;
  countryId?: Maybe<Int>;
}

export interface CityUpsertWithoutHospitalInput {
  update: CityUpdateWithoutHospitalDataInput;
  create: CityCreateWithoutHospitalInput;
}

export interface CountryUpdateOneInput {
  create?: Maybe<CountryCreateInput>;
  update?: Maybe<CountryUpdateDataInput>;
  upsert?: Maybe<CountryUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<CountryWhereUniqueInput>;
}

export interface CountryUpdateDataInput {
  country?: Maybe<String>;
  countryArabic?: Maybe<String>;
}

export interface CountryUpsertNestedInput {
  update: CountryUpdateDataInput;
  create: CountryCreateInput;
}

export interface InsuranceUpdateManyWithoutHospitalsInput {
  create?: Maybe<
    | InsuranceCreateWithoutHospitalsInput[]
    | InsuranceCreateWithoutHospitalsInput
  >;
  delete?: Maybe<InsuranceWhereUniqueInput[] | InsuranceWhereUniqueInput>;
  connect?: Maybe<InsuranceWhereUniqueInput[] | InsuranceWhereUniqueInput>;
  set?: Maybe<InsuranceWhereUniqueInput[] | InsuranceWhereUniqueInput>;
  disconnect?: Maybe<InsuranceWhereUniqueInput[] | InsuranceWhereUniqueInput>;
  update?: Maybe<
    | InsuranceUpdateWithWhereUniqueWithoutHospitalsInput[]
    | InsuranceUpdateWithWhereUniqueWithoutHospitalsInput
  >;
  upsert?: Maybe<
    | InsuranceUpsertWithWhereUniqueWithoutHospitalsInput[]
    | InsuranceUpsertWithWhereUniqueWithoutHospitalsInput
  >;
  deleteMany?: Maybe<InsuranceScalarWhereInput[] | InsuranceScalarWhereInput>;
  updateMany?: Maybe<
    | InsuranceUpdateManyWithWhereNestedInput[]
    | InsuranceUpdateManyWithWhereNestedInput
  >;
}

export interface InsuranceUpdateWithWhereUniqueWithoutHospitalsInput {
  where: InsuranceWhereUniqueInput;
  data: InsuranceUpdateWithoutHospitalsDataInput;
}

export interface InsuranceUpdateWithoutHospitalsDataInput {
  countryId?: Maybe<Int>;
  insurance?: Maybe<String>;
  insuranceArabic?: Maybe<String>;
}

export interface InsuranceUpsertWithWhereUniqueWithoutHospitalsInput {
  where: InsuranceWhereUniqueInput;
  update: InsuranceUpdateWithoutHospitalsDataInput;
  create: InsuranceCreateWithoutHospitalsInput;
}

export interface InsuranceScalarWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  countryId?: Maybe<Int>;
  countryId_not?: Maybe<Int>;
  countryId_in?: Maybe<Int[] | Int>;
  countryId_not_in?: Maybe<Int[] | Int>;
  countryId_lt?: Maybe<Int>;
  countryId_lte?: Maybe<Int>;
  countryId_gt?: Maybe<Int>;
  countryId_gte?: Maybe<Int>;
  insurance?: Maybe<String>;
  insurance_not?: Maybe<String>;
  insurance_in?: Maybe<String[] | String>;
  insurance_not_in?: Maybe<String[] | String>;
  insurance_lt?: Maybe<String>;
  insurance_lte?: Maybe<String>;
  insurance_gt?: Maybe<String>;
  insurance_gte?: Maybe<String>;
  insurance_contains?: Maybe<String>;
  insurance_not_contains?: Maybe<String>;
  insurance_starts_with?: Maybe<String>;
  insurance_not_starts_with?: Maybe<String>;
  insurance_ends_with?: Maybe<String>;
  insurance_not_ends_with?: Maybe<String>;
  insuranceArabic?: Maybe<String>;
  insuranceArabic_not?: Maybe<String>;
  insuranceArabic_in?: Maybe<String[] | String>;
  insuranceArabic_not_in?: Maybe<String[] | String>;
  insuranceArabic_lt?: Maybe<String>;
  insuranceArabic_lte?: Maybe<String>;
  insuranceArabic_gt?: Maybe<String>;
  insuranceArabic_gte?: Maybe<String>;
  insuranceArabic_contains?: Maybe<String>;
  insuranceArabic_not_contains?: Maybe<String>;
  insuranceArabic_starts_with?: Maybe<String>;
  insuranceArabic_not_starts_with?: Maybe<String>;
  insuranceArabic_ends_with?: Maybe<String>;
  insuranceArabic_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<InsuranceScalarWhereInput[] | InsuranceScalarWhereInput>;
  OR?: Maybe<InsuranceScalarWhereInput[] | InsuranceScalarWhereInput>;
  NOT?: Maybe<InsuranceScalarWhereInput[] | InsuranceScalarWhereInput>;
}

export interface InsuranceUpdateManyWithWhereNestedInput {
  where: InsuranceScalarWhereInput;
  data: InsuranceUpdateManyDataInput;
}

export interface InsuranceUpdateManyDataInput {
  countryId?: Maybe<Int>;
  insurance?: Maybe<String>;
  insuranceArabic?: Maybe<String>;
}

export interface HospitalUpsertWithWhereUniqueWithoutDoctorsInput {
  where: HospitalWhereUniqueInput;
  update: HospitalUpdateWithoutDoctorsDataInput;
  create: HospitalCreateWithoutDoctorsInput;
}

export interface HospitalScalarWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  address?: Maybe<String>;
  address_not?: Maybe<String>;
  address_in?: Maybe<String[] | String>;
  address_not_in?: Maybe<String[] | String>;
  address_lt?: Maybe<String>;
  address_lte?: Maybe<String>;
  address_gt?: Maybe<String>;
  address_gte?: Maybe<String>;
  address_contains?: Maybe<String>;
  address_not_contains?: Maybe<String>;
  address_starts_with?: Maybe<String>;
  address_not_starts_with?: Maybe<String>;
  address_ends_with?: Maybe<String>;
  address_not_ends_with?: Maybe<String>;
  addressArabic?: Maybe<String>;
  addressArabic_not?: Maybe<String>;
  addressArabic_in?: Maybe<String[] | String>;
  addressArabic_not_in?: Maybe<String[] | String>;
  addressArabic_lt?: Maybe<String>;
  addressArabic_lte?: Maybe<String>;
  addressArabic_gt?: Maybe<String>;
  addressArabic_gte?: Maybe<String>;
  addressArabic_contains?: Maybe<String>;
  addressArabic_not_contains?: Maybe<String>;
  addressArabic_starts_with?: Maybe<String>;
  addressArabic_not_starts_with?: Maybe<String>;
  addressArabic_ends_with?: Maybe<String>;
  addressArabic_not_ends_with?: Maybe<String>;
  apiKey?: Maybe<String>;
  apiKey_not?: Maybe<String>;
  apiKey_in?: Maybe<String[] | String>;
  apiKey_not_in?: Maybe<String[] | String>;
  apiKey_lt?: Maybe<String>;
  apiKey_lte?: Maybe<String>;
  apiKey_gt?: Maybe<String>;
  apiKey_gte?: Maybe<String>;
  apiKey_contains?: Maybe<String>;
  apiKey_not_contains?: Maybe<String>;
  apiKey_starts_with?: Maybe<String>;
  apiKey_not_starts_with?: Maybe<String>;
  apiKey_ends_with?: Maybe<String>;
  apiKey_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  hospital?: Maybe<String>;
  hospital_not?: Maybe<String>;
  hospital_in?: Maybe<String[] | String>;
  hospital_not_in?: Maybe<String[] | String>;
  hospital_lt?: Maybe<String>;
  hospital_lte?: Maybe<String>;
  hospital_gt?: Maybe<String>;
  hospital_gte?: Maybe<String>;
  hospital_contains?: Maybe<String>;
  hospital_not_contains?: Maybe<String>;
  hospital_starts_with?: Maybe<String>;
  hospital_not_starts_with?: Maybe<String>;
  hospital_ends_with?: Maybe<String>;
  hospital_not_ends_with?: Maybe<String>;
  hospitalArabic?: Maybe<String>;
  hospitalArabic_not?: Maybe<String>;
  hospitalArabic_in?: Maybe<String[] | String>;
  hospitalArabic_not_in?: Maybe<String[] | String>;
  hospitalArabic_lt?: Maybe<String>;
  hospitalArabic_lte?: Maybe<String>;
  hospitalArabic_gt?: Maybe<String>;
  hospitalArabic_gte?: Maybe<String>;
  hospitalArabic_contains?: Maybe<String>;
  hospitalArabic_not_contains?: Maybe<String>;
  hospitalArabic_starts_with?: Maybe<String>;
  hospitalArabic_not_starts_with?: Maybe<String>;
  hospitalArabic_ends_with?: Maybe<String>;
  hospitalArabic_not_ends_with?: Maybe<String>;
  language?: Maybe<String>;
  language_not?: Maybe<String>;
  language_in?: Maybe<String[] | String>;
  language_not_in?: Maybe<String[] | String>;
  language_lt?: Maybe<String>;
  language_lte?: Maybe<String>;
  language_gt?: Maybe<String>;
  language_gte?: Maybe<String>;
  language_contains?: Maybe<String>;
  language_not_contains?: Maybe<String>;
  language_starts_with?: Maybe<String>;
  language_not_starts_with?: Maybe<String>;
  language_ends_with?: Maybe<String>;
  language_not_ends_with?: Maybe<String>;
  latitude?: Maybe<String>;
  latitude_not?: Maybe<String>;
  latitude_in?: Maybe<String[] | String>;
  latitude_not_in?: Maybe<String[] | String>;
  latitude_lt?: Maybe<String>;
  latitude_lte?: Maybe<String>;
  latitude_gt?: Maybe<String>;
  latitude_gte?: Maybe<String>;
  latitude_contains?: Maybe<String>;
  latitude_not_contains?: Maybe<String>;
  latitude_starts_with?: Maybe<String>;
  latitude_not_starts_with?: Maybe<String>;
  latitude_ends_with?: Maybe<String>;
  latitude_not_ends_with?: Maybe<String>;
  location?: Maybe<String>;
  location_not?: Maybe<String>;
  location_in?: Maybe<String[] | String>;
  location_not_in?: Maybe<String[] | String>;
  location_lt?: Maybe<String>;
  location_lte?: Maybe<String>;
  location_gt?: Maybe<String>;
  location_gte?: Maybe<String>;
  location_contains?: Maybe<String>;
  location_not_contains?: Maybe<String>;
  location_starts_with?: Maybe<String>;
  location_not_starts_with?: Maybe<String>;
  location_ends_with?: Maybe<String>;
  location_not_ends_with?: Maybe<String>;
  logo?: Maybe<String>;
  logo_not?: Maybe<String>;
  logo_in?: Maybe<String[] | String>;
  logo_not_in?: Maybe<String[] | String>;
  logo_lt?: Maybe<String>;
  logo_lte?: Maybe<String>;
  logo_gt?: Maybe<String>;
  logo_gte?: Maybe<String>;
  logo_contains?: Maybe<String>;
  logo_not_contains?: Maybe<String>;
  logo_starts_with?: Maybe<String>;
  logo_not_starts_with?: Maybe<String>;
  logo_ends_with?: Maybe<String>;
  logo_not_ends_with?: Maybe<String>;
  longitude?: Maybe<String>;
  longitude_not?: Maybe<String>;
  longitude_in?: Maybe<String[] | String>;
  longitude_not_in?: Maybe<String[] | String>;
  longitude_lt?: Maybe<String>;
  longitude_lte?: Maybe<String>;
  longitude_gt?: Maybe<String>;
  longitude_gte?: Maybe<String>;
  longitude_contains?: Maybe<String>;
  longitude_not_contains?: Maybe<String>;
  longitude_starts_with?: Maybe<String>;
  longitude_not_starts_with?: Maybe<String>;
  longitude_ends_with?: Maybe<String>;
  longitude_not_ends_with?: Maybe<String>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  phone?: Maybe<String>;
  phone_not?: Maybe<String>;
  phone_in?: Maybe<String[] | String>;
  phone_not_in?: Maybe<String[] | String>;
  phone_lt?: Maybe<String>;
  phone_lte?: Maybe<String>;
  phone_gt?: Maybe<String>;
  phone_gte?: Maybe<String>;
  phone_contains?: Maybe<String>;
  phone_not_contains?: Maybe<String>;
  phone_starts_with?: Maybe<String>;
  phone_not_starts_with?: Maybe<String>;
  phone_ends_with?: Maybe<String>;
  phone_not_ends_with?: Maybe<String>;
  phone1?: Maybe<String>;
  phone1_not?: Maybe<String>;
  phone1_in?: Maybe<String[] | String>;
  phone1_not_in?: Maybe<String[] | String>;
  phone1_lt?: Maybe<String>;
  phone1_lte?: Maybe<String>;
  phone1_gt?: Maybe<String>;
  phone1_gte?: Maybe<String>;
  phone1_contains?: Maybe<String>;
  phone1_not_contains?: Maybe<String>;
  phone1_starts_with?: Maybe<String>;
  phone1_not_starts_with?: Maybe<String>;
  phone1_ends_with?: Maybe<String>;
  phone1_not_ends_with?: Maybe<String>;
  status?: Maybe<Int>;
  status_not?: Maybe<Int>;
  status_in?: Maybe<Int[] | Int>;
  status_not_in?: Maybe<Int[] | Int>;
  status_lt?: Maybe<Int>;
  status_lte?: Maybe<Int>;
  status_gt?: Maybe<Int>;
  status_gte?: Maybe<Int>;
  type?: Maybe<String>;
  type_not?: Maybe<String>;
  type_in?: Maybe<String[] | String>;
  type_not_in?: Maybe<String[] | String>;
  type_lt?: Maybe<String>;
  type_lte?: Maybe<String>;
  type_gt?: Maybe<String>;
  type_gte?: Maybe<String>;
  type_contains?: Maybe<String>;
  type_not_contains?: Maybe<String>;
  type_starts_with?: Maybe<String>;
  type_not_starts_with?: Maybe<String>;
  type_ends_with?: Maybe<String>;
  type_not_ends_with?: Maybe<String>;
  uniqeId?: Maybe<String>;
  uniqeId_not?: Maybe<String>;
  uniqeId_in?: Maybe<String[] | String>;
  uniqeId_not_in?: Maybe<String[] | String>;
  uniqeId_lt?: Maybe<String>;
  uniqeId_lte?: Maybe<String>;
  uniqeId_gt?: Maybe<String>;
  uniqeId_gte?: Maybe<String>;
  uniqeId_contains?: Maybe<String>;
  uniqeId_not_contains?: Maybe<String>;
  uniqeId_starts_with?: Maybe<String>;
  uniqeId_not_starts_with?: Maybe<String>;
  uniqeId_ends_with?: Maybe<String>;
  uniqeId_not_ends_with?: Maybe<String>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  createdDate?: Maybe<DateTimeInput>;
  createdDate_not?: Maybe<DateTimeInput>;
  createdDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdDate_lt?: Maybe<DateTimeInput>;
  createdDate_lte?: Maybe<DateTimeInput>;
  createdDate_gt?: Maybe<DateTimeInput>;
  createdDate_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<HospitalScalarWhereInput[] | HospitalScalarWhereInput>;
  OR?: Maybe<HospitalScalarWhereInput[] | HospitalScalarWhereInput>;
  NOT?: Maybe<HospitalScalarWhereInput[] | HospitalScalarWhereInput>;
}

export interface HospitalUpdateManyWithWhereNestedInput {
  where: HospitalScalarWhereInput;
  data: HospitalUpdateManyDataInput;
}

export interface HospitalUpdateManyDataInput {
  address?: Maybe<String>;
  addressArabic?: Maybe<String>;
  apiKey?: Maybe<String>;
  email?: Maybe<String>;
  hospital?: Maybe<String>;
  hospitalArabic?: Maybe<String>;
  language?: Maybe<String>;
  latitude?: Maybe<String>;
  location?: Maybe<String>;
  logo?: Maybe<String>;
  longitude?: Maybe<String>;
  password?: Maybe<String>;
  phone?: Maybe<String>;
  phone1?: Maybe<String>;
  status?: Maybe<Int>;
  type?: Maybe<String>;
  uniqeId?: Maybe<String>;
  createdDate?: Maybe<DateTimeInput>;
}

export interface DoctorUpsertNestedInput {
  update: DoctorUpdateDataInput;
  create: DoctorCreateInput;
}

export interface DoctorSheduleTimeUpdateOneInput {
  create?: Maybe<DoctorSheduleTimeCreateInput>;
  update?: Maybe<DoctorSheduleTimeUpdateDataInput>;
  upsert?: Maybe<DoctorSheduleTimeUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<DoctorSheduleTimeWhereUniqueInput>;
}

export interface DoctorSheduleTimeUpdateDataInput {
  drSheduleId?: Maybe<Int>;
  scheduleTime?: Maybe<Int>;
  status?: Maybe<Int>;
}

export interface DoctorSheduleTimeUpsertNestedInput {
  update: DoctorSheduleTimeUpdateDataInput;
  create: DoctorSheduleTimeCreateInput;
}

export interface HospitalUpdateOneInput {
  create?: Maybe<HospitalCreateInput>;
  update?: Maybe<HospitalUpdateDataInput>;
  upsert?: Maybe<HospitalUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<HospitalWhereUniqueInput>;
}

export interface HospitalUpdateDataInput {
  address?: Maybe<String>;
  addressArabic?: Maybe<String>;
  apiKey?: Maybe<String>;
  city?: Maybe<CityUpdateOneWithoutHospitalInput>;
  countryId?: Maybe<CountryUpdateOneInput>;
  email?: Maybe<String>;
  hospital?: Maybe<String>;
  hospitalArabic?: Maybe<String>;
  doctors?: Maybe<DoctorUpdateManyWithoutHospitalInput>;
  language?: Maybe<String>;
  latitude?: Maybe<String>;
  location?: Maybe<String>;
  logo?: Maybe<String>;
  longitude?: Maybe<String>;
  password?: Maybe<String>;
  phone?: Maybe<String>;
  phone1?: Maybe<String>;
  status?: Maybe<Int>;
  type?: Maybe<String>;
  uniqeId?: Maybe<String>;
  insurances?: Maybe<InsuranceUpdateManyWithoutHospitalsInput>;
  createdDate?: Maybe<DateTimeInput>;
}

export interface DoctorUpdateManyWithoutHospitalInput {
  create?: Maybe<
    DoctorCreateWithoutHospitalInput[] | DoctorCreateWithoutHospitalInput
  >;
  delete?: Maybe<DoctorWhereUniqueInput[] | DoctorWhereUniqueInput>;
  connect?: Maybe<DoctorWhereUniqueInput[] | DoctorWhereUniqueInput>;
  set?: Maybe<DoctorWhereUniqueInput[] | DoctorWhereUniqueInput>;
  disconnect?: Maybe<DoctorWhereUniqueInput[] | DoctorWhereUniqueInput>;
  update?: Maybe<
    | DoctorUpdateWithWhereUniqueWithoutHospitalInput[]
    | DoctorUpdateWithWhereUniqueWithoutHospitalInput
  >;
  upsert?: Maybe<
    | DoctorUpsertWithWhereUniqueWithoutHospitalInput[]
    | DoctorUpsertWithWhereUniqueWithoutHospitalInput
  >;
  deleteMany?: Maybe<DoctorScalarWhereInput[] | DoctorScalarWhereInput>;
  updateMany?: Maybe<
    | DoctorUpdateManyWithWhereNestedInput[]
    | DoctorUpdateManyWithWhereNestedInput
  >;
}

export interface DoctorUpdateWithWhereUniqueWithoutHospitalInput {
  where: DoctorWhereUniqueInput;
  data: DoctorUpdateWithoutHospitalDataInput;
}

export interface DoctorUpdateWithoutHospitalDataInput {
  apiKey?: Maybe<String>;
  designation?: Maybe<String>;
  doctorCv?: Maybe<String>;
  email?: Maybe<String>;
  gender?: Maybe<String>;
  mohcard?: Maybe<String>;
  mohId?: Maybe<String>;
  name?: Maybe<String>;
  nameArabic?: Maybe<String>;
  password?: Maybe<String>;
  phone?: Maybe<String>;
  fees?: Maybe<String>;
  picture?: Maybe<String>;
  specialityId?: Maybe<Int>;
  specialities?: Maybe<SpecialityUpdateOneWithoutDoctorsInput>;
  status?: Maybe<Int>;
}

export interface DoctorUpsertWithWhereUniqueWithoutHospitalInput {
  where: DoctorWhereUniqueInput;
  update: DoctorUpdateWithoutHospitalDataInput;
  create: DoctorCreateWithoutHospitalInput;
}

export interface DoctorScalarWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  apiKey?: Maybe<String>;
  apiKey_not?: Maybe<String>;
  apiKey_in?: Maybe<String[] | String>;
  apiKey_not_in?: Maybe<String[] | String>;
  apiKey_lt?: Maybe<String>;
  apiKey_lte?: Maybe<String>;
  apiKey_gt?: Maybe<String>;
  apiKey_gte?: Maybe<String>;
  apiKey_contains?: Maybe<String>;
  apiKey_not_contains?: Maybe<String>;
  apiKey_starts_with?: Maybe<String>;
  apiKey_not_starts_with?: Maybe<String>;
  apiKey_ends_with?: Maybe<String>;
  apiKey_not_ends_with?: Maybe<String>;
  designation?: Maybe<String>;
  designation_not?: Maybe<String>;
  designation_in?: Maybe<String[] | String>;
  designation_not_in?: Maybe<String[] | String>;
  designation_lt?: Maybe<String>;
  designation_lte?: Maybe<String>;
  designation_gt?: Maybe<String>;
  designation_gte?: Maybe<String>;
  designation_contains?: Maybe<String>;
  designation_not_contains?: Maybe<String>;
  designation_starts_with?: Maybe<String>;
  designation_not_starts_with?: Maybe<String>;
  designation_ends_with?: Maybe<String>;
  designation_not_ends_with?: Maybe<String>;
  doctorCv?: Maybe<String>;
  doctorCv_not?: Maybe<String>;
  doctorCv_in?: Maybe<String[] | String>;
  doctorCv_not_in?: Maybe<String[] | String>;
  doctorCv_lt?: Maybe<String>;
  doctorCv_lte?: Maybe<String>;
  doctorCv_gt?: Maybe<String>;
  doctorCv_gte?: Maybe<String>;
  doctorCv_contains?: Maybe<String>;
  doctorCv_not_contains?: Maybe<String>;
  doctorCv_starts_with?: Maybe<String>;
  doctorCv_not_starts_with?: Maybe<String>;
  doctorCv_ends_with?: Maybe<String>;
  doctorCv_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  gender?: Maybe<String>;
  gender_not?: Maybe<String>;
  gender_in?: Maybe<String[] | String>;
  gender_not_in?: Maybe<String[] | String>;
  gender_lt?: Maybe<String>;
  gender_lte?: Maybe<String>;
  gender_gt?: Maybe<String>;
  gender_gte?: Maybe<String>;
  gender_contains?: Maybe<String>;
  gender_not_contains?: Maybe<String>;
  gender_starts_with?: Maybe<String>;
  gender_not_starts_with?: Maybe<String>;
  gender_ends_with?: Maybe<String>;
  gender_not_ends_with?: Maybe<String>;
  mohcard?: Maybe<String>;
  mohcard_not?: Maybe<String>;
  mohcard_in?: Maybe<String[] | String>;
  mohcard_not_in?: Maybe<String[] | String>;
  mohcard_lt?: Maybe<String>;
  mohcard_lte?: Maybe<String>;
  mohcard_gt?: Maybe<String>;
  mohcard_gte?: Maybe<String>;
  mohcard_contains?: Maybe<String>;
  mohcard_not_contains?: Maybe<String>;
  mohcard_starts_with?: Maybe<String>;
  mohcard_not_starts_with?: Maybe<String>;
  mohcard_ends_with?: Maybe<String>;
  mohcard_not_ends_with?: Maybe<String>;
  mohId?: Maybe<String>;
  mohId_not?: Maybe<String>;
  mohId_in?: Maybe<String[] | String>;
  mohId_not_in?: Maybe<String[] | String>;
  mohId_lt?: Maybe<String>;
  mohId_lte?: Maybe<String>;
  mohId_gt?: Maybe<String>;
  mohId_gte?: Maybe<String>;
  mohId_contains?: Maybe<String>;
  mohId_not_contains?: Maybe<String>;
  mohId_starts_with?: Maybe<String>;
  mohId_not_starts_with?: Maybe<String>;
  mohId_ends_with?: Maybe<String>;
  mohId_not_ends_with?: Maybe<String>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  nameArabic?: Maybe<String>;
  nameArabic_not?: Maybe<String>;
  nameArabic_in?: Maybe<String[] | String>;
  nameArabic_not_in?: Maybe<String[] | String>;
  nameArabic_lt?: Maybe<String>;
  nameArabic_lte?: Maybe<String>;
  nameArabic_gt?: Maybe<String>;
  nameArabic_gte?: Maybe<String>;
  nameArabic_contains?: Maybe<String>;
  nameArabic_not_contains?: Maybe<String>;
  nameArabic_starts_with?: Maybe<String>;
  nameArabic_not_starts_with?: Maybe<String>;
  nameArabic_ends_with?: Maybe<String>;
  nameArabic_not_ends_with?: Maybe<String>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  phone?: Maybe<String>;
  phone_not?: Maybe<String>;
  phone_in?: Maybe<String[] | String>;
  phone_not_in?: Maybe<String[] | String>;
  phone_lt?: Maybe<String>;
  phone_lte?: Maybe<String>;
  phone_gt?: Maybe<String>;
  phone_gte?: Maybe<String>;
  phone_contains?: Maybe<String>;
  phone_not_contains?: Maybe<String>;
  phone_starts_with?: Maybe<String>;
  phone_not_starts_with?: Maybe<String>;
  phone_ends_with?: Maybe<String>;
  phone_not_ends_with?: Maybe<String>;
  fees?: Maybe<String>;
  fees_not?: Maybe<String>;
  fees_in?: Maybe<String[] | String>;
  fees_not_in?: Maybe<String[] | String>;
  fees_lt?: Maybe<String>;
  fees_lte?: Maybe<String>;
  fees_gt?: Maybe<String>;
  fees_gte?: Maybe<String>;
  fees_contains?: Maybe<String>;
  fees_not_contains?: Maybe<String>;
  fees_starts_with?: Maybe<String>;
  fees_not_starts_with?: Maybe<String>;
  fees_ends_with?: Maybe<String>;
  fees_not_ends_with?: Maybe<String>;
  picture?: Maybe<String>;
  picture_not?: Maybe<String>;
  picture_in?: Maybe<String[] | String>;
  picture_not_in?: Maybe<String[] | String>;
  picture_lt?: Maybe<String>;
  picture_lte?: Maybe<String>;
  picture_gt?: Maybe<String>;
  picture_gte?: Maybe<String>;
  picture_contains?: Maybe<String>;
  picture_not_contains?: Maybe<String>;
  picture_starts_with?: Maybe<String>;
  picture_not_starts_with?: Maybe<String>;
  picture_ends_with?: Maybe<String>;
  picture_not_ends_with?: Maybe<String>;
  specialityId?: Maybe<Int>;
  specialityId_not?: Maybe<Int>;
  specialityId_in?: Maybe<Int[] | Int>;
  specialityId_not_in?: Maybe<Int[] | Int>;
  specialityId_lt?: Maybe<Int>;
  specialityId_lte?: Maybe<Int>;
  specialityId_gt?: Maybe<Int>;
  specialityId_gte?: Maybe<Int>;
  status?: Maybe<Int>;
  status_not?: Maybe<Int>;
  status_in?: Maybe<Int[] | Int>;
  status_not_in?: Maybe<Int[] | Int>;
  status_lt?: Maybe<Int>;
  status_lte?: Maybe<Int>;
  status_gt?: Maybe<Int>;
  status_gte?: Maybe<Int>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  createdDate?: Maybe<DateTimeInput>;
  createdDate_not?: Maybe<DateTimeInput>;
  createdDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdDate_lt?: Maybe<DateTimeInput>;
  createdDate_lte?: Maybe<DateTimeInput>;
  createdDate_gt?: Maybe<DateTimeInput>;
  createdDate_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<DoctorScalarWhereInput[] | DoctorScalarWhereInput>;
  OR?: Maybe<DoctorScalarWhereInput[] | DoctorScalarWhereInput>;
  NOT?: Maybe<DoctorScalarWhereInput[] | DoctorScalarWhereInput>;
}

export interface DoctorUpdateManyWithWhereNestedInput {
  where: DoctorScalarWhereInput;
  data: DoctorUpdateManyDataInput;
}

export interface DoctorUpdateManyDataInput {
  apiKey?: Maybe<String>;
  designation?: Maybe<String>;
  doctorCv?: Maybe<String>;
  email?: Maybe<String>;
  gender?: Maybe<String>;
  mohcard?: Maybe<String>;
  mohId?: Maybe<String>;
  name?: Maybe<String>;
  nameArabic?: Maybe<String>;
  password?: Maybe<String>;
  phone?: Maybe<String>;
  fees?: Maybe<String>;
  picture?: Maybe<String>;
  specialityId?: Maybe<Int>;
  status?: Maybe<Int>;
}

export interface HospitalUpsertNestedInput {
  update: HospitalUpdateDataInput;
  create: HospitalCreateInput;
}

export interface OptTimeUpdateOneInput {
  create?: Maybe<OptTimeCreateInput>;
  update?: Maybe<OptTimeUpdateDataInput>;
  upsert?: Maybe<OptTimeUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<OptTimeWhereUniqueInput>;
}

export interface OptTimeUpdateDataInput {
  fifteenMins?: Maybe<String>;
  thirtyMins?: Maybe<String>;
  twentyMins?: Maybe<String>;
}

export interface OptTimeUpsertNestedInput {
  update: OptTimeUpdateDataInput;
  create: OptTimeCreateInput;
}

export interface PatientUpdateOneInput {
  create?: Maybe<PatientCreateInput>;
  update?: Maybe<PatientUpdateDataInput>;
  upsert?: Maybe<PatientUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<PatientWhereUniqueInput>;
}

export interface PatientUpdateDataInput {
  age?: Maybe<Int>;
  apiKey?: Maybe<String>;
  dob?: Maybe<String>;
  email?: Maybe<String>;
  gender?: Maybe<String>;
  lastAction?: Maybe<String>;
  mailSubs?: Maybe<Int>;
  mobile?: Maybe<String>;
  name?: Maybe<String>;
  password?: Maybe<String>;
  status?: Maybe<Int>;
  uniqeId?: Maybe<String>;
}

export interface PatientUpsertNestedInput {
  update: PatientUpdateDataInput;
  create: PatientCreateInput;
}

export interface SheduleTimeUpdateOneInput {
  create?: Maybe<SheduleTimeCreateInput>;
  update?: Maybe<SheduleTimeUpdateDataInput>;
  upsert?: Maybe<SheduleTimeUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<SheduleTimeWhereUniqueInput>;
}

export interface SheduleTimeUpdateDataInput {
  drSheduleId?: Maybe<Int>;
  scheduleFullDate?: Maybe<Int>;
  sheduleTime?: Maybe<String>;
  status?: Maybe<Int>;
}

export interface SheduleTimeUpsertNestedInput {
  update: SheduleTimeUpdateDataInput;
  create: SheduleTimeCreateInput;
}

export interface AppointmentUpdateManyMutationInput {
  apointmentDate?: Maybe<String>;
  apointmentFulldate?: Maybe<Int>;
  apointmentTime?: Maybe<String>;
  doctorArabic?: Maybe<String>;
  doctorName?: Maybe<String>;
  gender?: Maybe<String>;
  isRead?: Maybe<Int>;
  phone?: Maybe<String>;
  phoneCode?: Maybe<String>;
  status?: Maybe<Int>;
}

export interface BlogCreateInput {
  id?: Maybe<Int>;
  bannerImage: String;
  hospitalId?: Maybe<HospitalCreateOneInput>;
  name: String;
  status?: Maybe<Int>;
}

export interface BlogUpdateInput {
  bannerImage?: Maybe<String>;
  hospitalId?: Maybe<HospitalUpdateOneInput>;
  name?: Maybe<String>;
  status?: Maybe<Int>;
}

export interface BlogUpdateManyMutationInput {
  bannerImage?: Maybe<String>;
  name?: Maybe<String>;
  status?: Maybe<Int>;
}

export interface BlogCommentCreateInput {
  id?: Maybe<Int>;
  commentator: Int;
  commentatorName: String;
  comments: String;
  postId?: Maybe<BlogPostCreateOneInput>;
}

export interface BlogPostCreateOneInput {
  create?: Maybe<BlogPostCreateInput>;
  connect?: Maybe<BlogPostWhereUniqueInput>;
}

export interface BlogPostCreateInput {
  id?: Maybe<Int>;
  blogId?: Maybe<BlogCreateOneInput>;
  hospitalId?: Maybe<HospitalCreateOneInput>;
  postContent: String;
  postTitle: String;
  status?: Maybe<Int>;
  totalViewers?: Maybe<Int>;
  images?: Maybe<PostImageCreateManyWithoutPostIdInput>;
}

export interface BlogCreateOneInput {
  create?: Maybe<BlogCreateInput>;
  connect?: Maybe<BlogWhereUniqueInput>;
}

export interface PostImageCreateManyWithoutPostIdInput {
  create?: Maybe<
    PostImageCreateWithoutPostIdInput[] | PostImageCreateWithoutPostIdInput
  >;
  connect?: Maybe<PostImageWhereUniqueInput[] | PostImageWhereUniqueInput>;
}

export interface PostImageCreateWithoutPostIdInput {
  id?: Maybe<Int>;
  isDefault?: Maybe<Int>;
  pic: String;
}

export interface BlogCommentUpdateInput {
  commentator?: Maybe<Int>;
  commentatorName?: Maybe<String>;
  comments?: Maybe<String>;
  postId?: Maybe<BlogPostUpdateOneInput>;
}

export interface BlogPostUpdateOneInput {
  create?: Maybe<BlogPostCreateInput>;
  update?: Maybe<BlogPostUpdateDataInput>;
  upsert?: Maybe<BlogPostUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<BlogPostWhereUniqueInput>;
}

export interface BlogPostUpdateDataInput {
  blogId?: Maybe<BlogUpdateOneInput>;
  hospitalId?: Maybe<HospitalUpdateOneInput>;
  postContent?: Maybe<String>;
  postTitle?: Maybe<String>;
  status?: Maybe<Int>;
  totalViewers?: Maybe<Int>;
  images?: Maybe<PostImageUpdateManyWithoutPostIdInput>;
}

export interface BlogUpdateOneInput {
  create?: Maybe<BlogCreateInput>;
  update?: Maybe<BlogUpdateDataInput>;
  upsert?: Maybe<BlogUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<BlogWhereUniqueInput>;
}

export interface BlogUpdateDataInput {
  bannerImage?: Maybe<String>;
  hospitalId?: Maybe<HospitalUpdateOneInput>;
  name?: Maybe<String>;
  status?: Maybe<Int>;
}

export interface BlogUpsertNestedInput {
  update: BlogUpdateDataInput;
  create: BlogCreateInput;
}

export interface PostImageUpdateManyWithoutPostIdInput {
  create?: Maybe<
    PostImageCreateWithoutPostIdInput[] | PostImageCreateWithoutPostIdInput
  >;
  delete?: Maybe<PostImageWhereUniqueInput[] | PostImageWhereUniqueInput>;
  connect?: Maybe<PostImageWhereUniqueInput[] | PostImageWhereUniqueInput>;
  set?: Maybe<PostImageWhereUniqueInput[] | PostImageWhereUniqueInput>;
  disconnect?: Maybe<PostImageWhereUniqueInput[] | PostImageWhereUniqueInput>;
  update?: Maybe<
    | PostImageUpdateWithWhereUniqueWithoutPostIdInput[]
    | PostImageUpdateWithWhereUniqueWithoutPostIdInput
  >;
  upsert?: Maybe<
    | PostImageUpsertWithWhereUniqueWithoutPostIdInput[]
    | PostImageUpsertWithWhereUniqueWithoutPostIdInput
  >;
  deleteMany?: Maybe<PostImageScalarWhereInput[] | PostImageScalarWhereInput>;
  updateMany?: Maybe<
    | PostImageUpdateManyWithWhereNestedInput[]
    | PostImageUpdateManyWithWhereNestedInput
  >;
}

export interface PostImageUpdateWithWhereUniqueWithoutPostIdInput {
  where: PostImageWhereUniqueInput;
  data: PostImageUpdateWithoutPostIdDataInput;
}

export interface PostImageUpdateWithoutPostIdDataInput {
  isDefault?: Maybe<Int>;
  pic?: Maybe<String>;
}

export interface PostImageUpsertWithWhereUniqueWithoutPostIdInput {
  where: PostImageWhereUniqueInput;
  update: PostImageUpdateWithoutPostIdDataInput;
  create: PostImageCreateWithoutPostIdInput;
}

export interface PostImageScalarWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  isDefault?: Maybe<Int>;
  isDefault_not?: Maybe<Int>;
  isDefault_in?: Maybe<Int[] | Int>;
  isDefault_not_in?: Maybe<Int[] | Int>;
  isDefault_lt?: Maybe<Int>;
  isDefault_lte?: Maybe<Int>;
  isDefault_gt?: Maybe<Int>;
  isDefault_gte?: Maybe<Int>;
  pic?: Maybe<String>;
  pic_not?: Maybe<String>;
  pic_in?: Maybe<String[] | String>;
  pic_not_in?: Maybe<String[] | String>;
  pic_lt?: Maybe<String>;
  pic_lte?: Maybe<String>;
  pic_gt?: Maybe<String>;
  pic_gte?: Maybe<String>;
  pic_contains?: Maybe<String>;
  pic_not_contains?: Maybe<String>;
  pic_starts_with?: Maybe<String>;
  pic_not_starts_with?: Maybe<String>;
  pic_ends_with?: Maybe<String>;
  pic_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<PostImageScalarWhereInput[] | PostImageScalarWhereInput>;
  OR?: Maybe<PostImageScalarWhereInput[] | PostImageScalarWhereInput>;
  NOT?: Maybe<PostImageScalarWhereInput[] | PostImageScalarWhereInput>;
}

export interface PostImageUpdateManyWithWhereNestedInput {
  where: PostImageScalarWhereInput;
  data: PostImageUpdateManyDataInput;
}

export interface PostImageUpdateManyDataInput {
  isDefault?: Maybe<Int>;
  pic?: Maybe<String>;
}

export interface BlogPostUpsertNestedInput {
  update: BlogPostUpdateDataInput;
  create: BlogPostCreateInput;
}

export interface BlogCommentUpdateManyMutationInput {
  commentator?: Maybe<Int>;
  commentatorName?: Maybe<String>;
  comments?: Maybe<String>;
}

export interface BlogPostUpdateInput {
  blogId?: Maybe<BlogUpdateOneInput>;
  hospitalId?: Maybe<HospitalUpdateOneInput>;
  postContent?: Maybe<String>;
  postTitle?: Maybe<String>;
  status?: Maybe<Int>;
  totalViewers?: Maybe<Int>;
  images?: Maybe<PostImageUpdateManyWithoutPostIdInput>;
}

export interface BlogPostUpdateManyMutationInput {
  postContent?: Maybe<String>;
  postTitle?: Maybe<String>;
  status?: Maybe<Int>;
  totalViewers?: Maybe<Int>;
}

export interface CityCreateInput {
  id?: Maybe<Int>;
  city?: Maybe<String>;
  cityArabic: String;
  countryId?: Maybe<Int>;
  hospital?: Maybe<HospitalCreateManyWithoutCityInput>;
}

export interface HospitalCreateManyWithoutCityInput {
  create?: Maybe<
    HospitalCreateWithoutCityInput[] | HospitalCreateWithoutCityInput
  >;
  connect?: Maybe<HospitalWhereUniqueInput[] | HospitalWhereUniqueInput>;
}

export interface HospitalCreateWithoutCityInput {
  id?: Maybe<Int>;
  address: String;
  addressArabic: String;
  apiKey: String;
  countryId?: Maybe<CountryCreateOneInput>;
  email?: Maybe<String>;
  hospital?: Maybe<String>;
  hospitalArabic: String;
  doctors?: Maybe<DoctorCreateManyWithoutHospitalInput>;
  language: String;
  latitude: String;
  location: String;
  logo?: Maybe<String>;
  longitude: String;
  password?: Maybe<String>;
  phone?: Maybe<String>;
  phone1: String;
  status?: Maybe<Int>;
  type?: Maybe<String>;
  uniqeId: String;
  insurances?: Maybe<InsuranceCreateManyWithoutHospitalsInput>;
  createdDate: DateTimeInput;
}

export interface CityUpdateInput {
  city?: Maybe<String>;
  cityArabic?: Maybe<String>;
  countryId?: Maybe<Int>;
  hospital?: Maybe<HospitalUpdateManyWithoutCityInput>;
}

export interface HospitalUpdateManyWithoutCityInput {
  create?: Maybe<
    HospitalCreateWithoutCityInput[] | HospitalCreateWithoutCityInput
  >;
  delete?: Maybe<HospitalWhereUniqueInput[] | HospitalWhereUniqueInput>;
  connect?: Maybe<HospitalWhereUniqueInput[] | HospitalWhereUniqueInput>;
  set?: Maybe<HospitalWhereUniqueInput[] | HospitalWhereUniqueInput>;
  disconnect?: Maybe<HospitalWhereUniqueInput[] | HospitalWhereUniqueInput>;
  update?: Maybe<
    | HospitalUpdateWithWhereUniqueWithoutCityInput[]
    | HospitalUpdateWithWhereUniqueWithoutCityInput
  >;
  upsert?: Maybe<
    | HospitalUpsertWithWhereUniqueWithoutCityInput[]
    | HospitalUpsertWithWhereUniqueWithoutCityInput
  >;
  deleteMany?: Maybe<HospitalScalarWhereInput[] | HospitalScalarWhereInput>;
  updateMany?: Maybe<
    | HospitalUpdateManyWithWhereNestedInput[]
    | HospitalUpdateManyWithWhereNestedInput
  >;
}

export interface HospitalUpdateWithWhereUniqueWithoutCityInput {
  where: HospitalWhereUniqueInput;
  data: HospitalUpdateWithoutCityDataInput;
}

export interface HospitalUpdateWithoutCityDataInput {
  address?: Maybe<String>;
  addressArabic?: Maybe<String>;
  apiKey?: Maybe<String>;
  countryId?: Maybe<CountryUpdateOneInput>;
  email?: Maybe<String>;
  hospital?: Maybe<String>;
  hospitalArabic?: Maybe<String>;
  doctors?: Maybe<DoctorUpdateManyWithoutHospitalInput>;
  language?: Maybe<String>;
  latitude?: Maybe<String>;
  location?: Maybe<String>;
  logo?: Maybe<String>;
  longitude?: Maybe<String>;
  password?: Maybe<String>;
  phone?: Maybe<String>;
  phone1?: Maybe<String>;
  status?: Maybe<Int>;
  type?: Maybe<String>;
  uniqeId?: Maybe<String>;
  insurances?: Maybe<InsuranceUpdateManyWithoutHospitalsInput>;
  createdDate?: Maybe<DateTimeInput>;
}

export interface HospitalUpsertWithWhereUniqueWithoutCityInput {
  where: HospitalWhereUniqueInput;
  update: HospitalUpdateWithoutCityDataInput;
  create: HospitalCreateWithoutCityInput;
}

export interface CityUpdateManyMutationInput {
  city?: Maybe<String>;
  cityArabic?: Maybe<String>;
  countryId?: Maybe<Int>;
}

export interface ContactUsCreateInput {
  id?: Maybe<Int>;
  address: String;
  email: String;
  lat: String;
  lon: String;
  phone: String;
  pobox: String;
}

export interface ContactUsUpdateInput {
  address?: Maybe<String>;
  email?: Maybe<String>;
  lat?: Maybe<String>;
  lon?: Maybe<String>;
  phone?: Maybe<String>;
  pobox?: Maybe<String>;
}

export interface ContactUsUpdateManyMutationInput {
  address?: Maybe<String>;
  email?: Maybe<String>;
  lat?: Maybe<String>;
  lon?: Maybe<String>;
  phone?: Maybe<String>;
  pobox?: Maybe<String>;
}

export interface CountryUpdateInput {
  country?: Maybe<String>;
  countryArabic?: Maybe<String>;
}

export interface CountryUpdateManyMutationInput {
  country?: Maybe<String>;
  countryArabic?: Maybe<String>;
}

export interface DiseaseUpdateInput {
  disease?: Maybe<String>;
  diseaseArabic?: Maybe<String>;
}

export interface DiseaseUpdateManyMutationInput {
  disease?: Maybe<String>;
  diseaseArabic?: Maybe<String>;
}

export interface DiseaseCoveredCreateInput {
  id?: Maybe<Int>;
  diseaseId?: Maybe<Int>;
  insuranceCatId?: Maybe<Int>;
}

export interface DiseaseCoveredUpdateInput {
  diseaseId?: Maybe<Int>;
  insuranceCatId?: Maybe<Int>;
}

export interface DiseaseCoveredUpdateManyMutationInput {
  diseaseId?: Maybe<Int>;
  insuranceCatId?: Maybe<Int>;
}

export interface DoctorUpdateInput {
  apiKey?: Maybe<String>;
  designation?: Maybe<String>;
  doctorCv?: Maybe<String>;
  email?: Maybe<String>;
  gender?: Maybe<String>;
  mohcard?: Maybe<String>;
  mohId?: Maybe<String>;
  name?: Maybe<String>;
  nameArabic?: Maybe<String>;
  password?: Maybe<String>;
  phone?: Maybe<String>;
  fees?: Maybe<String>;
  picture?: Maybe<String>;
  specialityId?: Maybe<Int>;
  specialities?: Maybe<SpecialityUpdateOneWithoutDoctorsInput>;
  hospital?: Maybe<HospitalUpdateManyWithoutDoctorsInput>;
  status?: Maybe<Int>;
}

export interface DoctorUpdateManyMutationInput {
  apiKey?: Maybe<String>;
  designation?: Maybe<String>;
  doctorCv?: Maybe<String>;
  email?: Maybe<String>;
  gender?: Maybe<String>;
  mohcard?: Maybe<String>;
  mohId?: Maybe<String>;
  name?: Maybe<String>;
  nameArabic?: Maybe<String>;
  password?: Maybe<String>;
  phone?: Maybe<String>;
  fees?: Maybe<String>;
  picture?: Maybe<String>;
  specialityId?: Maybe<Int>;
  status?: Maybe<Int>;
}

export interface DoctorOldCreateInput {
  id?: Maybe<Int>;
  apiKey: String;
  designation: String;
  doctorCv: String;
  doctorsRating?: Maybe<DoctorsRatingCreateManyWithoutDoctorsInput>;
  email?: Maybe<String>;
  gender: String;
  mohcard?: Maybe<String>;
  mohId: String;
  name?: Maybe<String>;
  nameArabic: String;
  password?: Maybe<String>;
  phone?: Maybe<String>;
  fees?: Maybe<String>;
  picture?: Maybe<String>;
  speciality?: Maybe<SpecialityCreateOneInput>;
  status?: Maybe<Int>;
}

export interface DoctorsRatingCreateManyWithoutDoctorsInput {
  create?: Maybe<
    | DoctorsRatingCreateWithoutDoctorsInput[]
    | DoctorsRatingCreateWithoutDoctorsInput
  >;
  connect?: Maybe<
    DoctorsRatingWhereUniqueInput[] | DoctorsRatingWhereUniqueInput
  >;
}

export interface DoctorsRatingCreateWithoutDoctorsInput {
  id?: Maybe<Int>;
  rating?: Maybe<String>;
  systemIp: String;
}

export interface SpecialityCreateOneInput {
  create?: Maybe<SpecialityCreateInput>;
  connect?: Maybe<SpecialityWhereUniqueInput>;
}

export interface SpecialityCreateInput {
  id?: Maybe<Int>;
  doctors?: Maybe<DoctorCreateManyWithoutSpecialitiesInput>;
  speciality?: Maybe<String>;
  specialityArabic?: Maybe<String>;
}

export interface DoctorCreateManyWithoutSpecialitiesInput {
  create?: Maybe<
    | DoctorCreateWithoutSpecialitiesInput[]
    | DoctorCreateWithoutSpecialitiesInput
  >;
  connect?: Maybe<DoctorWhereUniqueInput[] | DoctorWhereUniqueInput>;
}

export interface DoctorCreateWithoutSpecialitiesInput {
  id?: Maybe<Int>;
  apiKey: String;
  designation?: Maybe<String>;
  doctorCv: String;
  email?: Maybe<String>;
  gender?: Maybe<String>;
  mohcard?: Maybe<String>;
  mohId: String;
  name?: Maybe<String>;
  nameArabic?: Maybe<String>;
  password?: Maybe<String>;
  phone?: Maybe<String>;
  fees?: Maybe<String>;
  picture?: Maybe<String>;
  specialityId?: Maybe<Int>;
  hospital?: Maybe<HospitalCreateManyWithoutDoctorsInput>;
  status?: Maybe<Int>;
}

export interface DoctorOldUpdateInput {
  apiKey?: Maybe<String>;
  designation?: Maybe<String>;
  doctorCv?: Maybe<String>;
  doctorsRating?: Maybe<DoctorsRatingUpdateManyWithoutDoctorsInput>;
  email?: Maybe<String>;
  gender?: Maybe<String>;
  mohcard?: Maybe<String>;
  mohId?: Maybe<String>;
  name?: Maybe<String>;
  nameArabic?: Maybe<String>;
  password?: Maybe<String>;
  phone?: Maybe<String>;
  fees?: Maybe<String>;
  picture?: Maybe<String>;
  speciality?: Maybe<SpecialityUpdateOneInput>;
  status?: Maybe<Int>;
}

export interface DoctorsRatingUpdateManyWithoutDoctorsInput {
  create?: Maybe<
    | DoctorsRatingCreateWithoutDoctorsInput[]
    | DoctorsRatingCreateWithoutDoctorsInput
  >;
  delete?: Maybe<
    DoctorsRatingWhereUniqueInput[] | DoctorsRatingWhereUniqueInput
  >;
  connect?: Maybe<
    DoctorsRatingWhereUniqueInput[] | DoctorsRatingWhereUniqueInput
  >;
  set?: Maybe<DoctorsRatingWhereUniqueInput[] | DoctorsRatingWhereUniqueInput>;
  disconnect?: Maybe<
    DoctorsRatingWhereUniqueInput[] | DoctorsRatingWhereUniqueInput
  >;
  update?: Maybe<
    | DoctorsRatingUpdateWithWhereUniqueWithoutDoctorsInput[]
    | DoctorsRatingUpdateWithWhereUniqueWithoutDoctorsInput
  >;
  upsert?: Maybe<
    | DoctorsRatingUpsertWithWhereUniqueWithoutDoctorsInput[]
    | DoctorsRatingUpsertWithWhereUniqueWithoutDoctorsInput
  >;
  deleteMany?: Maybe<
    DoctorsRatingScalarWhereInput[] | DoctorsRatingScalarWhereInput
  >;
  updateMany?: Maybe<
    | DoctorsRatingUpdateManyWithWhereNestedInput[]
    | DoctorsRatingUpdateManyWithWhereNestedInput
  >;
}

export interface DoctorsRatingUpdateWithWhereUniqueWithoutDoctorsInput {
  where: DoctorsRatingWhereUniqueInput;
  data: DoctorsRatingUpdateWithoutDoctorsDataInput;
}

export interface DoctorsRatingUpdateWithoutDoctorsDataInput {
  rating?: Maybe<String>;
  systemIp?: Maybe<String>;
}

export interface DoctorsRatingUpsertWithWhereUniqueWithoutDoctorsInput {
  where: DoctorsRatingWhereUniqueInput;
  update: DoctorsRatingUpdateWithoutDoctorsDataInput;
  create: DoctorsRatingCreateWithoutDoctorsInput;
}

export interface DoctorsRatingScalarWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  rating?: Maybe<String>;
  rating_not?: Maybe<String>;
  rating_in?: Maybe<String[] | String>;
  rating_not_in?: Maybe<String[] | String>;
  rating_lt?: Maybe<String>;
  rating_lte?: Maybe<String>;
  rating_gt?: Maybe<String>;
  rating_gte?: Maybe<String>;
  rating_contains?: Maybe<String>;
  rating_not_contains?: Maybe<String>;
  rating_starts_with?: Maybe<String>;
  rating_not_starts_with?: Maybe<String>;
  rating_ends_with?: Maybe<String>;
  rating_not_ends_with?: Maybe<String>;
  systemIp?: Maybe<String>;
  systemIp_not?: Maybe<String>;
  systemIp_in?: Maybe<String[] | String>;
  systemIp_not_in?: Maybe<String[] | String>;
  systemIp_lt?: Maybe<String>;
  systemIp_lte?: Maybe<String>;
  systemIp_gt?: Maybe<String>;
  systemIp_gte?: Maybe<String>;
  systemIp_contains?: Maybe<String>;
  systemIp_not_contains?: Maybe<String>;
  systemIp_starts_with?: Maybe<String>;
  systemIp_not_starts_with?: Maybe<String>;
  systemIp_ends_with?: Maybe<String>;
  systemIp_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<DoctorsRatingScalarWhereInput[] | DoctorsRatingScalarWhereInput>;
  OR?: Maybe<DoctorsRatingScalarWhereInput[] | DoctorsRatingScalarWhereInput>;
  NOT?: Maybe<DoctorsRatingScalarWhereInput[] | DoctorsRatingScalarWhereInput>;
}

export interface DoctorsRatingUpdateManyWithWhereNestedInput {
  where: DoctorsRatingScalarWhereInput;
  data: DoctorsRatingUpdateManyDataInput;
}

export interface DoctorsRatingUpdateManyDataInput {
  rating?: Maybe<String>;
  systemIp?: Maybe<String>;
}

export interface SpecialityUpdateOneInput {
  create?: Maybe<SpecialityCreateInput>;
  update?: Maybe<SpecialityUpdateDataInput>;
  upsert?: Maybe<SpecialityUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<SpecialityWhereUniqueInput>;
}

export interface SpecialityUpdateDataInput {
  doctors?: Maybe<DoctorUpdateManyWithoutSpecialitiesInput>;
  speciality?: Maybe<String>;
  specialityArabic?: Maybe<String>;
}

export interface DoctorUpdateManyWithoutSpecialitiesInput {
  create?: Maybe<
    | DoctorCreateWithoutSpecialitiesInput[]
    | DoctorCreateWithoutSpecialitiesInput
  >;
  delete?: Maybe<DoctorWhereUniqueInput[] | DoctorWhereUniqueInput>;
  connect?: Maybe<DoctorWhereUniqueInput[] | DoctorWhereUniqueInput>;
  set?: Maybe<DoctorWhereUniqueInput[] | DoctorWhereUniqueInput>;
  disconnect?: Maybe<DoctorWhereUniqueInput[] | DoctorWhereUniqueInput>;
  update?: Maybe<
    | DoctorUpdateWithWhereUniqueWithoutSpecialitiesInput[]
    | DoctorUpdateWithWhereUniqueWithoutSpecialitiesInput
  >;
  upsert?: Maybe<
    | DoctorUpsertWithWhereUniqueWithoutSpecialitiesInput[]
    | DoctorUpsertWithWhereUniqueWithoutSpecialitiesInput
  >;
  deleteMany?: Maybe<DoctorScalarWhereInput[] | DoctorScalarWhereInput>;
  updateMany?: Maybe<
    | DoctorUpdateManyWithWhereNestedInput[]
    | DoctorUpdateManyWithWhereNestedInput
  >;
}

export interface DoctorUpdateWithWhereUniqueWithoutSpecialitiesInput {
  where: DoctorWhereUniqueInput;
  data: DoctorUpdateWithoutSpecialitiesDataInput;
}

export interface DoctorUpdateWithoutSpecialitiesDataInput {
  apiKey?: Maybe<String>;
  designation?: Maybe<String>;
  doctorCv?: Maybe<String>;
  email?: Maybe<String>;
  gender?: Maybe<String>;
  mohcard?: Maybe<String>;
  mohId?: Maybe<String>;
  name?: Maybe<String>;
  nameArabic?: Maybe<String>;
  password?: Maybe<String>;
  phone?: Maybe<String>;
  fees?: Maybe<String>;
  picture?: Maybe<String>;
  specialityId?: Maybe<Int>;
  hospital?: Maybe<HospitalUpdateManyWithoutDoctorsInput>;
  status?: Maybe<Int>;
}

export interface DoctorUpsertWithWhereUniqueWithoutSpecialitiesInput {
  where: DoctorWhereUniqueInput;
  update: DoctorUpdateWithoutSpecialitiesDataInput;
  create: DoctorCreateWithoutSpecialitiesInput;
}

export interface SpecialityUpsertNestedInput {
  update: SpecialityUpdateDataInput;
  create: SpecialityCreateInput;
}

export interface DoctorOldUpdateManyMutationInput {
  apiKey?: Maybe<String>;
  designation?: Maybe<String>;
  doctorCv?: Maybe<String>;
  email?: Maybe<String>;
  gender?: Maybe<String>;
  mohcard?: Maybe<String>;
  mohId?: Maybe<String>;
  name?: Maybe<String>;
  nameArabic?: Maybe<String>;
  password?: Maybe<String>;
  phone?: Maybe<String>;
  fees?: Maybe<String>;
  picture?: Maybe<String>;
  status?: Maybe<Int>;
}

export interface DoctorSheduleCreateInput {
  id?: Maybe<Int>;
  date?: Maybe<Int>;
  doctorId?: Maybe<Int>;
}

export interface DoctorSheduleUpdateInput {
  date?: Maybe<Int>;
  doctorId?: Maybe<Int>;
}

export interface DoctorSheduleUpdateManyMutationInput {
  date?: Maybe<Int>;
  doctorId?: Maybe<Int>;
}

export interface DoctorSheduleTimeUpdateInput {
  drSheduleId?: Maybe<Int>;
  scheduleTime?: Maybe<Int>;
  status?: Maybe<Int>;
}

export interface DoctorSheduleTimeUpdateManyMutationInput {
  drSheduleId?: Maybe<Int>;
  scheduleTime?: Maybe<Int>;
  status?: Maybe<Int>;
}

export interface DoctorsRatingCreateInput {
  id?: Maybe<Int>;
  doctors?: Maybe<DoctorOldCreateOneWithoutDoctorsRatingInput>;
  rating?: Maybe<String>;
  systemIp: String;
}

export interface DoctorOldCreateOneWithoutDoctorsRatingInput {
  create?: Maybe<DoctorOldCreateWithoutDoctorsRatingInput>;
  connect?: Maybe<DoctorOldWhereUniqueInput>;
}

export interface DoctorOldCreateWithoutDoctorsRatingInput {
  id?: Maybe<Int>;
  apiKey: String;
  designation: String;
  doctorCv: String;
  email?: Maybe<String>;
  gender: String;
  mohcard?: Maybe<String>;
  mohId: String;
  name?: Maybe<String>;
  nameArabic: String;
  password?: Maybe<String>;
  phone?: Maybe<String>;
  fees?: Maybe<String>;
  picture?: Maybe<String>;
  speciality?: Maybe<SpecialityCreateOneInput>;
  status?: Maybe<Int>;
}

export interface DoctorsRatingUpdateInput {
  doctors?: Maybe<DoctorOldUpdateOneWithoutDoctorsRatingInput>;
  rating?: Maybe<String>;
  systemIp?: Maybe<String>;
}

export interface DoctorOldUpdateOneWithoutDoctorsRatingInput {
  create?: Maybe<DoctorOldCreateWithoutDoctorsRatingInput>;
  update?: Maybe<DoctorOldUpdateWithoutDoctorsRatingDataInput>;
  upsert?: Maybe<DoctorOldUpsertWithoutDoctorsRatingInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<DoctorOldWhereUniqueInput>;
}

export interface DoctorOldUpdateWithoutDoctorsRatingDataInput {
  apiKey?: Maybe<String>;
  designation?: Maybe<String>;
  doctorCv?: Maybe<String>;
  email?: Maybe<String>;
  gender?: Maybe<String>;
  mohcard?: Maybe<String>;
  mohId?: Maybe<String>;
  name?: Maybe<String>;
  nameArabic?: Maybe<String>;
  password?: Maybe<String>;
  phone?: Maybe<String>;
  fees?: Maybe<String>;
  picture?: Maybe<String>;
  speciality?: Maybe<SpecialityUpdateOneInput>;
  status?: Maybe<Int>;
}

export interface DoctorOldUpsertWithoutDoctorsRatingInput {
  update: DoctorOldUpdateWithoutDoctorsRatingDataInput;
  create: DoctorOldCreateWithoutDoctorsRatingInput;
}

export interface DoctorsRatingUpdateManyMutationInput {
  rating?: Maybe<String>;
  systemIp?: Maybe<String>;
}

export interface DrSheduleCreateInput {
  id?: Maybe<Int>;
  date?: Maybe<DateTimeInput>;
  doctorId?: Maybe<Int>;
  hospitalId?: Maybe<Int>;
}

export interface DrSheduleUpdateInput {
  date?: Maybe<DateTimeInput>;
  doctorId?: Maybe<Int>;
  hospitalId?: Maybe<Int>;
}

export interface DrSheduleUpdateManyMutationInput {
  date?: Maybe<DateTimeInput>;
  doctorId?: Maybe<Int>;
  hospitalId?: Maybe<Int>;
}

export interface EmailSubscriptionCreateInput {
  id?: Maybe<Int>;
  email: String;
}

export interface EmailSubscriptionUpdateInput {
  email?: Maybe<String>;
}

export interface EmailSubscriptionUpdateManyMutationInput {
  email?: Maybe<String>;
}

export interface FacilityCreateInput {
  id?: Maybe<Int>;
  facility?: Maybe<String>;
}

export interface FacilityUpdateInput {
  facility?: Maybe<String>;
}

export interface FacilityUpdateManyMutationInput {
  facility?: Maybe<String>;
}

export interface HospitalUpdateInput {
  address?: Maybe<String>;
  addressArabic?: Maybe<String>;
  apiKey?: Maybe<String>;
  city?: Maybe<CityUpdateOneWithoutHospitalInput>;
  countryId?: Maybe<CountryUpdateOneInput>;
  email?: Maybe<String>;
  hospital?: Maybe<String>;
  hospitalArabic?: Maybe<String>;
  doctors?: Maybe<DoctorUpdateManyWithoutHospitalInput>;
  language?: Maybe<String>;
  latitude?: Maybe<String>;
  location?: Maybe<String>;
  logo?: Maybe<String>;
  longitude?: Maybe<String>;
  password?: Maybe<String>;
  phone?: Maybe<String>;
  phone1?: Maybe<String>;
  status?: Maybe<Int>;
  type?: Maybe<String>;
  uniqeId?: Maybe<String>;
  insurances?: Maybe<InsuranceUpdateManyWithoutHospitalsInput>;
  createdDate?: Maybe<DateTimeInput>;
}

export interface HospitalUpdateManyMutationInput {
  address?: Maybe<String>;
  addressArabic?: Maybe<String>;
  apiKey?: Maybe<String>;
  email?: Maybe<String>;
  hospital?: Maybe<String>;
  hospitalArabic?: Maybe<String>;
  language?: Maybe<String>;
  latitude?: Maybe<String>;
  location?: Maybe<String>;
  logo?: Maybe<String>;
  longitude?: Maybe<String>;
  password?: Maybe<String>;
  phone?: Maybe<String>;
  phone1?: Maybe<String>;
  status?: Maybe<Int>;
  type?: Maybe<String>;
  uniqeId?: Maybe<String>;
  createdDate?: Maybe<DateTimeInput>;
}

export interface HospitalFacilityCreateInput {
  id?: Maybe<Int>;
  facilityId?: Maybe<Int>;
  hospitalId?: Maybe<Int>;
}

export interface HospitalFacilityUpdateInput {
  facilityId?: Maybe<Int>;
  hospitalId?: Maybe<Int>;
}

export interface HospitalFacilityUpdateManyMutationInput {
  facilityId?: Maybe<Int>;
  hospitalId?: Maybe<Int>;
}

export interface HospitalRatingCreateInput {
  id?: Maybe<Int>;
  hospitalId?: Maybe<Int>;
  rating?: Maybe<String>;
}

export interface HospitalRatingUpdateInput {
  hospitalId?: Maybe<Int>;
  rating?: Maybe<String>;
}

export interface HospitalRatingUpdateManyMutationInput {
  hospitalId?: Maybe<Int>;
  rating?: Maybe<String>;
}

export interface IllnessCreateInput {
  id?: Maybe<Int>;
  illness?: Maybe<String>;
  illnessArabic?: Maybe<String>;
}

export interface IllnessUpdateInput {
  illness?: Maybe<String>;
  illnessArabic?: Maybe<String>;
}

export interface IllnessUpdateManyMutationInput {
  illness?: Maybe<String>;
  illnessArabic?: Maybe<String>;
}

export interface InsuranceCreateInput {
  id?: Maybe<Int>;
  countryId: Int;
  hospitals?: Maybe<HospitalCreateManyWithoutInsurancesInput>;
  insurance?: Maybe<String>;
  insuranceArabic?: Maybe<String>;
}

export interface HospitalCreateManyWithoutInsurancesInput {
  create?: Maybe<
    | HospitalCreateWithoutInsurancesInput[]
    | HospitalCreateWithoutInsurancesInput
  >;
  connect?: Maybe<HospitalWhereUniqueInput[] | HospitalWhereUniqueInput>;
}

export interface HospitalCreateWithoutInsurancesInput {
  id?: Maybe<Int>;
  address: String;
  addressArabic: String;
  apiKey: String;
  city?: Maybe<CityCreateOneWithoutHospitalInput>;
  countryId?: Maybe<CountryCreateOneInput>;
  email?: Maybe<String>;
  hospital?: Maybe<String>;
  hospitalArabic: String;
  doctors?: Maybe<DoctorCreateManyWithoutHospitalInput>;
  language: String;
  latitude: String;
  location: String;
  logo?: Maybe<String>;
  longitude: String;
  password?: Maybe<String>;
  phone?: Maybe<String>;
  phone1: String;
  status?: Maybe<Int>;
  type?: Maybe<String>;
  uniqeId: String;
  createdDate: DateTimeInput;
}

export interface InsuranceUpdateInput {
  countryId?: Maybe<Int>;
  hospitals?: Maybe<HospitalUpdateManyWithoutInsurancesInput>;
  insurance?: Maybe<String>;
  insuranceArabic?: Maybe<String>;
}

export interface HospitalUpdateManyWithoutInsurancesInput {
  create?: Maybe<
    | HospitalCreateWithoutInsurancesInput[]
    | HospitalCreateWithoutInsurancesInput
  >;
  delete?: Maybe<HospitalWhereUniqueInput[] | HospitalWhereUniqueInput>;
  connect?: Maybe<HospitalWhereUniqueInput[] | HospitalWhereUniqueInput>;
  set?: Maybe<HospitalWhereUniqueInput[] | HospitalWhereUniqueInput>;
  disconnect?: Maybe<HospitalWhereUniqueInput[] | HospitalWhereUniqueInput>;
  update?: Maybe<
    | HospitalUpdateWithWhereUniqueWithoutInsurancesInput[]
    | HospitalUpdateWithWhereUniqueWithoutInsurancesInput
  >;
  upsert?: Maybe<
    | HospitalUpsertWithWhereUniqueWithoutInsurancesInput[]
    | HospitalUpsertWithWhereUniqueWithoutInsurancesInput
  >;
  deleteMany?: Maybe<HospitalScalarWhereInput[] | HospitalScalarWhereInput>;
  updateMany?: Maybe<
    | HospitalUpdateManyWithWhereNestedInput[]
    | HospitalUpdateManyWithWhereNestedInput
  >;
}

export interface HospitalUpdateWithWhereUniqueWithoutInsurancesInput {
  where: HospitalWhereUniqueInput;
  data: HospitalUpdateWithoutInsurancesDataInput;
}

export interface HospitalUpdateWithoutInsurancesDataInput {
  address?: Maybe<String>;
  addressArabic?: Maybe<String>;
  apiKey?: Maybe<String>;
  city?: Maybe<CityUpdateOneWithoutHospitalInput>;
  countryId?: Maybe<CountryUpdateOneInput>;
  email?: Maybe<String>;
  hospital?: Maybe<String>;
  hospitalArabic?: Maybe<String>;
  doctors?: Maybe<DoctorUpdateManyWithoutHospitalInput>;
  language?: Maybe<String>;
  latitude?: Maybe<String>;
  location?: Maybe<String>;
  logo?: Maybe<String>;
  longitude?: Maybe<String>;
  password?: Maybe<String>;
  phone?: Maybe<String>;
  phone1?: Maybe<String>;
  status?: Maybe<Int>;
  type?: Maybe<String>;
  uniqeId?: Maybe<String>;
  createdDate?: Maybe<DateTimeInput>;
}

export interface HospitalUpsertWithWhereUniqueWithoutInsurancesInput {
  where: HospitalWhereUniqueInput;
  update: HospitalUpdateWithoutInsurancesDataInput;
  create: HospitalCreateWithoutInsurancesInput;
}

export interface InsuranceUpdateManyMutationInput {
  countryId?: Maybe<Int>;
  insurance?: Maybe<String>;
  insuranceArabic?: Maybe<String>;
}

export interface InsuranceCategoryCreateInput {
  id?: Maybe<Int>;
  category?: Maybe<String>;
  insuranceId?: Maybe<Int>;
}

export interface InsuranceCategoryUpdateInput {
  category?: Maybe<String>;
  insuranceId?: Maybe<Int>;
}

export interface InsuranceCategoryUpdateManyMutationInput {
  category?: Maybe<String>;
  insuranceId?: Maybe<Int>;
}

export interface JobCreateInput {
  id?: Maybe<Int>;
  position: String;
  positionArabic: String;
}

export interface JobUpdateInput {
  position?: Maybe<String>;
  positionArabic?: Maybe<String>;
}

export interface JobUpdateManyMutationInput {
  position?: Maybe<String>;
  positionArabic?: Maybe<String>;
}

export interface LanguageCreateInput {
  id?: Maybe<Int>;
  language?: Maybe<String>;
}

export interface LanguageUpdateInput {
  language?: Maybe<String>;
}

export interface LanguageUpdateManyMutationInput {
  language?: Maybe<String>;
}

export interface MessageCreateInput {
  id?: Maybe<Int>;
  fromUser: Int;
  isDelete?: Maybe<Int>;
  isRead?: Maybe<Int>;
  message: String;
  sentBy: Int;
  toUser: Int;
}

export interface MessageUpdateInput {
  fromUser?: Maybe<Int>;
  isDelete?: Maybe<Int>;
  isRead?: Maybe<Int>;
  message?: Maybe<String>;
  sentBy?: Maybe<Int>;
  toUser?: Maybe<Int>;
}

export interface MessageUpdateManyMutationInput {
  fromUser?: Maybe<Int>;
  isDelete?: Maybe<Int>;
  isRead?: Maybe<Int>;
  message?: Maybe<String>;
  sentBy?: Maybe<Int>;
  toUser?: Maybe<Int>;
}

export interface MigrationCreateInput {
  id?: Maybe<Int>;
  batch: Int;
  migration: String;
}

export interface MigrationUpdateInput {
  batch?: Maybe<Int>;
  migration?: Maybe<String>;
}

export interface MigrationUpdateManyMutationInput {
  batch?: Maybe<Int>;
  migration?: Maybe<String>;
}

export interface OfferCreateInput {
  id?: Maybe<Int>;
  description: String;
  descriptionArabic: String;
  endDate: DateTimeInput;
  heading: String;
  headingArabic: String;
  hospitalId: Int;
  offerImage: String;
  position: Int;
  startDate: DateTimeInput;
  status?: Maybe<Int>;
  type: Int;
}

export interface OfferUpdateInput {
  description?: Maybe<String>;
  descriptionArabic?: Maybe<String>;
  endDate?: Maybe<DateTimeInput>;
  heading?: Maybe<String>;
  headingArabic?: Maybe<String>;
  hospitalId?: Maybe<Int>;
  offerImage?: Maybe<String>;
  position?: Maybe<Int>;
  startDate?: Maybe<DateTimeInput>;
  status?: Maybe<Int>;
  type?: Maybe<Int>;
}

export interface OfferUpdateManyMutationInput {
  description?: Maybe<String>;
  descriptionArabic?: Maybe<String>;
  endDate?: Maybe<DateTimeInput>;
  heading?: Maybe<String>;
  headingArabic?: Maybe<String>;
  hospitalId?: Maybe<Int>;
  offerImage?: Maybe<String>;
  position?: Maybe<Int>;
  startDate?: Maybe<DateTimeInput>;
  status?: Maybe<Int>;
  type?: Maybe<Int>;
}

export interface OnlineAppointmentCreateInput {
  id?: Maybe<Int>;
  apointmentDate: String;
  apointmentFulldate: Int;
  apointmentTime: String;
  diseaseId?: Maybe<Int>;
  doctorArabic: String;
  doctorId?: Maybe<Int>;
  doctorName: String;
  dtId?: Maybe<Int>;
  gender: String;
  optId?: Maybe<Int>;
  patientId?: Maybe<Int>;
  phone: String;
  phoneCode?: Maybe<String>;
  scheduleTimeId: Int;
  status?: Maybe<Int>;
}

export interface OnlineAppointmentUpdateInput {
  apointmentDate?: Maybe<String>;
  apointmentFulldate?: Maybe<Int>;
  apointmentTime?: Maybe<String>;
  diseaseId?: Maybe<Int>;
  doctorArabic?: Maybe<String>;
  doctorId?: Maybe<Int>;
  doctorName?: Maybe<String>;
  dtId?: Maybe<Int>;
  gender?: Maybe<String>;
  optId?: Maybe<Int>;
  patientId?: Maybe<Int>;
  phone?: Maybe<String>;
  phoneCode?: Maybe<String>;
  scheduleTimeId?: Maybe<Int>;
  status?: Maybe<Int>;
}

export interface OnlineAppointmentUpdateManyMutationInput {
  apointmentDate?: Maybe<String>;
  apointmentFulldate?: Maybe<Int>;
  apointmentTime?: Maybe<String>;
  diseaseId?: Maybe<Int>;
  doctorArabic?: Maybe<String>;
  doctorId?: Maybe<Int>;
  doctorName?: Maybe<String>;
  dtId?: Maybe<Int>;
  gender?: Maybe<String>;
  optId?: Maybe<Int>;
  patientId?: Maybe<Int>;
  phone?: Maybe<String>;
  phoneCode?: Maybe<String>;
  scheduleTimeId?: Maybe<Int>;
  status?: Maybe<Int>;
}

export interface OnlineDoctorCreateInput {
  id?: Maybe<Int>;
  apiKey: String;
  designation: String;
  doctorCv: String;
  email?: Maybe<String>;
  gender: String;
  mohcard?: Maybe<String>;
  mohId: String;
  name?: Maybe<String>;
  nameArabic: String;
  password?: Maybe<String>;
  phone?: Maybe<String>;
  picture?: Maybe<String>;
  specialityId?: Maybe<Int>;
  status?: Maybe<Int>;
}

export interface OnlineDoctorUpdateInput {
  apiKey?: Maybe<String>;
  designation?: Maybe<String>;
  doctorCv?: Maybe<String>;
  email?: Maybe<String>;
  gender?: Maybe<String>;
  mohcard?: Maybe<String>;
  mohId?: Maybe<String>;
  name?: Maybe<String>;
  nameArabic?: Maybe<String>;
  password?: Maybe<String>;
  phone?: Maybe<String>;
  picture?: Maybe<String>;
  specialityId?: Maybe<Int>;
  status?: Maybe<Int>;
}

export interface OnlineDoctorUpdateManyMutationInput {
  apiKey?: Maybe<String>;
  designation?: Maybe<String>;
  doctorCv?: Maybe<String>;
  email?: Maybe<String>;
  gender?: Maybe<String>;
  mohcard?: Maybe<String>;
  mohId?: Maybe<String>;
  name?: Maybe<String>;
  nameArabic?: Maybe<String>;
  password?: Maybe<String>;
  phone?: Maybe<String>;
  picture?: Maybe<String>;
  specialityId?: Maybe<Int>;
  status?: Maybe<Int>;
}

export interface OnlineRatingCreateInput {
  id?: Maybe<Int>;
  doctorsId?: Maybe<Int>;
  rating?: Maybe<String>;
  systemIp: String;
}

export interface OnlineRatingUpdateInput {
  doctorsId?: Maybe<Int>;
  rating?: Maybe<String>;
  systemIp?: Maybe<String>;
}

export interface OnlineRatingUpdateManyMutationInput {
  doctorsId?: Maybe<Int>;
  rating?: Maybe<String>;
  systemIp?: Maybe<String>;
}

export interface OptTimeUpdateInput {
  fifteenMins?: Maybe<String>;
  thirtyMins?: Maybe<String>;
  twentyMins?: Maybe<String>;
}

export interface OptTimeUpdateManyMutationInput {
  fifteenMins?: Maybe<String>;
  thirtyMins?: Maybe<String>;
  twentyMins?: Maybe<String>;
}

export interface PageCreateInput {
  id?: Maybe<Int>;
  slug?: Maybe<String>;
  slug_ar?: Maybe<String>;
  title?: Maybe<String>;
  title_ar?: Maybe<String>;
  content?: Maybe<String>;
  content_ar?: Maybe<String>;
}

export interface PageUpdateInput {
  slug?: Maybe<String>;
  slug_ar?: Maybe<String>;
  title?: Maybe<String>;
  title_ar?: Maybe<String>;
  content?: Maybe<String>;
  content_ar?: Maybe<String>;
}

export interface PageUpdateManyMutationInput {
  slug?: Maybe<String>;
  slug_ar?: Maybe<String>;
  title?: Maybe<String>;
  title_ar?: Maybe<String>;
  content?: Maybe<String>;
  content_ar?: Maybe<String>;
}

export interface PasswordResetCreateInput {
  id?: Maybe<Int>;
  email: String;
  token: String;
}

export interface PasswordResetUpdateInput {
  email?: Maybe<String>;
  token?: Maybe<String>;
}

export interface PasswordResetUpdateManyMutationInput {
  email?: Maybe<String>;
  token?: Maybe<String>;
}

export interface PatientUpdateInput {
  age?: Maybe<Int>;
  apiKey?: Maybe<String>;
  dob?: Maybe<String>;
  email?: Maybe<String>;
  gender?: Maybe<String>;
  lastAction?: Maybe<String>;
  mailSubs?: Maybe<Int>;
  mobile?: Maybe<String>;
  name?: Maybe<String>;
  password?: Maybe<String>;
  status?: Maybe<Int>;
  uniqeId?: Maybe<String>;
}

export interface PatientUpdateManyMutationInput {
  age?: Maybe<Int>;
  apiKey?: Maybe<String>;
  dob?: Maybe<String>;
  email?: Maybe<String>;
  gender?: Maybe<String>;
  lastAction?: Maybe<String>;
  mailSubs?: Maybe<Int>;
  mobile?: Maybe<String>;
  name?: Maybe<String>;
  password?: Maybe<String>;
  status?: Maybe<Int>;
  uniqeId?: Maybe<String>;
}

export interface PostImageCreateInput {
  id?: Maybe<Int>;
  isDefault?: Maybe<Int>;
  pic: String;
  postId?: Maybe<BlogPostCreateOneWithoutImagesInput>;
}

export interface BlogPostCreateOneWithoutImagesInput {
  create?: Maybe<BlogPostCreateWithoutImagesInput>;
  connect?: Maybe<BlogPostWhereUniqueInput>;
}

export interface BlogPostCreateWithoutImagesInput {
  id?: Maybe<Int>;
  blogId?: Maybe<BlogCreateOneInput>;
  hospitalId?: Maybe<HospitalCreateOneInput>;
  postContent: String;
  postTitle: String;
  status?: Maybe<Int>;
  totalViewers?: Maybe<Int>;
}

export interface PostImageUpdateInput {
  isDefault?: Maybe<Int>;
  pic?: Maybe<String>;
  postId?: Maybe<BlogPostUpdateOneWithoutImagesInput>;
}

export interface BlogPostUpdateOneWithoutImagesInput {
  create?: Maybe<BlogPostCreateWithoutImagesInput>;
  update?: Maybe<BlogPostUpdateWithoutImagesDataInput>;
  upsert?: Maybe<BlogPostUpsertWithoutImagesInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<BlogPostWhereUniqueInput>;
}

export interface BlogPostUpdateWithoutImagesDataInput {
  blogId?: Maybe<BlogUpdateOneInput>;
  hospitalId?: Maybe<HospitalUpdateOneInput>;
  postContent?: Maybe<String>;
  postTitle?: Maybe<String>;
  status?: Maybe<Int>;
  totalViewers?: Maybe<Int>;
}

export interface BlogPostUpsertWithoutImagesInput {
  update: BlogPostUpdateWithoutImagesDataInput;
  create: BlogPostCreateWithoutImagesInput;
}

export interface PostImageUpdateManyMutationInput {
  isDefault?: Maybe<Int>;
  pic?: Maybe<String>;
}

export interface SearchDesignCreateInput {
  id?: Maybe<Int>;
  addressColor: String;
  addressFamily: String;
  addressStyle: String;
  designationColor: String;
  designationFamily: String;
  designationStyle: String;
  doctorColor: String;
  doctorFamily: String;
  doctorStyle: String;
  emailColor: String;
  emailFamily: String;
  emailStyle: String;
  nameColor: String;
  nameFamily: String;
  nameStyle: String;
  phoneColor: String;
  phoneFamily: String;
  phoneStyle: String;
  ratingColor: String;
  ratingFamily: String;
  ratingStyle: String;
  specialityColor: String;
  specialityFamily: String;
  specialityStyle: String;
}

export interface SearchDesignUpdateInput {
  addressColor?: Maybe<String>;
  addressFamily?: Maybe<String>;
  addressStyle?: Maybe<String>;
  designationColor?: Maybe<String>;
  designationFamily?: Maybe<String>;
  designationStyle?: Maybe<String>;
  doctorColor?: Maybe<String>;
  doctorFamily?: Maybe<String>;
  doctorStyle?: Maybe<String>;
  emailColor?: Maybe<String>;
  emailFamily?: Maybe<String>;
  emailStyle?: Maybe<String>;
  nameColor?: Maybe<String>;
  nameFamily?: Maybe<String>;
  nameStyle?: Maybe<String>;
  phoneColor?: Maybe<String>;
  phoneFamily?: Maybe<String>;
  phoneStyle?: Maybe<String>;
  ratingColor?: Maybe<String>;
  ratingFamily?: Maybe<String>;
  ratingStyle?: Maybe<String>;
  specialityColor?: Maybe<String>;
  specialityFamily?: Maybe<String>;
  specialityStyle?: Maybe<String>;
}

export interface SearchDesignUpdateManyMutationInput {
  addressColor?: Maybe<String>;
  addressFamily?: Maybe<String>;
  addressStyle?: Maybe<String>;
  designationColor?: Maybe<String>;
  designationFamily?: Maybe<String>;
  designationStyle?: Maybe<String>;
  doctorColor?: Maybe<String>;
  doctorFamily?: Maybe<String>;
  doctorStyle?: Maybe<String>;
  emailColor?: Maybe<String>;
  emailFamily?: Maybe<String>;
  emailStyle?: Maybe<String>;
  nameColor?: Maybe<String>;
  nameFamily?: Maybe<String>;
  nameStyle?: Maybe<String>;
  phoneColor?: Maybe<String>;
  phoneFamily?: Maybe<String>;
  phoneStyle?: Maybe<String>;
  ratingColor?: Maybe<String>;
  ratingFamily?: Maybe<String>;
  ratingStyle?: Maybe<String>;
  specialityColor?: Maybe<String>;
  specialityFamily?: Maybe<String>;
  specialityStyle?: Maybe<String>;
}

export interface SheduleTimeUpdateInput {
  drSheduleId?: Maybe<Int>;
  scheduleFullDate?: Maybe<Int>;
  sheduleTime?: Maybe<String>;
  status?: Maybe<Int>;
}

export interface SheduleTimeUpdateManyMutationInput {
  drSheduleId?: Maybe<Int>;
  scheduleFullDate?: Maybe<Int>;
  sheduleTime?: Maybe<String>;
  status?: Maybe<Int>;
}

export interface SliderCreateInput {
  id?: Maybe<Int>;
  arabicHeading: String;
  banner: String;
  heading: String;
}

export interface SliderUpdateInput {
  arabicHeading?: Maybe<String>;
  banner?: Maybe<String>;
  heading?: Maybe<String>;
}

export interface SliderUpdateManyMutationInput {
  arabicHeading?: Maybe<String>;
  banner?: Maybe<String>;
  heading?: Maybe<String>;
}

export interface SpecialityUpdateInput {
  doctors?: Maybe<DoctorUpdateManyWithoutSpecialitiesInput>;
  speciality?: Maybe<String>;
  specialityArabic?: Maybe<String>;
}

export interface SpecialityUpdateManyMutationInput {
  speciality?: Maybe<String>;
  specialityArabic?: Maybe<String>;
}

export interface TranslationCreateInput {
  id?: Maybe<Int>;
  arabi: String;
  english: String;
  index: String;
}

export interface TranslationUpdateInput {
  arabi?: Maybe<String>;
  english?: Maybe<String>;
  index?: Maybe<String>;
}

export interface TranslationUpdateManyMutationInput {
  arabi?: Maybe<String>;
  english?: Maybe<String>;
  index?: Maybe<String>;
}

export interface UserCreateInput {
  id?: Maybe<Int>;
  email: String;
  name: String;
  password: String;
  rememberToken?: Maybe<String>;
}

export interface UserUpdateInput {
  email?: Maybe<String>;
  name?: Maybe<String>;
  password?: Maybe<String>;
  rememberToken?: Maybe<String>;
}

export interface UserUpdateManyMutationInput {
  email?: Maybe<String>;
  name?: Maybe<String>;
  password?: Maybe<String>;
  rememberToken?: Maybe<String>;
}

export interface VideoRequestCreateInput {
  id?: Maybe<Int>;
  doctorId: Int;
  joinCall?: Maybe<Int>;
  patientId: Int;
  requestDate: Int;
  videoCode?: Maybe<Int>;
}

export interface VideoRequestUpdateInput {
  doctorId?: Maybe<Int>;
  joinCall?: Maybe<Int>;
  patientId?: Maybe<Int>;
  requestDate?: Maybe<Int>;
  videoCode?: Maybe<Int>;
}

export interface VideoRequestUpdateManyMutationInput {
  doctorId?: Maybe<Int>;
  joinCall?: Maybe<Int>;
  patientId?: Maybe<Int>;
  requestDate?: Maybe<Int>;
  videoCode?: Maybe<Int>;
}

export interface VisitorCreateInput {
  id?: Maybe<Int>;
  country?: Maybe<String>;
  hits: Int;
  ipAddress: String;
  visitDate: DateTimeInput;
}

export interface VisitorUpdateInput {
  country?: Maybe<String>;
  hits?: Maybe<Int>;
  ipAddress?: Maybe<String>;
  visitDate?: Maybe<DateTimeInput>;
}

export interface VisitorUpdateManyMutationInput {
  country?: Maybe<String>;
  hits?: Maybe<Int>;
  ipAddress?: Maybe<String>;
  visitDate?: Maybe<DateTimeInput>;
}

export interface AboutUsSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<AboutUsWhereInput>;
  AND?: Maybe<AboutUsSubscriptionWhereInput[] | AboutUsSubscriptionWhereInput>;
  OR?: Maybe<AboutUsSubscriptionWhereInput[] | AboutUsSubscriptionWhereInput>;
  NOT?: Maybe<AboutUsSubscriptionWhereInput[] | AboutUsSubscriptionWhereInput>;
}

export interface AdminSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<AdminWhereInput>;
  AND?: Maybe<AdminSubscriptionWhereInput[] | AdminSubscriptionWhereInput>;
  OR?: Maybe<AdminSubscriptionWhereInput[] | AdminSubscriptionWhereInput>;
  NOT?: Maybe<AdminSubscriptionWhereInput[] | AdminSubscriptionWhereInput>;
}

export interface AppointmentSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<AppointmentWhereInput>;
  AND?: Maybe<
    AppointmentSubscriptionWhereInput[] | AppointmentSubscriptionWhereInput
  >;
  OR?: Maybe<
    AppointmentSubscriptionWhereInput[] | AppointmentSubscriptionWhereInput
  >;
  NOT?: Maybe<
    AppointmentSubscriptionWhereInput[] | AppointmentSubscriptionWhereInput
  >;
}

export interface BlogSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<BlogWhereInput>;
  AND?: Maybe<BlogSubscriptionWhereInput[] | BlogSubscriptionWhereInput>;
  OR?: Maybe<BlogSubscriptionWhereInput[] | BlogSubscriptionWhereInput>;
  NOT?: Maybe<BlogSubscriptionWhereInput[] | BlogSubscriptionWhereInput>;
}

export interface BlogCommentSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<BlogCommentWhereInput>;
  AND?: Maybe<
    BlogCommentSubscriptionWhereInput[] | BlogCommentSubscriptionWhereInput
  >;
  OR?: Maybe<
    BlogCommentSubscriptionWhereInput[] | BlogCommentSubscriptionWhereInput
  >;
  NOT?: Maybe<
    BlogCommentSubscriptionWhereInput[] | BlogCommentSubscriptionWhereInput
  >;
}

export interface BlogPostSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<BlogPostWhereInput>;
  AND?: Maybe<
    BlogPostSubscriptionWhereInput[] | BlogPostSubscriptionWhereInput
  >;
  OR?: Maybe<BlogPostSubscriptionWhereInput[] | BlogPostSubscriptionWhereInput>;
  NOT?: Maybe<
    BlogPostSubscriptionWhereInput[] | BlogPostSubscriptionWhereInput
  >;
}

export interface CitySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CityWhereInput>;
  AND?: Maybe<CitySubscriptionWhereInput[] | CitySubscriptionWhereInput>;
  OR?: Maybe<CitySubscriptionWhereInput[] | CitySubscriptionWhereInput>;
  NOT?: Maybe<CitySubscriptionWhereInput[] | CitySubscriptionWhereInput>;
}

export interface ContactUsSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ContactUsWhereInput>;
  AND?: Maybe<
    ContactUsSubscriptionWhereInput[] | ContactUsSubscriptionWhereInput
  >;
  OR?: Maybe<
    ContactUsSubscriptionWhereInput[] | ContactUsSubscriptionWhereInput
  >;
  NOT?: Maybe<
    ContactUsSubscriptionWhereInput[] | ContactUsSubscriptionWhereInput
  >;
}

export interface CountrySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CountryWhereInput>;
  AND?: Maybe<CountrySubscriptionWhereInput[] | CountrySubscriptionWhereInput>;
  OR?: Maybe<CountrySubscriptionWhereInput[] | CountrySubscriptionWhereInput>;
  NOT?: Maybe<CountrySubscriptionWhereInput[] | CountrySubscriptionWhereInput>;
}

export interface DiseaseSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<DiseaseWhereInput>;
  AND?: Maybe<DiseaseSubscriptionWhereInput[] | DiseaseSubscriptionWhereInput>;
  OR?: Maybe<DiseaseSubscriptionWhereInput[] | DiseaseSubscriptionWhereInput>;
  NOT?: Maybe<DiseaseSubscriptionWhereInput[] | DiseaseSubscriptionWhereInput>;
}

export interface DiseaseCoveredSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<DiseaseCoveredWhereInput>;
  AND?: Maybe<
    | DiseaseCoveredSubscriptionWhereInput[]
    | DiseaseCoveredSubscriptionWhereInput
  >;
  OR?: Maybe<
    | DiseaseCoveredSubscriptionWhereInput[]
    | DiseaseCoveredSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | DiseaseCoveredSubscriptionWhereInput[]
    | DiseaseCoveredSubscriptionWhereInput
  >;
}

export interface DoctorSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<DoctorWhereInput>;
  AND?: Maybe<DoctorSubscriptionWhereInput[] | DoctorSubscriptionWhereInput>;
  OR?: Maybe<DoctorSubscriptionWhereInput[] | DoctorSubscriptionWhereInput>;
  NOT?: Maybe<DoctorSubscriptionWhereInput[] | DoctorSubscriptionWhereInput>;
}

export interface DoctorOldSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<DoctorOldWhereInput>;
  AND?: Maybe<
    DoctorOldSubscriptionWhereInput[] | DoctorOldSubscriptionWhereInput
  >;
  OR?: Maybe<
    DoctorOldSubscriptionWhereInput[] | DoctorOldSubscriptionWhereInput
  >;
  NOT?: Maybe<
    DoctorOldSubscriptionWhereInput[] | DoctorOldSubscriptionWhereInput
  >;
}

export interface DoctorSheduleSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<DoctorSheduleWhereInput>;
  AND?: Maybe<
    DoctorSheduleSubscriptionWhereInput[] | DoctorSheduleSubscriptionWhereInput
  >;
  OR?: Maybe<
    DoctorSheduleSubscriptionWhereInput[] | DoctorSheduleSubscriptionWhereInput
  >;
  NOT?: Maybe<
    DoctorSheduleSubscriptionWhereInput[] | DoctorSheduleSubscriptionWhereInput
  >;
}

export interface DoctorSheduleTimeSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<DoctorSheduleTimeWhereInput>;
  AND?: Maybe<
    | DoctorSheduleTimeSubscriptionWhereInput[]
    | DoctorSheduleTimeSubscriptionWhereInput
  >;
  OR?: Maybe<
    | DoctorSheduleTimeSubscriptionWhereInput[]
    | DoctorSheduleTimeSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | DoctorSheduleTimeSubscriptionWhereInput[]
    | DoctorSheduleTimeSubscriptionWhereInput
  >;
}

export interface DoctorsRatingSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<DoctorsRatingWhereInput>;
  AND?: Maybe<
    DoctorsRatingSubscriptionWhereInput[] | DoctorsRatingSubscriptionWhereInput
  >;
  OR?: Maybe<
    DoctorsRatingSubscriptionWhereInput[] | DoctorsRatingSubscriptionWhereInput
  >;
  NOT?: Maybe<
    DoctorsRatingSubscriptionWhereInput[] | DoctorsRatingSubscriptionWhereInput
  >;
}

export interface DrSheduleSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<DrSheduleWhereInput>;
  AND?: Maybe<
    DrSheduleSubscriptionWhereInput[] | DrSheduleSubscriptionWhereInput
  >;
  OR?: Maybe<
    DrSheduleSubscriptionWhereInput[] | DrSheduleSubscriptionWhereInput
  >;
  NOT?: Maybe<
    DrSheduleSubscriptionWhereInput[] | DrSheduleSubscriptionWhereInput
  >;
}

export interface EmailSubscriptionSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<EmailSubscriptionWhereInput>;
  AND?: Maybe<
    | EmailSubscriptionSubscriptionWhereInput[]
    | EmailSubscriptionSubscriptionWhereInput
  >;
  OR?: Maybe<
    | EmailSubscriptionSubscriptionWhereInput[]
    | EmailSubscriptionSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | EmailSubscriptionSubscriptionWhereInput[]
    | EmailSubscriptionSubscriptionWhereInput
  >;
}

export interface FacilitySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<FacilityWhereInput>;
  AND?: Maybe<
    FacilitySubscriptionWhereInput[] | FacilitySubscriptionWhereInput
  >;
  OR?: Maybe<FacilitySubscriptionWhereInput[] | FacilitySubscriptionWhereInput>;
  NOT?: Maybe<
    FacilitySubscriptionWhereInput[] | FacilitySubscriptionWhereInput
  >;
}

export interface HospitalSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<HospitalWhereInput>;
  AND?: Maybe<
    HospitalSubscriptionWhereInput[] | HospitalSubscriptionWhereInput
  >;
  OR?: Maybe<HospitalSubscriptionWhereInput[] | HospitalSubscriptionWhereInput>;
  NOT?: Maybe<
    HospitalSubscriptionWhereInput[] | HospitalSubscriptionWhereInput
  >;
}

export interface HospitalFacilitySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<HospitalFacilityWhereInput>;
  AND?: Maybe<
    | HospitalFacilitySubscriptionWhereInput[]
    | HospitalFacilitySubscriptionWhereInput
  >;
  OR?: Maybe<
    | HospitalFacilitySubscriptionWhereInput[]
    | HospitalFacilitySubscriptionWhereInput
  >;
  NOT?: Maybe<
    | HospitalFacilitySubscriptionWhereInput[]
    | HospitalFacilitySubscriptionWhereInput
  >;
}

export interface HospitalRatingSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<HospitalRatingWhereInput>;
  AND?: Maybe<
    | HospitalRatingSubscriptionWhereInput[]
    | HospitalRatingSubscriptionWhereInput
  >;
  OR?: Maybe<
    | HospitalRatingSubscriptionWhereInput[]
    | HospitalRatingSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | HospitalRatingSubscriptionWhereInput[]
    | HospitalRatingSubscriptionWhereInput
  >;
}

export interface IllnessSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<IllnessWhereInput>;
  AND?: Maybe<IllnessSubscriptionWhereInput[] | IllnessSubscriptionWhereInput>;
  OR?: Maybe<IllnessSubscriptionWhereInput[] | IllnessSubscriptionWhereInput>;
  NOT?: Maybe<IllnessSubscriptionWhereInput[] | IllnessSubscriptionWhereInput>;
}

export interface InsuranceSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<InsuranceWhereInput>;
  AND?: Maybe<
    InsuranceSubscriptionWhereInput[] | InsuranceSubscriptionWhereInput
  >;
  OR?: Maybe<
    InsuranceSubscriptionWhereInput[] | InsuranceSubscriptionWhereInput
  >;
  NOT?: Maybe<
    InsuranceSubscriptionWhereInput[] | InsuranceSubscriptionWhereInput
  >;
}

export interface InsuranceCategorySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<InsuranceCategoryWhereInput>;
  AND?: Maybe<
    | InsuranceCategorySubscriptionWhereInput[]
    | InsuranceCategorySubscriptionWhereInput
  >;
  OR?: Maybe<
    | InsuranceCategorySubscriptionWhereInput[]
    | InsuranceCategorySubscriptionWhereInput
  >;
  NOT?: Maybe<
    | InsuranceCategorySubscriptionWhereInput[]
    | InsuranceCategorySubscriptionWhereInput
  >;
}

export interface JobSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<JobWhereInput>;
  AND?: Maybe<JobSubscriptionWhereInput[] | JobSubscriptionWhereInput>;
  OR?: Maybe<JobSubscriptionWhereInput[] | JobSubscriptionWhereInput>;
  NOT?: Maybe<JobSubscriptionWhereInput[] | JobSubscriptionWhereInput>;
}

export interface LanguageSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<LanguageWhereInput>;
  AND?: Maybe<
    LanguageSubscriptionWhereInput[] | LanguageSubscriptionWhereInput
  >;
  OR?: Maybe<LanguageSubscriptionWhereInput[] | LanguageSubscriptionWhereInput>;
  NOT?: Maybe<
    LanguageSubscriptionWhereInput[] | LanguageSubscriptionWhereInput
  >;
}

export interface MessageSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<MessageWhereInput>;
  AND?: Maybe<MessageSubscriptionWhereInput[] | MessageSubscriptionWhereInput>;
  OR?: Maybe<MessageSubscriptionWhereInput[] | MessageSubscriptionWhereInput>;
  NOT?: Maybe<MessageSubscriptionWhereInput[] | MessageSubscriptionWhereInput>;
}

export interface MigrationSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<MigrationWhereInput>;
  AND?: Maybe<
    MigrationSubscriptionWhereInput[] | MigrationSubscriptionWhereInput
  >;
  OR?: Maybe<
    MigrationSubscriptionWhereInput[] | MigrationSubscriptionWhereInput
  >;
  NOT?: Maybe<
    MigrationSubscriptionWhereInput[] | MigrationSubscriptionWhereInput
  >;
}

export interface OfferSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<OfferWhereInput>;
  AND?: Maybe<OfferSubscriptionWhereInput[] | OfferSubscriptionWhereInput>;
  OR?: Maybe<OfferSubscriptionWhereInput[] | OfferSubscriptionWhereInput>;
  NOT?: Maybe<OfferSubscriptionWhereInput[] | OfferSubscriptionWhereInput>;
}

export interface OnlineAppointmentSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<OnlineAppointmentWhereInput>;
  AND?: Maybe<
    | OnlineAppointmentSubscriptionWhereInput[]
    | OnlineAppointmentSubscriptionWhereInput
  >;
  OR?: Maybe<
    | OnlineAppointmentSubscriptionWhereInput[]
    | OnlineAppointmentSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | OnlineAppointmentSubscriptionWhereInput[]
    | OnlineAppointmentSubscriptionWhereInput
  >;
}

export interface OnlineDoctorSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<OnlineDoctorWhereInput>;
  AND?: Maybe<
    OnlineDoctorSubscriptionWhereInput[] | OnlineDoctorSubscriptionWhereInput
  >;
  OR?: Maybe<
    OnlineDoctorSubscriptionWhereInput[] | OnlineDoctorSubscriptionWhereInput
  >;
  NOT?: Maybe<
    OnlineDoctorSubscriptionWhereInput[] | OnlineDoctorSubscriptionWhereInput
  >;
}

export interface OnlineRatingSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<OnlineRatingWhereInput>;
  AND?: Maybe<
    OnlineRatingSubscriptionWhereInput[] | OnlineRatingSubscriptionWhereInput
  >;
  OR?: Maybe<
    OnlineRatingSubscriptionWhereInput[] | OnlineRatingSubscriptionWhereInput
  >;
  NOT?: Maybe<
    OnlineRatingSubscriptionWhereInput[] | OnlineRatingSubscriptionWhereInput
  >;
}

export interface OptTimeSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<OptTimeWhereInput>;
  AND?: Maybe<OptTimeSubscriptionWhereInput[] | OptTimeSubscriptionWhereInput>;
  OR?: Maybe<OptTimeSubscriptionWhereInput[] | OptTimeSubscriptionWhereInput>;
  NOT?: Maybe<OptTimeSubscriptionWhereInput[] | OptTimeSubscriptionWhereInput>;
}

export interface PageSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PageWhereInput>;
  AND?: Maybe<PageSubscriptionWhereInput[] | PageSubscriptionWhereInput>;
  OR?: Maybe<PageSubscriptionWhereInput[] | PageSubscriptionWhereInput>;
  NOT?: Maybe<PageSubscriptionWhereInput[] | PageSubscriptionWhereInput>;
}

export interface PasswordResetSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PasswordResetWhereInput>;
  AND?: Maybe<
    PasswordResetSubscriptionWhereInput[] | PasswordResetSubscriptionWhereInput
  >;
  OR?: Maybe<
    PasswordResetSubscriptionWhereInput[] | PasswordResetSubscriptionWhereInput
  >;
  NOT?: Maybe<
    PasswordResetSubscriptionWhereInput[] | PasswordResetSubscriptionWhereInput
  >;
}

export interface PatientSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PatientWhereInput>;
  AND?: Maybe<PatientSubscriptionWhereInput[] | PatientSubscriptionWhereInput>;
  OR?: Maybe<PatientSubscriptionWhereInput[] | PatientSubscriptionWhereInput>;
  NOT?: Maybe<PatientSubscriptionWhereInput[] | PatientSubscriptionWhereInput>;
}

export interface PostImageSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PostImageWhereInput>;
  AND?: Maybe<
    PostImageSubscriptionWhereInput[] | PostImageSubscriptionWhereInput
  >;
  OR?: Maybe<
    PostImageSubscriptionWhereInput[] | PostImageSubscriptionWhereInput
  >;
  NOT?: Maybe<
    PostImageSubscriptionWhereInput[] | PostImageSubscriptionWhereInput
  >;
}

export interface SearchDesignSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<SearchDesignWhereInput>;
  AND?: Maybe<
    SearchDesignSubscriptionWhereInput[] | SearchDesignSubscriptionWhereInput
  >;
  OR?: Maybe<
    SearchDesignSubscriptionWhereInput[] | SearchDesignSubscriptionWhereInput
  >;
  NOT?: Maybe<
    SearchDesignSubscriptionWhereInput[] | SearchDesignSubscriptionWhereInput
  >;
}

export interface SheduleTimeSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<SheduleTimeWhereInput>;
  AND?: Maybe<
    SheduleTimeSubscriptionWhereInput[] | SheduleTimeSubscriptionWhereInput
  >;
  OR?: Maybe<
    SheduleTimeSubscriptionWhereInput[] | SheduleTimeSubscriptionWhereInput
  >;
  NOT?: Maybe<
    SheduleTimeSubscriptionWhereInput[] | SheduleTimeSubscriptionWhereInput
  >;
}

export interface SliderSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<SliderWhereInput>;
  AND?: Maybe<SliderSubscriptionWhereInput[] | SliderSubscriptionWhereInput>;
  OR?: Maybe<SliderSubscriptionWhereInput[] | SliderSubscriptionWhereInput>;
  NOT?: Maybe<SliderSubscriptionWhereInput[] | SliderSubscriptionWhereInput>;
}

export interface SpecialitySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<SpecialityWhereInput>;
  AND?: Maybe<
    SpecialitySubscriptionWhereInput[] | SpecialitySubscriptionWhereInput
  >;
  OR?: Maybe<
    SpecialitySubscriptionWhereInput[] | SpecialitySubscriptionWhereInput
  >;
  NOT?: Maybe<
    SpecialitySubscriptionWhereInput[] | SpecialitySubscriptionWhereInput
  >;
}

export interface TranslationSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<TranslationWhereInput>;
  AND?: Maybe<
    TranslationSubscriptionWhereInput[] | TranslationSubscriptionWhereInput
  >;
  OR?: Maybe<
    TranslationSubscriptionWhereInput[] | TranslationSubscriptionWhereInput
  >;
  NOT?: Maybe<
    TranslationSubscriptionWhereInput[] | TranslationSubscriptionWhereInput
  >;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserWhereInput>;
  AND?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  OR?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  NOT?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
}

export interface VideoRequestSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<VideoRequestWhereInput>;
  AND?: Maybe<
    VideoRequestSubscriptionWhereInput[] | VideoRequestSubscriptionWhereInput
  >;
  OR?: Maybe<
    VideoRequestSubscriptionWhereInput[] | VideoRequestSubscriptionWhereInput
  >;
  NOT?: Maybe<
    VideoRequestSubscriptionWhereInput[] | VideoRequestSubscriptionWhereInput
  >;
}

export interface VisitorSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<VisitorWhereInput>;
  AND?: Maybe<VisitorSubscriptionWhereInput[] | VisitorSubscriptionWhereInput>;
  OR?: Maybe<VisitorSubscriptionWhereInput[] | VisitorSubscriptionWhereInput>;
  NOT?: Maybe<VisitorSubscriptionWhereInput[] | VisitorSubscriptionWhereInput>;
}

export interface NodeNode {
  id: ID_Output;
}

export interface AboutUs {
  id: Int;
  arabicContent: String;
  englishContent: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface AboutUsPromise extends Promise<AboutUs>, Fragmentable {
  id: () => Promise<Int>;
  arabicContent: () => Promise<String>;
  englishContent: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface AboutUsSubscription
  extends Promise<AsyncIterator<AboutUs>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  arabicContent: () => Promise<AsyncIterator<String>>;
  englishContent: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AboutUsNullablePromise
  extends Promise<AboutUs | null>,
    Fragmentable {
  id: () => Promise<Int>;
  arabicContent: () => Promise<String>;
  englishContent: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface AboutUsConnection {
  pageInfo: PageInfo;
  edges: AboutUsEdge[];
}

export interface AboutUsConnectionPromise
  extends Promise<AboutUsConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AboutUsEdge>>() => T;
  aggregate: <T = AggregateAboutUsPromise>() => T;
}

export interface AboutUsConnectionSubscription
  extends Promise<AsyncIterator<AboutUsConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AboutUsEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAboutUsSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface AboutUsEdge {
  node: AboutUs;
  cursor: String;
}

export interface AboutUsEdgePromise extends Promise<AboutUsEdge>, Fragmentable {
  node: <T = AboutUsPromise>() => T;
  cursor: () => Promise<String>;
}

export interface AboutUsEdgeSubscription
  extends Promise<AsyncIterator<AboutUsEdge>>,
    Fragmentable {
  node: <T = AboutUsSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateAboutUs {
  count: Int;
}

export interface AggregateAboutUsPromise
  extends Promise<AggregateAboutUs>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAboutUsSubscription
  extends Promise<AsyncIterator<AggregateAboutUs>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Admin {
  id: Int;
  email: String;
  pass?: String;
  superAdmin: Int;
  user?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface AdminPromise extends Promise<Admin>, Fragmentable {
  id: () => Promise<Int>;
  email: () => Promise<String>;
  pass: () => Promise<String>;
  superAdmin: () => Promise<Int>;
  user: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface AdminSubscription
  extends Promise<AsyncIterator<Admin>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  email: () => Promise<AsyncIterator<String>>;
  pass: () => Promise<AsyncIterator<String>>;
  superAdmin: () => Promise<AsyncIterator<Int>>;
  user: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AdminNullablePromise
  extends Promise<Admin | null>,
    Fragmentable {
  id: () => Promise<Int>;
  email: () => Promise<String>;
  pass: () => Promise<String>;
  superAdmin: () => Promise<Int>;
  user: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface AdminConnection {
  pageInfo: PageInfo;
  edges: AdminEdge[];
}

export interface AdminConnectionPromise
  extends Promise<AdminConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AdminEdge>>() => T;
  aggregate: <T = AggregateAdminPromise>() => T;
}

export interface AdminConnectionSubscription
  extends Promise<AsyncIterator<AdminConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AdminEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAdminSubscription>() => T;
}

export interface AdminEdge {
  node: Admin;
  cursor: String;
}

export interface AdminEdgePromise extends Promise<AdminEdge>, Fragmentable {
  node: <T = AdminPromise>() => T;
  cursor: () => Promise<String>;
}

export interface AdminEdgeSubscription
  extends Promise<AsyncIterator<AdminEdge>>,
    Fragmentable {
  node: <T = AdminSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateAdmin {
  count: Int;
}

export interface AggregateAdminPromise
  extends Promise<AggregateAdmin>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAdminSubscription
  extends Promise<AsyncIterator<AggregateAdmin>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Appointment {
  id: Int;
  apointmentDate: String;
  apointmentFulldate: Int;
  apointmentTime: String;
  doctorArabic: String;
  doctorName: String;
  gender: String;
  isRead: Int;
  phone: String;
  phoneCode?: String;
  status?: Int;
}

export interface AppointmentPromise extends Promise<Appointment>, Fragmentable {
  id: () => Promise<Int>;
  apointmentDate: () => Promise<String>;
  apointmentFulldate: () => Promise<Int>;
  apointmentTime: () => Promise<String>;
  diseaseId: <T = DiseasePromise>() => T;
  doctorArabic: () => Promise<String>;
  doctorId: <T = DoctorPromise>() => T;
  doctorName: () => Promise<String>;
  dtId: <T = DoctorSheduleTimePromise>() => T;
  gender: () => Promise<String>;
  hospitalId: <T = HospitalPromise>() => T;
  isRead: () => Promise<Int>;
  optId: <T = OptTimePromise>() => T;
  patientId: <T = PatientPromise>() => T;
  phone: () => Promise<String>;
  phoneCode: () => Promise<String>;
  scheduleTimeId: <T = SheduleTimePromise>() => T;
  status: () => Promise<Int>;
}

export interface AppointmentSubscription
  extends Promise<AsyncIterator<Appointment>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  apointmentDate: () => Promise<AsyncIterator<String>>;
  apointmentFulldate: () => Promise<AsyncIterator<Int>>;
  apointmentTime: () => Promise<AsyncIterator<String>>;
  diseaseId: <T = DiseaseSubscription>() => T;
  doctorArabic: () => Promise<AsyncIterator<String>>;
  doctorId: <T = DoctorSubscription>() => T;
  doctorName: () => Promise<AsyncIterator<String>>;
  dtId: <T = DoctorSheduleTimeSubscription>() => T;
  gender: () => Promise<AsyncIterator<String>>;
  hospitalId: <T = HospitalSubscription>() => T;
  isRead: () => Promise<AsyncIterator<Int>>;
  optId: <T = OptTimeSubscription>() => T;
  patientId: <T = PatientSubscription>() => T;
  phone: () => Promise<AsyncIterator<String>>;
  phoneCode: () => Promise<AsyncIterator<String>>;
  scheduleTimeId: <T = SheduleTimeSubscription>() => T;
  status: () => Promise<AsyncIterator<Int>>;
}

export interface AppointmentNullablePromise
  extends Promise<Appointment | null>,
    Fragmentable {
  id: () => Promise<Int>;
  apointmentDate: () => Promise<String>;
  apointmentFulldate: () => Promise<Int>;
  apointmentTime: () => Promise<String>;
  diseaseId: <T = DiseasePromise>() => T;
  doctorArabic: () => Promise<String>;
  doctorId: <T = DoctorPromise>() => T;
  doctorName: () => Promise<String>;
  dtId: <T = DoctorSheduleTimePromise>() => T;
  gender: () => Promise<String>;
  hospitalId: <T = HospitalPromise>() => T;
  isRead: () => Promise<Int>;
  optId: <T = OptTimePromise>() => T;
  patientId: <T = PatientPromise>() => T;
  phone: () => Promise<String>;
  phoneCode: () => Promise<String>;
  scheduleTimeId: <T = SheduleTimePromise>() => T;
  status: () => Promise<Int>;
}

export interface Disease {
  id: Int;
  disease?: String;
  diseaseArabic: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface DiseasePromise extends Promise<Disease>, Fragmentable {
  id: () => Promise<Int>;
  disease: () => Promise<String>;
  diseaseArabic: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface DiseaseSubscription
  extends Promise<AsyncIterator<Disease>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  disease: () => Promise<AsyncIterator<String>>;
  diseaseArabic: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface DiseaseNullablePromise
  extends Promise<Disease | null>,
    Fragmentable {
  id: () => Promise<Int>;
  disease: () => Promise<String>;
  diseaseArabic: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface Doctor {
  id: Int;
  apiKey: String;
  designation?: String;
  doctorCv: String;
  email?: String;
  gender?: String;
  mohcard?: String;
  mohId: String;
  name?: String;
  nameArabic?: String;
  password: String;
  phone?: String;
  fees?: String;
  picture?: String;
  specialityId?: Int;
  status?: Int;
  updatedAt?: DateTimeOutput;
  createdDate: DateTimeOutput;
}

export interface DoctorPromise extends Promise<Doctor>, Fragmentable {
  id: () => Promise<Int>;
  apiKey: () => Promise<String>;
  designation: () => Promise<String>;
  doctorCv: () => Promise<String>;
  email: () => Promise<String>;
  gender: () => Promise<String>;
  mohcard: () => Promise<String>;
  mohId: () => Promise<String>;
  name: () => Promise<String>;
  nameArabic: () => Promise<String>;
  password: () => Promise<String>;
  phone: () => Promise<String>;
  fees: () => Promise<String>;
  picture: () => Promise<String>;
  specialityId: () => Promise<Int>;
  specialities: <T = SpecialityPromise>() => T;
  hospital: <T = FragmentableArray<Hospital>>(args?: {
    where?: HospitalWhereInput;
    orderBy?: HospitalOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  status: () => Promise<Int>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdDate: () => Promise<DateTimeOutput>;
}

export interface DoctorSubscription
  extends Promise<AsyncIterator<Doctor>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  apiKey: () => Promise<AsyncIterator<String>>;
  designation: () => Promise<AsyncIterator<String>>;
  doctorCv: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  gender: () => Promise<AsyncIterator<String>>;
  mohcard: () => Promise<AsyncIterator<String>>;
  mohId: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  nameArabic: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
  fees: () => Promise<AsyncIterator<String>>;
  picture: () => Promise<AsyncIterator<String>>;
  specialityId: () => Promise<AsyncIterator<Int>>;
  specialities: <T = SpecialitySubscription>() => T;
  hospital: <T = Promise<AsyncIterator<HospitalSubscription>>>(args?: {
    where?: HospitalWhereInput;
    orderBy?: HospitalOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  status: () => Promise<AsyncIterator<Int>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdDate: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface DoctorNullablePromise
  extends Promise<Doctor | null>,
    Fragmentable {
  id: () => Promise<Int>;
  apiKey: () => Promise<String>;
  designation: () => Promise<String>;
  doctorCv: () => Promise<String>;
  email: () => Promise<String>;
  gender: () => Promise<String>;
  mohcard: () => Promise<String>;
  mohId: () => Promise<String>;
  name: () => Promise<String>;
  nameArabic: () => Promise<String>;
  password: () => Promise<String>;
  phone: () => Promise<String>;
  fees: () => Promise<String>;
  picture: () => Promise<String>;
  specialityId: () => Promise<Int>;
  specialities: <T = SpecialityPromise>() => T;
  hospital: <T = FragmentableArray<Hospital>>(args?: {
    where?: HospitalWhereInput;
    orderBy?: HospitalOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  status: () => Promise<Int>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdDate: () => Promise<DateTimeOutput>;
}

export interface Speciality {
  id: Int;
  speciality?: String;
  specialityArabic?: String;
  createdAt?: DateTimeOutput;
  updatedAt?: DateTimeOutput;
}

export interface SpecialityPromise extends Promise<Speciality>, Fragmentable {
  id: () => Promise<Int>;
  doctors: <T = FragmentableArray<Doctor>>(args?: {
    where?: DoctorWhereInput;
    orderBy?: DoctorOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  speciality: () => Promise<String>;
  specialityArabic: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface SpecialitySubscription
  extends Promise<AsyncIterator<Speciality>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  doctors: <T = Promise<AsyncIterator<DoctorSubscription>>>(args?: {
    where?: DoctorWhereInput;
    orderBy?: DoctorOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  speciality: () => Promise<AsyncIterator<String>>;
  specialityArabic: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface SpecialityNullablePromise
  extends Promise<Speciality | null>,
    Fragmentable {
  id: () => Promise<Int>;
  doctors: <T = FragmentableArray<Doctor>>(args?: {
    where?: DoctorWhereInput;
    orderBy?: DoctorOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  speciality: () => Promise<String>;
  specialityArabic: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface Hospital {
  id: Int;
  address: String;
  addressArabic: String;
  apiKey: String;
  email?: String;
  hospital?: String;
  hospitalArabic: String;
  language: String;
  latitude: String;
  location: String;
  logo?: String;
  longitude: String;
  password?: String;
  phone?: String;
  phone1: String;
  status?: Int;
  type?: String;
  uniqeId: String;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
  createdDate: DateTimeOutput;
}

export interface HospitalPromise extends Promise<Hospital>, Fragmentable {
  id: () => Promise<Int>;
  address: () => Promise<String>;
  addressArabic: () => Promise<String>;
  apiKey: () => Promise<String>;
  city: <T = CityPromise>() => T;
  countryId: <T = CountryPromise>() => T;
  email: () => Promise<String>;
  hospital: () => Promise<String>;
  hospitalArabic: () => Promise<String>;
  doctors: <T = FragmentableArray<Doctor>>(args?: {
    where?: DoctorWhereInput;
    orderBy?: DoctorOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  language: () => Promise<String>;
  latitude: () => Promise<String>;
  location: () => Promise<String>;
  logo: () => Promise<String>;
  longitude: () => Promise<String>;
  password: () => Promise<String>;
  phone: () => Promise<String>;
  phone1: () => Promise<String>;
  status: () => Promise<Int>;
  type: () => Promise<String>;
  uniqeId: () => Promise<String>;
  insurances: <T = FragmentableArray<Insurance>>(args?: {
    where?: InsuranceWhereInput;
    orderBy?: InsuranceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  createdDate: () => Promise<DateTimeOutput>;
}

export interface HospitalSubscription
  extends Promise<AsyncIterator<Hospital>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  address: () => Promise<AsyncIterator<String>>;
  addressArabic: () => Promise<AsyncIterator<String>>;
  apiKey: () => Promise<AsyncIterator<String>>;
  city: <T = CitySubscription>() => T;
  countryId: <T = CountrySubscription>() => T;
  email: () => Promise<AsyncIterator<String>>;
  hospital: () => Promise<AsyncIterator<String>>;
  hospitalArabic: () => Promise<AsyncIterator<String>>;
  doctors: <T = Promise<AsyncIterator<DoctorSubscription>>>(args?: {
    where?: DoctorWhereInput;
    orderBy?: DoctorOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  language: () => Promise<AsyncIterator<String>>;
  latitude: () => Promise<AsyncIterator<String>>;
  location: () => Promise<AsyncIterator<String>>;
  logo: () => Promise<AsyncIterator<String>>;
  longitude: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
  phone1: () => Promise<AsyncIterator<String>>;
  status: () => Promise<AsyncIterator<Int>>;
  type: () => Promise<AsyncIterator<String>>;
  uniqeId: () => Promise<AsyncIterator<String>>;
  insurances: <T = Promise<AsyncIterator<InsuranceSubscription>>>(args?: {
    where?: InsuranceWhereInput;
    orderBy?: InsuranceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdDate: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface HospitalNullablePromise
  extends Promise<Hospital | null>,
    Fragmentable {
  id: () => Promise<Int>;
  address: () => Promise<String>;
  addressArabic: () => Promise<String>;
  apiKey: () => Promise<String>;
  city: <T = CityPromise>() => T;
  countryId: <T = CountryPromise>() => T;
  email: () => Promise<String>;
  hospital: () => Promise<String>;
  hospitalArabic: () => Promise<String>;
  doctors: <T = FragmentableArray<Doctor>>(args?: {
    where?: DoctorWhereInput;
    orderBy?: DoctorOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  language: () => Promise<String>;
  latitude: () => Promise<String>;
  location: () => Promise<String>;
  logo: () => Promise<String>;
  longitude: () => Promise<String>;
  password: () => Promise<String>;
  phone: () => Promise<String>;
  phone1: () => Promise<String>;
  status: () => Promise<Int>;
  type: () => Promise<String>;
  uniqeId: () => Promise<String>;
  insurances: <T = FragmentableArray<Insurance>>(args?: {
    where?: InsuranceWhereInput;
    orderBy?: InsuranceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  createdDate: () => Promise<DateTimeOutput>;
}

export interface City {
  id: Int;
  city?: String;
  cityArabic: String;
  countryId?: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface CityPromise extends Promise<City>, Fragmentable {
  id: () => Promise<Int>;
  city: () => Promise<String>;
  cityArabic: () => Promise<String>;
  countryId: () => Promise<Int>;
  hospital: <T = FragmentableArray<Hospital>>(args?: {
    where?: HospitalWhereInput;
    orderBy?: HospitalOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CitySubscription
  extends Promise<AsyncIterator<City>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  city: () => Promise<AsyncIterator<String>>;
  cityArabic: () => Promise<AsyncIterator<String>>;
  countryId: () => Promise<AsyncIterator<Int>>;
  hospital: <T = Promise<AsyncIterator<HospitalSubscription>>>(args?: {
    where?: HospitalWhereInput;
    orderBy?: HospitalOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CityNullablePromise
  extends Promise<City | null>,
    Fragmentable {
  id: () => Promise<Int>;
  city: () => Promise<String>;
  cityArabic: () => Promise<String>;
  countryId: () => Promise<Int>;
  hospital: <T = FragmentableArray<Hospital>>(args?: {
    where?: HospitalWhereInput;
    orderBy?: HospitalOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface Country {
  id: Int;
  country?: String;
  countryArabic: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface CountryPromise extends Promise<Country>, Fragmentable {
  id: () => Promise<Int>;
  country: () => Promise<String>;
  countryArabic: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CountrySubscription
  extends Promise<AsyncIterator<Country>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  country: () => Promise<AsyncIterator<String>>;
  countryArabic: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CountryNullablePromise
  extends Promise<Country | null>,
    Fragmentable {
  id: () => Promise<Int>;
  country: () => Promise<String>;
  countryArabic: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface Insurance {
  id: Int;
  countryId: Int;
  insurance?: String;
  insuranceArabic?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface InsurancePromise extends Promise<Insurance>, Fragmentable {
  id: () => Promise<Int>;
  countryId: () => Promise<Int>;
  hospitals: <T = FragmentableArray<Hospital>>(args?: {
    where?: HospitalWhereInput;
    orderBy?: HospitalOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  insurance: () => Promise<String>;
  insuranceArabic: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface InsuranceSubscription
  extends Promise<AsyncIterator<Insurance>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  countryId: () => Promise<AsyncIterator<Int>>;
  hospitals: <T = Promise<AsyncIterator<HospitalSubscription>>>(args?: {
    where?: HospitalWhereInput;
    orderBy?: HospitalOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  insurance: () => Promise<AsyncIterator<String>>;
  insuranceArabic: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface InsuranceNullablePromise
  extends Promise<Insurance | null>,
    Fragmentable {
  id: () => Promise<Int>;
  countryId: () => Promise<Int>;
  hospitals: <T = FragmentableArray<Hospital>>(args?: {
    where?: HospitalWhereInput;
    orderBy?: HospitalOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  insurance: () => Promise<String>;
  insuranceArabic: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface DoctorSheduleTime {
  id: Int;
  drSheduleId?: Int;
  scheduleTime?: Int;
  status?: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface DoctorSheduleTimePromise
  extends Promise<DoctorSheduleTime>,
    Fragmentable {
  id: () => Promise<Int>;
  drSheduleId: () => Promise<Int>;
  scheduleTime: () => Promise<Int>;
  status: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface DoctorSheduleTimeSubscription
  extends Promise<AsyncIterator<DoctorSheduleTime>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  drSheduleId: () => Promise<AsyncIterator<Int>>;
  scheduleTime: () => Promise<AsyncIterator<Int>>;
  status: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface DoctorSheduleTimeNullablePromise
  extends Promise<DoctorSheduleTime | null>,
    Fragmentable {
  id: () => Promise<Int>;
  drSheduleId: () => Promise<Int>;
  scheduleTime: () => Promise<Int>;
  status: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface OptTime {
  id: Int;
  fifteenMins?: String;
  thirtyMins?: String;
  twentyMins?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface OptTimePromise extends Promise<OptTime>, Fragmentable {
  id: () => Promise<Int>;
  fifteenMins: () => Promise<String>;
  thirtyMins: () => Promise<String>;
  twentyMins: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface OptTimeSubscription
  extends Promise<AsyncIterator<OptTime>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  fifteenMins: () => Promise<AsyncIterator<String>>;
  thirtyMins: () => Promise<AsyncIterator<String>>;
  twentyMins: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface OptTimeNullablePromise
  extends Promise<OptTime | null>,
    Fragmentable {
  id: () => Promise<Int>;
  fifteenMins: () => Promise<String>;
  thirtyMins: () => Promise<String>;
  twentyMins: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface Patient {
  id: Int;
  age: Int;
  apiKey: String;
  createdDate: DateTimeOutput;
  dob?: String;
  email?: String;
  gender?: String;
  lastAction: String;
  lastSeen: DateTimeOutput;
  mailSubs?: Int;
  mobile?: String;
  name?: String;
  password?: String;
  status: Int;
  uniqeId: String;
}

export interface PatientPromise extends Promise<Patient>, Fragmentable {
  id: () => Promise<Int>;
  age: () => Promise<Int>;
  apiKey: () => Promise<String>;
  createdDate: () => Promise<DateTimeOutput>;
  dob: () => Promise<String>;
  email: () => Promise<String>;
  gender: () => Promise<String>;
  lastAction: () => Promise<String>;
  lastSeen: () => Promise<DateTimeOutput>;
  mailSubs: () => Promise<Int>;
  mobile: () => Promise<String>;
  name: () => Promise<String>;
  password: () => Promise<String>;
  status: () => Promise<Int>;
  uniqeId: () => Promise<String>;
}

export interface PatientSubscription
  extends Promise<AsyncIterator<Patient>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  age: () => Promise<AsyncIterator<Int>>;
  apiKey: () => Promise<AsyncIterator<String>>;
  createdDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  dob: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  gender: () => Promise<AsyncIterator<String>>;
  lastAction: () => Promise<AsyncIterator<String>>;
  lastSeen: () => Promise<AsyncIterator<DateTimeOutput>>;
  mailSubs: () => Promise<AsyncIterator<Int>>;
  mobile: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  status: () => Promise<AsyncIterator<Int>>;
  uniqeId: () => Promise<AsyncIterator<String>>;
}

export interface PatientNullablePromise
  extends Promise<Patient | null>,
    Fragmentable {
  id: () => Promise<Int>;
  age: () => Promise<Int>;
  apiKey: () => Promise<String>;
  createdDate: () => Promise<DateTimeOutput>;
  dob: () => Promise<String>;
  email: () => Promise<String>;
  gender: () => Promise<String>;
  lastAction: () => Promise<String>;
  lastSeen: () => Promise<DateTimeOutput>;
  mailSubs: () => Promise<Int>;
  mobile: () => Promise<String>;
  name: () => Promise<String>;
  password: () => Promise<String>;
  status: () => Promise<Int>;
  uniqeId: () => Promise<String>;
}

export interface SheduleTime {
  id: Int;
  drSheduleId?: Int;
  scheduleFullDate: Int;
  sheduleTime?: String;
  status?: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface SheduleTimePromise extends Promise<SheduleTime>, Fragmentable {
  id: () => Promise<Int>;
  drSheduleId: () => Promise<Int>;
  scheduleFullDate: () => Promise<Int>;
  sheduleTime: () => Promise<String>;
  status: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface SheduleTimeSubscription
  extends Promise<AsyncIterator<SheduleTime>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  drSheduleId: () => Promise<AsyncIterator<Int>>;
  scheduleFullDate: () => Promise<AsyncIterator<Int>>;
  sheduleTime: () => Promise<AsyncIterator<String>>;
  status: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface SheduleTimeNullablePromise
  extends Promise<SheduleTime | null>,
    Fragmentable {
  id: () => Promise<Int>;
  drSheduleId: () => Promise<Int>;
  scheduleFullDate: () => Promise<Int>;
  sheduleTime: () => Promise<String>;
  status: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface AppointmentConnection {
  pageInfo: PageInfo;
  edges: AppointmentEdge[];
}

export interface AppointmentConnectionPromise
  extends Promise<AppointmentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AppointmentEdge>>() => T;
  aggregate: <T = AggregateAppointmentPromise>() => T;
}

export interface AppointmentConnectionSubscription
  extends Promise<AsyncIterator<AppointmentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AppointmentEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAppointmentSubscription>() => T;
}

export interface AppointmentEdge {
  node: Appointment;
  cursor: String;
}

export interface AppointmentEdgePromise
  extends Promise<AppointmentEdge>,
    Fragmentable {
  node: <T = AppointmentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface AppointmentEdgeSubscription
  extends Promise<AsyncIterator<AppointmentEdge>>,
    Fragmentable {
  node: <T = AppointmentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateAppointment {
  count: Int;
}

export interface AggregateAppointmentPromise
  extends Promise<AggregateAppointment>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAppointmentSubscription
  extends Promise<AsyncIterator<AggregateAppointment>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Blog {
  id: Int;
  bannerImage: String;
  createdDate: DateTimeOutput;
  name: String;
  status: Int;
  updatedAt?: DateTimeOutput;
}

export interface BlogPromise extends Promise<Blog>, Fragmentable {
  id: () => Promise<Int>;
  bannerImage: () => Promise<String>;
  createdDate: () => Promise<DateTimeOutput>;
  hospitalId: <T = HospitalPromise>() => T;
  name: () => Promise<String>;
  status: () => Promise<Int>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface BlogSubscription
  extends Promise<AsyncIterator<Blog>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  bannerImage: () => Promise<AsyncIterator<String>>;
  createdDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  hospitalId: <T = HospitalSubscription>() => T;
  name: () => Promise<AsyncIterator<String>>;
  status: () => Promise<AsyncIterator<Int>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface BlogNullablePromise
  extends Promise<Blog | null>,
    Fragmentable {
  id: () => Promise<Int>;
  bannerImage: () => Promise<String>;
  createdDate: () => Promise<DateTimeOutput>;
  hospitalId: <T = HospitalPromise>() => T;
  name: () => Promise<String>;
  status: () => Promise<Int>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface BlogConnection {
  pageInfo: PageInfo;
  edges: BlogEdge[];
}

export interface BlogConnectionPromise
  extends Promise<BlogConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<BlogEdge>>() => T;
  aggregate: <T = AggregateBlogPromise>() => T;
}

export interface BlogConnectionSubscription
  extends Promise<AsyncIterator<BlogConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<BlogEdgeSubscription>>>() => T;
  aggregate: <T = AggregateBlogSubscription>() => T;
}

export interface BlogEdge {
  node: Blog;
  cursor: String;
}

export interface BlogEdgePromise extends Promise<BlogEdge>, Fragmentable {
  node: <T = BlogPromise>() => T;
  cursor: () => Promise<String>;
}

export interface BlogEdgeSubscription
  extends Promise<AsyncIterator<BlogEdge>>,
    Fragmentable {
  node: <T = BlogSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateBlog {
  count: Int;
}

export interface AggregateBlogPromise
  extends Promise<AggregateBlog>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBlogSubscription
  extends Promise<AsyncIterator<AggregateBlog>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BlogComment {
  id: Int;
  commentator: Int;
  commentatorName: String;
  comments: String;
  logCreated: DateTimeOutput;
  updatedAt?: DateTimeOutput;
}

export interface BlogCommentPromise extends Promise<BlogComment>, Fragmentable {
  id: () => Promise<Int>;
  commentator: () => Promise<Int>;
  commentatorName: () => Promise<String>;
  comments: () => Promise<String>;
  logCreated: () => Promise<DateTimeOutput>;
  postId: <T = BlogPostPromise>() => T;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface BlogCommentSubscription
  extends Promise<AsyncIterator<BlogComment>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  commentator: () => Promise<AsyncIterator<Int>>;
  commentatorName: () => Promise<AsyncIterator<String>>;
  comments: () => Promise<AsyncIterator<String>>;
  logCreated: () => Promise<AsyncIterator<DateTimeOutput>>;
  postId: <T = BlogPostSubscription>() => T;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface BlogCommentNullablePromise
  extends Promise<BlogComment | null>,
    Fragmentable {
  id: () => Promise<Int>;
  commentator: () => Promise<Int>;
  commentatorName: () => Promise<String>;
  comments: () => Promise<String>;
  logCreated: () => Promise<DateTimeOutput>;
  postId: <T = BlogPostPromise>() => T;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface BlogPost {
  id: Int;
  logCreated: DateTimeOutput;
  postContent: String;
  postTitle: String;
  status: Int;
  totalViewers: Int;
  updatedAt?: DateTimeOutput;
}

export interface BlogPostPromise extends Promise<BlogPost>, Fragmentable {
  id: () => Promise<Int>;
  blogId: <T = BlogPromise>() => T;
  hospitalId: <T = HospitalPromise>() => T;
  logCreated: () => Promise<DateTimeOutput>;
  postContent: () => Promise<String>;
  postTitle: () => Promise<String>;
  status: () => Promise<Int>;
  totalViewers: () => Promise<Int>;
  images: <T = FragmentableArray<PostImage>>(args?: {
    where?: PostImageWhereInput;
    orderBy?: PostImageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface BlogPostSubscription
  extends Promise<AsyncIterator<BlogPost>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  blogId: <T = BlogSubscription>() => T;
  hospitalId: <T = HospitalSubscription>() => T;
  logCreated: () => Promise<AsyncIterator<DateTimeOutput>>;
  postContent: () => Promise<AsyncIterator<String>>;
  postTitle: () => Promise<AsyncIterator<String>>;
  status: () => Promise<AsyncIterator<Int>>;
  totalViewers: () => Promise<AsyncIterator<Int>>;
  images: <T = Promise<AsyncIterator<PostImageSubscription>>>(args?: {
    where?: PostImageWhereInput;
    orderBy?: PostImageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface BlogPostNullablePromise
  extends Promise<BlogPost | null>,
    Fragmentable {
  id: () => Promise<Int>;
  blogId: <T = BlogPromise>() => T;
  hospitalId: <T = HospitalPromise>() => T;
  logCreated: () => Promise<DateTimeOutput>;
  postContent: () => Promise<String>;
  postTitle: () => Promise<String>;
  status: () => Promise<Int>;
  totalViewers: () => Promise<Int>;
  images: <T = FragmentableArray<PostImage>>(args?: {
    where?: PostImageWhereInput;
    orderBy?: PostImageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PostImage {
  id: Int;
  isDefault: Int;
  pic: String;
  createdAt?: DateTimeOutput;
  updatedAt?: DateTimeOutput;
}

export interface PostImagePromise extends Promise<PostImage>, Fragmentable {
  id: () => Promise<Int>;
  isDefault: () => Promise<Int>;
  pic: () => Promise<String>;
  postId: <T = BlogPostPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PostImageSubscription
  extends Promise<AsyncIterator<PostImage>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  isDefault: () => Promise<AsyncIterator<Int>>;
  pic: () => Promise<AsyncIterator<String>>;
  postId: <T = BlogPostSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PostImageNullablePromise
  extends Promise<PostImage | null>,
    Fragmentable {
  id: () => Promise<Int>;
  isDefault: () => Promise<Int>;
  pic: () => Promise<String>;
  postId: <T = BlogPostPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface BlogCommentConnection {
  pageInfo: PageInfo;
  edges: BlogCommentEdge[];
}

export interface BlogCommentConnectionPromise
  extends Promise<BlogCommentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<BlogCommentEdge>>() => T;
  aggregate: <T = AggregateBlogCommentPromise>() => T;
}

export interface BlogCommentConnectionSubscription
  extends Promise<AsyncIterator<BlogCommentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<BlogCommentEdgeSubscription>>>() => T;
  aggregate: <T = AggregateBlogCommentSubscription>() => T;
}

export interface BlogCommentEdge {
  node: BlogComment;
  cursor: String;
}

export interface BlogCommentEdgePromise
  extends Promise<BlogCommentEdge>,
    Fragmentable {
  node: <T = BlogCommentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface BlogCommentEdgeSubscription
  extends Promise<AsyncIterator<BlogCommentEdge>>,
    Fragmentable {
  node: <T = BlogCommentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateBlogComment {
  count: Int;
}

export interface AggregateBlogCommentPromise
  extends Promise<AggregateBlogComment>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBlogCommentSubscription
  extends Promise<AsyncIterator<AggregateBlogComment>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BlogPostConnection {
  pageInfo: PageInfo;
  edges: BlogPostEdge[];
}

export interface BlogPostConnectionPromise
  extends Promise<BlogPostConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<BlogPostEdge>>() => T;
  aggregate: <T = AggregateBlogPostPromise>() => T;
}

export interface BlogPostConnectionSubscription
  extends Promise<AsyncIterator<BlogPostConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<BlogPostEdgeSubscription>>>() => T;
  aggregate: <T = AggregateBlogPostSubscription>() => T;
}

export interface BlogPostEdge {
  node: BlogPost;
  cursor: String;
}

export interface BlogPostEdgePromise
  extends Promise<BlogPostEdge>,
    Fragmentable {
  node: <T = BlogPostPromise>() => T;
  cursor: () => Promise<String>;
}

export interface BlogPostEdgeSubscription
  extends Promise<AsyncIterator<BlogPostEdge>>,
    Fragmentable {
  node: <T = BlogPostSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateBlogPost {
  count: Int;
}

export interface AggregateBlogPostPromise
  extends Promise<AggregateBlogPost>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBlogPostSubscription
  extends Promise<AsyncIterator<AggregateBlogPost>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CityConnection {
  pageInfo: PageInfo;
  edges: CityEdge[];
}

export interface CityConnectionPromise
  extends Promise<CityConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CityEdge>>() => T;
  aggregate: <T = AggregateCityPromise>() => T;
}

export interface CityConnectionSubscription
  extends Promise<AsyncIterator<CityConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CityEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCitySubscription>() => T;
}

export interface CityEdge {
  node: City;
  cursor: String;
}

export interface CityEdgePromise extends Promise<CityEdge>, Fragmentable {
  node: <T = CityPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CityEdgeSubscription
  extends Promise<AsyncIterator<CityEdge>>,
    Fragmentable {
  node: <T = CitySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCity {
  count: Int;
}

export interface AggregateCityPromise
  extends Promise<AggregateCity>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCitySubscription
  extends Promise<AsyncIterator<AggregateCity>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ContactUs {
  id: Int;
  address: String;
  email: String;
  lat: String;
  lon: String;
  phone: String;
  pobox: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ContactUsPromise extends Promise<ContactUs>, Fragmentable {
  id: () => Promise<Int>;
  address: () => Promise<String>;
  email: () => Promise<String>;
  lat: () => Promise<String>;
  lon: () => Promise<String>;
  phone: () => Promise<String>;
  pobox: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ContactUsSubscription
  extends Promise<AsyncIterator<ContactUs>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  address: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  lat: () => Promise<AsyncIterator<String>>;
  lon: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
  pobox: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ContactUsNullablePromise
  extends Promise<ContactUs | null>,
    Fragmentable {
  id: () => Promise<Int>;
  address: () => Promise<String>;
  email: () => Promise<String>;
  lat: () => Promise<String>;
  lon: () => Promise<String>;
  phone: () => Promise<String>;
  pobox: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ContactUsConnection {
  pageInfo: PageInfo;
  edges: ContactUsEdge[];
}

export interface ContactUsConnectionPromise
  extends Promise<ContactUsConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ContactUsEdge>>() => T;
  aggregate: <T = AggregateContactUsPromise>() => T;
}

export interface ContactUsConnectionSubscription
  extends Promise<AsyncIterator<ContactUsConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ContactUsEdgeSubscription>>>() => T;
  aggregate: <T = AggregateContactUsSubscription>() => T;
}

export interface ContactUsEdge {
  node: ContactUs;
  cursor: String;
}

export interface ContactUsEdgePromise
  extends Promise<ContactUsEdge>,
    Fragmentable {
  node: <T = ContactUsPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ContactUsEdgeSubscription
  extends Promise<AsyncIterator<ContactUsEdge>>,
    Fragmentable {
  node: <T = ContactUsSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateContactUs {
  count: Int;
}

export interface AggregateContactUsPromise
  extends Promise<AggregateContactUs>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateContactUsSubscription
  extends Promise<AsyncIterator<AggregateContactUs>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CountryConnection {
  pageInfo: PageInfo;
  edges: CountryEdge[];
}

export interface CountryConnectionPromise
  extends Promise<CountryConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CountryEdge>>() => T;
  aggregate: <T = AggregateCountryPromise>() => T;
}

export interface CountryConnectionSubscription
  extends Promise<AsyncIterator<CountryConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CountryEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCountrySubscription>() => T;
}

export interface CountryEdge {
  node: Country;
  cursor: String;
}

export interface CountryEdgePromise extends Promise<CountryEdge>, Fragmentable {
  node: <T = CountryPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CountryEdgeSubscription
  extends Promise<AsyncIterator<CountryEdge>>,
    Fragmentable {
  node: <T = CountrySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCountry {
  count: Int;
}

export interface AggregateCountryPromise
  extends Promise<AggregateCountry>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCountrySubscription
  extends Promise<AsyncIterator<AggregateCountry>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface DiseaseConnection {
  pageInfo: PageInfo;
  edges: DiseaseEdge[];
}

export interface DiseaseConnectionPromise
  extends Promise<DiseaseConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<DiseaseEdge>>() => T;
  aggregate: <T = AggregateDiseasePromise>() => T;
}

export interface DiseaseConnectionSubscription
  extends Promise<AsyncIterator<DiseaseConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<DiseaseEdgeSubscription>>>() => T;
  aggregate: <T = AggregateDiseaseSubscription>() => T;
}

export interface DiseaseEdge {
  node: Disease;
  cursor: String;
}

export interface DiseaseEdgePromise extends Promise<DiseaseEdge>, Fragmentable {
  node: <T = DiseasePromise>() => T;
  cursor: () => Promise<String>;
}

export interface DiseaseEdgeSubscription
  extends Promise<AsyncIterator<DiseaseEdge>>,
    Fragmentable {
  node: <T = DiseaseSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateDisease {
  count: Int;
}

export interface AggregateDiseasePromise
  extends Promise<AggregateDisease>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateDiseaseSubscription
  extends Promise<AsyncIterator<AggregateDisease>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface DiseaseCovered {
  id: Int;
  diseaseId?: Int;
  insuranceCatId?: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface DiseaseCoveredPromise
  extends Promise<DiseaseCovered>,
    Fragmentable {
  id: () => Promise<Int>;
  diseaseId: () => Promise<Int>;
  insuranceCatId: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface DiseaseCoveredSubscription
  extends Promise<AsyncIterator<DiseaseCovered>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  diseaseId: () => Promise<AsyncIterator<Int>>;
  insuranceCatId: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface DiseaseCoveredNullablePromise
  extends Promise<DiseaseCovered | null>,
    Fragmentable {
  id: () => Promise<Int>;
  diseaseId: () => Promise<Int>;
  insuranceCatId: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface DiseaseCoveredConnection {
  pageInfo: PageInfo;
  edges: DiseaseCoveredEdge[];
}

export interface DiseaseCoveredConnectionPromise
  extends Promise<DiseaseCoveredConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<DiseaseCoveredEdge>>() => T;
  aggregate: <T = AggregateDiseaseCoveredPromise>() => T;
}

export interface DiseaseCoveredConnectionSubscription
  extends Promise<AsyncIterator<DiseaseCoveredConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<DiseaseCoveredEdgeSubscription>>>() => T;
  aggregate: <T = AggregateDiseaseCoveredSubscription>() => T;
}

export interface DiseaseCoveredEdge {
  node: DiseaseCovered;
  cursor: String;
}

export interface DiseaseCoveredEdgePromise
  extends Promise<DiseaseCoveredEdge>,
    Fragmentable {
  node: <T = DiseaseCoveredPromise>() => T;
  cursor: () => Promise<String>;
}

export interface DiseaseCoveredEdgeSubscription
  extends Promise<AsyncIterator<DiseaseCoveredEdge>>,
    Fragmentable {
  node: <T = DiseaseCoveredSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateDiseaseCovered {
  count: Int;
}

export interface AggregateDiseaseCoveredPromise
  extends Promise<AggregateDiseaseCovered>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateDiseaseCoveredSubscription
  extends Promise<AsyncIterator<AggregateDiseaseCovered>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface DoctorConnection {
  pageInfo: PageInfo;
  edges: DoctorEdge[];
}

export interface DoctorConnectionPromise
  extends Promise<DoctorConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<DoctorEdge>>() => T;
  aggregate: <T = AggregateDoctorPromise>() => T;
}

export interface DoctorConnectionSubscription
  extends Promise<AsyncIterator<DoctorConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<DoctorEdgeSubscription>>>() => T;
  aggregate: <T = AggregateDoctorSubscription>() => T;
}

export interface DoctorEdge {
  node: Doctor;
  cursor: String;
}

export interface DoctorEdgePromise extends Promise<DoctorEdge>, Fragmentable {
  node: <T = DoctorPromise>() => T;
  cursor: () => Promise<String>;
}

export interface DoctorEdgeSubscription
  extends Promise<AsyncIterator<DoctorEdge>>,
    Fragmentable {
  node: <T = DoctorSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateDoctor {
  count: Int;
}

export interface AggregateDoctorPromise
  extends Promise<AggregateDoctor>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateDoctorSubscription
  extends Promise<AsyncIterator<AggregateDoctor>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface DoctorOld {
  id: Int;
  apiKey: String;
  createdDate: DateTimeOutput;
  designation: String;
  doctorCv: String;
  email?: String;
  gender: String;
  mohcard?: String;
  mohId: String;
  name?: String;
  nameArabic: String;
  password: String;
  phone?: String;
  fees?: String;
  picture?: String;
  status?: Int;
  updatedAt: DateTimeOutput;
}

export interface DoctorOldPromise extends Promise<DoctorOld>, Fragmentable {
  id: () => Promise<Int>;
  apiKey: () => Promise<String>;
  createdDate: () => Promise<DateTimeOutput>;
  designation: () => Promise<String>;
  doctorCv: () => Promise<String>;
  doctorsRating: <T = FragmentableArray<DoctorsRating>>(args?: {
    where?: DoctorsRatingWhereInput;
    orderBy?: DoctorsRatingOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  email: () => Promise<String>;
  gender: () => Promise<String>;
  mohcard: () => Promise<String>;
  mohId: () => Promise<String>;
  name: () => Promise<String>;
  nameArabic: () => Promise<String>;
  password: () => Promise<String>;
  phone: () => Promise<String>;
  fees: () => Promise<String>;
  picture: () => Promise<String>;
  speciality: <T = SpecialityPromise>() => T;
  status: () => Promise<Int>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface DoctorOldSubscription
  extends Promise<AsyncIterator<DoctorOld>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  apiKey: () => Promise<AsyncIterator<String>>;
  createdDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  designation: () => Promise<AsyncIterator<String>>;
  doctorCv: () => Promise<AsyncIterator<String>>;
  doctorsRating: <
    T = Promise<AsyncIterator<DoctorsRatingSubscription>>
  >(args?: {
    where?: DoctorsRatingWhereInput;
    orderBy?: DoctorsRatingOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  email: () => Promise<AsyncIterator<String>>;
  gender: () => Promise<AsyncIterator<String>>;
  mohcard: () => Promise<AsyncIterator<String>>;
  mohId: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  nameArabic: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
  fees: () => Promise<AsyncIterator<String>>;
  picture: () => Promise<AsyncIterator<String>>;
  speciality: <T = SpecialitySubscription>() => T;
  status: () => Promise<AsyncIterator<Int>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface DoctorOldNullablePromise
  extends Promise<DoctorOld | null>,
    Fragmentable {
  id: () => Promise<Int>;
  apiKey: () => Promise<String>;
  createdDate: () => Promise<DateTimeOutput>;
  designation: () => Promise<String>;
  doctorCv: () => Promise<String>;
  doctorsRating: <T = FragmentableArray<DoctorsRating>>(args?: {
    where?: DoctorsRatingWhereInput;
    orderBy?: DoctorsRatingOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  email: () => Promise<String>;
  gender: () => Promise<String>;
  mohcard: () => Promise<String>;
  mohId: () => Promise<String>;
  name: () => Promise<String>;
  nameArabic: () => Promise<String>;
  password: () => Promise<String>;
  phone: () => Promise<String>;
  fees: () => Promise<String>;
  picture: () => Promise<String>;
  speciality: <T = SpecialityPromise>() => T;
  status: () => Promise<Int>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface DoctorsRating {
  id: Int;
  rating?: String;
  systemIp: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface DoctorsRatingPromise
  extends Promise<DoctorsRating>,
    Fragmentable {
  id: () => Promise<Int>;
  doctors: <T = DoctorOldPromise>() => T;
  rating: () => Promise<String>;
  systemIp: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface DoctorsRatingSubscription
  extends Promise<AsyncIterator<DoctorsRating>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  doctors: <T = DoctorOldSubscription>() => T;
  rating: () => Promise<AsyncIterator<String>>;
  systemIp: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface DoctorsRatingNullablePromise
  extends Promise<DoctorsRating | null>,
    Fragmentable {
  id: () => Promise<Int>;
  doctors: <T = DoctorOldPromise>() => T;
  rating: () => Promise<String>;
  systemIp: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface DoctorOldConnection {
  pageInfo: PageInfo;
  edges: DoctorOldEdge[];
}

export interface DoctorOldConnectionPromise
  extends Promise<DoctorOldConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<DoctorOldEdge>>() => T;
  aggregate: <T = AggregateDoctorOldPromise>() => T;
}

export interface DoctorOldConnectionSubscription
  extends Promise<AsyncIterator<DoctorOldConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<DoctorOldEdgeSubscription>>>() => T;
  aggregate: <T = AggregateDoctorOldSubscription>() => T;
}

export interface DoctorOldEdge {
  node: DoctorOld;
  cursor: String;
}

export interface DoctorOldEdgePromise
  extends Promise<DoctorOldEdge>,
    Fragmentable {
  node: <T = DoctorOldPromise>() => T;
  cursor: () => Promise<String>;
}

export interface DoctorOldEdgeSubscription
  extends Promise<AsyncIterator<DoctorOldEdge>>,
    Fragmentable {
  node: <T = DoctorOldSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateDoctorOld {
  count: Int;
}

export interface AggregateDoctorOldPromise
  extends Promise<AggregateDoctorOld>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateDoctorOldSubscription
  extends Promise<AsyncIterator<AggregateDoctorOld>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface DoctorShedule {
  id: Int;
  date?: Int;
  doctorId?: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface DoctorShedulePromise
  extends Promise<DoctorShedule>,
    Fragmentable {
  id: () => Promise<Int>;
  date: () => Promise<Int>;
  doctorId: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface DoctorSheduleSubscription
  extends Promise<AsyncIterator<DoctorShedule>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  date: () => Promise<AsyncIterator<Int>>;
  doctorId: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface DoctorSheduleNullablePromise
  extends Promise<DoctorShedule | null>,
    Fragmentable {
  id: () => Promise<Int>;
  date: () => Promise<Int>;
  doctorId: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface DoctorSheduleConnection {
  pageInfo: PageInfo;
  edges: DoctorSheduleEdge[];
}

export interface DoctorSheduleConnectionPromise
  extends Promise<DoctorSheduleConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<DoctorSheduleEdge>>() => T;
  aggregate: <T = AggregateDoctorShedulePromise>() => T;
}

export interface DoctorSheduleConnectionSubscription
  extends Promise<AsyncIterator<DoctorSheduleConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<DoctorSheduleEdgeSubscription>>>() => T;
  aggregate: <T = AggregateDoctorSheduleSubscription>() => T;
}

export interface DoctorSheduleEdge {
  node: DoctorShedule;
  cursor: String;
}

export interface DoctorSheduleEdgePromise
  extends Promise<DoctorSheduleEdge>,
    Fragmentable {
  node: <T = DoctorShedulePromise>() => T;
  cursor: () => Promise<String>;
}

export interface DoctorSheduleEdgeSubscription
  extends Promise<AsyncIterator<DoctorSheduleEdge>>,
    Fragmentable {
  node: <T = DoctorSheduleSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateDoctorShedule {
  count: Int;
}

export interface AggregateDoctorShedulePromise
  extends Promise<AggregateDoctorShedule>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateDoctorSheduleSubscription
  extends Promise<AsyncIterator<AggregateDoctorShedule>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface DoctorSheduleTimeConnection {
  pageInfo: PageInfo;
  edges: DoctorSheduleTimeEdge[];
}

export interface DoctorSheduleTimeConnectionPromise
  extends Promise<DoctorSheduleTimeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<DoctorSheduleTimeEdge>>() => T;
  aggregate: <T = AggregateDoctorSheduleTimePromise>() => T;
}

export interface DoctorSheduleTimeConnectionSubscription
  extends Promise<AsyncIterator<DoctorSheduleTimeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<DoctorSheduleTimeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateDoctorSheduleTimeSubscription>() => T;
}

export interface DoctorSheduleTimeEdge {
  node: DoctorSheduleTime;
  cursor: String;
}

export interface DoctorSheduleTimeEdgePromise
  extends Promise<DoctorSheduleTimeEdge>,
    Fragmentable {
  node: <T = DoctorSheduleTimePromise>() => T;
  cursor: () => Promise<String>;
}

export interface DoctorSheduleTimeEdgeSubscription
  extends Promise<AsyncIterator<DoctorSheduleTimeEdge>>,
    Fragmentable {
  node: <T = DoctorSheduleTimeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateDoctorSheduleTime {
  count: Int;
}

export interface AggregateDoctorSheduleTimePromise
  extends Promise<AggregateDoctorSheduleTime>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateDoctorSheduleTimeSubscription
  extends Promise<AsyncIterator<AggregateDoctorSheduleTime>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface DoctorsRatingConnection {
  pageInfo: PageInfo;
  edges: DoctorsRatingEdge[];
}

export interface DoctorsRatingConnectionPromise
  extends Promise<DoctorsRatingConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<DoctorsRatingEdge>>() => T;
  aggregate: <T = AggregateDoctorsRatingPromise>() => T;
}

export interface DoctorsRatingConnectionSubscription
  extends Promise<AsyncIterator<DoctorsRatingConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<DoctorsRatingEdgeSubscription>>>() => T;
  aggregate: <T = AggregateDoctorsRatingSubscription>() => T;
}

export interface DoctorsRatingEdge {
  node: DoctorsRating;
  cursor: String;
}

export interface DoctorsRatingEdgePromise
  extends Promise<DoctorsRatingEdge>,
    Fragmentable {
  node: <T = DoctorsRatingPromise>() => T;
  cursor: () => Promise<String>;
}

export interface DoctorsRatingEdgeSubscription
  extends Promise<AsyncIterator<DoctorsRatingEdge>>,
    Fragmentable {
  node: <T = DoctorsRatingSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateDoctorsRating {
  count: Int;
}

export interface AggregateDoctorsRatingPromise
  extends Promise<AggregateDoctorsRating>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateDoctorsRatingSubscription
  extends Promise<AsyncIterator<AggregateDoctorsRating>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface DrShedule {
  id: Int;
  date?: DateTimeOutput;
  doctorId?: Int;
  hospitalId?: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface DrShedulePromise extends Promise<DrShedule>, Fragmentable {
  id: () => Promise<Int>;
  date: () => Promise<DateTimeOutput>;
  doctorId: () => Promise<Int>;
  hospitalId: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface DrSheduleSubscription
  extends Promise<AsyncIterator<DrShedule>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  doctorId: () => Promise<AsyncIterator<Int>>;
  hospitalId: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface DrSheduleNullablePromise
  extends Promise<DrShedule | null>,
    Fragmentable {
  id: () => Promise<Int>;
  date: () => Promise<DateTimeOutput>;
  doctorId: () => Promise<Int>;
  hospitalId: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface DrSheduleConnection {
  pageInfo: PageInfo;
  edges: DrSheduleEdge[];
}

export interface DrSheduleConnectionPromise
  extends Promise<DrSheduleConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<DrSheduleEdge>>() => T;
  aggregate: <T = AggregateDrShedulePromise>() => T;
}

export interface DrSheduleConnectionSubscription
  extends Promise<AsyncIterator<DrSheduleConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<DrSheduleEdgeSubscription>>>() => T;
  aggregate: <T = AggregateDrSheduleSubscription>() => T;
}

export interface DrSheduleEdge {
  node: DrShedule;
  cursor: String;
}

export interface DrSheduleEdgePromise
  extends Promise<DrSheduleEdge>,
    Fragmentable {
  node: <T = DrShedulePromise>() => T;
  cursor: () => Promise<String>;
}

export interface DrSheduleEdgeSubscription
  extends Promise<AsyncIterator<DrSheduleEdge>>,
    Fragmentable {
  node: <T = DrSheduleSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateDrShedule {
  count: Int;
}

export interface AggregateDrShedulePromise
  extends Promise<AggregateDrShedule>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateDrSheduleSubscription
  extends Promise<AsyncIterator<AggregateDrShedule>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface EmailSubscription {
  id: Int;
  email: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface EmailSubscriptionPromise
  extends Promise<EmailSubscription>,
    Fragmentable {
  id: () => Promise<Int>;
  email: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface EmailSubscriptionSubscription
  extends Promise<AsyncIterator<EmailSubscription>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  email: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface EmailSubscriptionNullablePromise
  extends Promise<EmailSubscription | null>,
    Fragmentable {
  id: () => Promise<Int>;
  email: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface EmailSubscriptionConnection {
  pageInfo: PageInfo;
  edges: EmailSubscriptionEdge[];
}

export interface EmailSubscriptionConnectionPromise
  extends Promise<EmailSubscriptionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<EmailSubscriptionEdge>>() => T;
  aggregate: <T = AggregateEmailSubscriptionPromise>() => T;
}

export interface EmailSubscriptionConnectionSubscription
  extends Promise<AsyncIterator<EmailSubscriptionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<EmailSubscriptionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateEmailSubscriptionSubscription>() => T;
}

export interface EmailSubscriptionEdge {
  node: EmailSubscription;
  cursor: String;
}

export interface EmailSubscriptionEdgePromise
  extends Promise<EmailSubscriptionEdge>,
    Fragmentable {
  node: <T = EmailSubscriptionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface EmailSubscriptionEdgeSubscription
  extends Promise<AsyncIterator<EmailSubscriptionEdge>>,
    Fragmentable {
  node: <T = EmailSubscriptionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateEmailSubscription {
  count: Int;
}

export interface AggregateEmailSubscriptionPromise
  extends Promise<AggregateEmailSubscription>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateEmailSubscriptionSubscription
  extends Promise<AsyncIterator<AggregateEmailSubscription>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Facility {
  id: Int;
  facility?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface FacilityPromise extends Promise<Facility>, Fragmentable {
  id: () => Promise<Int>;
  facility: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface FacilitySubscription
  extends Promise<AsyncIterator<Facility>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  facility: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface FacilityNullablePromise
  extends Promise<Facility | null>,
    Fragmentable {
  id: () => Promise<Int>;
  facility: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface FacilityConnection {
  pageInfo: PageInfo;
  edges: FacilityEdge[];
}

export interface FacilityConnectionPromise
  extends Promise<FacilityConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<FacilityEdge>>() => T;
  aggregate: <T = AggregateFacilityPromise>() => T;
}

export interface FacilityConnectionSubscription
  extends Promise<AsyncIterator<FacilityConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<FacilityEdgeSubscription>>>() => T;
  aggregate: <T = AggregateFacilitySubscription>() => T;
}

export interface FacilityEdge {
  node: Facility;
  cursor: String;
}

export interface FacilityEdgePromise
  extends Promise<FacilityEdge>,
    Fragmentable {
  node: <T = FacilityPromise>() => T;
  cursor: () => Promise<String>;
}

export interface FacilityEdgeSubscription
  extends Promise<AsyncIterator<FacilityEdge>>,
    Fragmentable {
  node: <T = FacilitySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateFacility {
  count: Int;
}

export interface AggregateFacilityPromise
  extends Promise<AggregateFacility>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateFacilitySubscription
  extends Promise<AsyncIterator<AggregateFacility>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface HospitalConnection {
  pageInfo: PageInfo;
  edges: HospitalEdge[];
}

export interface HospitalConnectionPromise
  extends Promise<HospitalConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<HospitalEdge>>() => T;
  aggregate: <T = AggregateHospitalPromise>() => T;
}

export interface HospitalConnectionSubscription
  extends Promise<AsyncIterator<HospitalConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<HospitalEdgeSubscription>>>() => T;
  aggregate: <T = AggregateHospitalSubscription>() => T;
}

export interface HospitalEdge {
  node: Hospital;
  cursor: String;
}

export interface HospitalEdgePromise
  extends Promise<HospitalEdge>,
    Fragmentable {
  node: <T = HospitalPromise>() => T;
  cursor: () => Promise<String>;
}

export interface HospitalEdgeSubscription
  extends Promise<AsyncIterator<HospitalEdge>>,
    Fragmentable {
  node: <T = HospitalSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateHospital {
  count: Int;
}

export interface AggregateHospitalPromise
  extends Promise<AggregateHospital>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateHospitalSubscription
  extends Promise<AsyncIterator<AggregateHospital>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface HospitalFacility {
  id: Int;
  facilityId?: Int;
  hospitalId?: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface HospitalFacilityPromise
  extends Promise<HospitalFacility>,
    Fragmentable {
  id: () => Promise<Int>;
  facilityId: () => Promise<Int>;
  hospitalId: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface HospitalFacilitySubscription
  extends Promise<AsyncIterator<HospitalFacility>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  facilityId: () => Promise<AsyncIterator<Int>>;
  hospitalId: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface HospitalFacilityNullablePromise
  extends Promise<HospitalFacility | null>,
    Fragmentable {
  id: () => Promise<Int>;
  facilityId: () => Promise<Int>;
  hospitalId: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface HospitalFacilityConnection {
  pageInfo: PageInfo;
  edges: HospitalFacilityEdge[];
}

export interface HospitalFacilityConnectionPromise
  extends Promise<HospitalFacilityConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<HospitalFacilityEdge>>() => T;
  aggregate: <T = AggregateHospitalFacilityPromise>() => T;
}

export interface HospitalFacilityConnectionSubscription
  extends Promise<AsyncIterator<HospitalFacilityConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<HospitalFacilityEdgeSubscription>>>() => T;
  aggregate: <T = AggregateHospitalFacilitySubscription>() => T;
}

export interface HospitalFacilityEdge {
  node: HospitalFacility;
  cursor: String;
}

export interface HospitalFacilityEdgePromise
  extends Promise<HospitalFacilityEdge>,
    Fragmentable {
  node: <T = HospitalFacilityPromise>() => T;
  cursor: () => Promise<String>;
}

export interface HospitalFacilityEdgeSubscription
  extends Promise<AsyncIterator<HospitalFacilityEdge>>,
    Fragmentable {
  node: <T = HospitalFacilitySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateHospitalFacility {
  count: Int;
}

export interface AggregateHospitalFacilityPromise
  extends Promise<AggregateHospitalFacility>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateHospitalFacilitySubscription
  extends Promise<AsyncIterator<AggregateHospitalFacility>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface HospitalRating {
  id: Int;
  hospitalId?: Int;
  rating?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface HospitalRatingPromise
  extends Promise<HospitalRating>,
    Fragmentable {
  id: () => Promise<Int>;
  hospitalId: () => Promise<Int>;
  rating: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface HospitalRatingSubscription
  extends Promise<AsyncIterator<HospitalRating>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  hospitalId: () => Promise<AsyncIterator<Int>>;
  rating: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface HospitalRatingNullablePromise
  extends Promise<HospitalRating | null>,
    Fragmentable {
  id: () => Promise<Int>;
  hospitalId: () => Promise<Int>;
  rating: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface HospitalRatingConnection {
  pageInfo: PageInfo;
  edges: HospitalRatingEdge[];
}

export interface HospitalRatingConnectionPromise
  extends Promise<HospitalRatingConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<HospitalRatingEdge>>() => T;
  aggregate: <T = AggregateHospitalRatingPromise>() => T;
}

export interface HospitalRatingConnectionSubscription
  extends Promise<AsyncIterator<HospitalRatingConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<HospitalRatingEdgeSubscription>>>() => T;
  aggregate: <T = AggregateHospitalRatingSubscription>() => T;
}

export interface HospitalRatingEdge {
  node: HospitalRating;
  cursor: String;
}

export interface HospitalRatingEdgePromise
  extends Promise<HospitalRatingEdge>,
    Fragmentable {
  node: <T = HospitalRatingPromise>() => T;
  cursor: () => Promise<String>;
}

export interface HospitalRatingEdgeSubscription
  extends Promise<AsyncIterator<HospitalRatingEdge>>,
    Fragmentable {
  node: <T = HospitalRatingSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateHospitalRating {
  count: Int;
}

export interface AggregateHospitalRatingPromise
  extends Promise<AggregateHospitalRating>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateHospitalRatingSubscription
  extends Promise<AsyncIterator<AggregateHospitalRating>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Illness {
  id: Int;
  illness?: String;
  illnessArabic?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface IllnessPromise extends Promise<Illness>, Fragmentable {
  id: () => Promise<Int>;
  illness: () => Promise<String>;
  illnessArabic: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface IllnessSubscription
  extends Promise<AsyncIterator<Illness>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  illness: () => Promise<AsyncIterator<String>>;
  illnessArabic: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface IllnessNullablePromise
  extends Promise<Illness | null>,
    Fragmentable {
  id: () => Promise<Int>;
  illness: () => Promise<String>;
  illnessArabic: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface IllnessConnection {
  pageInfo: PageInfo;
  edges: IllnessEdge[];
}

export interface IllnessConnectionPromise
  extends Promise<IllnessConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<IllnessEdge>>() => T;
  aggregate: <T = AggregateIllnessPromise>() => T;
}

export interface IllnessConnectionSubscription
  extends Promise<AsyncIterator<IllnessConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<IllnessEdgeSubscription>>>() => T;
  aggregate: <T = AggregateIllnessSubscription>() => T;
}

export interface IllnessEdge {
  node: Illness;
  cursor: String;
}

export interface IllnessEdgePromise extends Promise<IllnessEdge>, Fragmentable {
  node: <T = IllnessPromise>() => T;
  cursor: () => Promise<String>;
}

export interface IllnessEdgeSubscription
  extends Promise<AsyncIterator<IllnessEdge>>,
    Fragmentable {
  node: <T = IllnessSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateIllness {
  count: Int;
}

export interface AggregateIllnessPromise
  extends Promise<AggregateIllness>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateIllnessSubscription
  extends Promise<AsyncIterator<AggregateIllness>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface InsuranceConnection {
  pageInfo: PageInfo;
  edges: InsuranceEdge[];
}

export interface InsuranceConnectionPromise
  extends Promise<InsuranceConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<InsuranceEdge>>() => T;
  aggregate: <T = AggregateInsurancePromise>() => T;
}

export interface InsuranceConnectionSubscription
  extends Promise<AsyncIterator<InsuranceConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<InsuranceEdgeSubscription>>>() => T;
  aggregate: <T = AggregateInsuranceSubscription>() => T;
}

export interface InsuranceEdge {
  node: Insurance;
  cursor: String;
}

export interface InsuranceEdgePromise
  extends Promise<InsuranceEdge>,
    Fragmentable {
  node: <T = InsurancePromise>() => T;
  cursor: () => Promise<String>;
}

export interface InsuranceEdgeSubscription
  extends Promise<AsyncIterator<InsuranceEdge>>,
    Fragmentable {
  node: <T = InsuranceSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateInsurance {
  count: Int;
}

export interface AggregateInsurancePromise
  extends Promise<AggregateInsurance>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateInsuranceSubscription
  extends Promise<AsyncIterator<AggregateInsurance>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface InsuranceCategory {
  id: Int;
  category?: String;
  insuranceId?: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface InsuranceCategoryPromise
  extends Promise<InsuranceCategory>,
    Fragmentable {
  id: () => Promise<Int>;
  category: () => Promise<String>;
  insuranceId: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface InsuranceCategorySubscription
  extends Promise<AsyncIterator<InsuranceCategory>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  category: () => Promise<AsyncIterator<String>>;
  insuranceId: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface InsuranceCategoryNullablePromise
  extends Promise<InsuranceCategory | null>,
    Fragmentable {
  id: () => Promise<Int>;
  category: () => Promise<String>;
  insuranceId: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface InsuranceCategoryConnection {
  pageInfo: PageInfo;
  edges: InsuranceCategoryEdge[];
}

export interface InsuranceCategoryConnectionPromise
  extends Promise<InsuranceCategoryConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<InsuranceCategoryEdge>>() => T;
  aggregate: <T = AggregateInsuranceCategoryPromise>() => T;
}

export interface InsuranceCategoryConnectionSubscription
  extends Promise<AsyncIterator<InsuranceCategoryConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<InsuranceCategoryEdgeSubscription>>>() => T;
  aggregate: <T = AggregateInsuranceCategorySubscription>() => T;
}

export interface InsuranceCategoryEdge {
  node: InsuranceCategory;
  cursor: String;
}

export interface InsuranceCategoryEdgePromise
  extends Promise<InsuranceCategoryEdge>,
    Fragmentable {
  node: <T = InsuranceCategoryPromise>() => T;
  cursor: () => Promise<String>;
}

export interface InsuranceCategoryEdgeSubscription
  extends Promise<AsyncIterator<InsuranceCategoryEdge>>,
    Fragmentable {
  node: <T = InsuranceCategorySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateInsuranceCategory {
  count: Int;
}

export interface AggregateInsuranceCategoryPromise
  extends Promise<AggregateInsuranceCategory>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateInsuranceCategorySubscription
  extends Promise<AsyncIterator<AggregateInsuranceCategory>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Job {
  id: Int;
  position: String;
  positionArabic: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface JobPromise extends Promise<Job>, Fragmentable {
  id: () => Promise<Int>;
  position: () => Promise<String>;
  positionArabic: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface JobSubscription
  extends Promise<AsyncIterator<Job>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  position: () => Promise<AsyncIterator<String>>;
  positionArabic: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface JobNullablePromise extends Promise<Job | null>, Fragmentable {
  id: () => Promise<Int>;
  position: () => Promise<String>;
  positionArabic: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface JobConnection {
  pageInfo: PageInfo;
  edges: JobEdge[];
}

export interface JobConnectionPromise
  extends Promise<JobConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<JobEdge>>() => T;
  aggregate: <T = AggregateJobPromise>() => T;
}

export interface JobConnectionSubscription
  extends Promise<AsyncIterator<JobConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<JobEdgeSubscription>>>() => T;
  aggregate: <T = AggregateJobSubscription>() => T;
}

export interface JobEdge {
  node: Job;
  cursor: String;
}

export interface JobEdgePromise extends Promise<JobEdge>, Fragmentable {
  node: <T = JobPromise>() => T;
  cursor: () => Promise<String>;
}

export interface JobEdgeSubscription
  extends Promise<AsyncIterator<JobEdge>>,
    Fragmentable {
  node: <T = JobSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateJob {
  count: Int;
}

export interface AggregateJobPromise
  extends Promise<AggregateJob>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateJobSubscription
  extends Promise<AsyncIterator<AggregateJob>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Language {
  id: Int;
  language?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface LanguagePromise extends Promise<Language>, Fragmentable {
  id: () => Promise<Int>;
  language: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface LanguageSubscription
  extends Promise<AsyncIterator<Language>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  language: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface LanguageNullablePromise
  extends Promise<Language | null>,
    Fragmentable {
  id: () => Promise<Int>;
  language: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface LanguageConnection {
  pageInfo: PageInfo;
  edges: LanguageEdge[];
}

export interface LanguageConnectionPromise
  extends Promise<LanguageConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<LanguageEdge>>() => T;
  aggregate: <T = AggregateLanguagePromise>() => T;
}

export interface LanguageConnectionSubscription
  extends Promise<AsyncIterator<LanguageConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<LanguageEdgeSubscription>>>() => T;
  aggregate: <T = AggregateLanguageSubscription>() => T;
}

export interface LanguageEdge {
  node: Language;
  cursor: String;
}

export interface LanguageEdgePromise
  extends Promise<LanguageEdge>,
    Fragmentable {
  node: <T = LanguagePromise>() => T;
  cursor: () => Promise<String>;
}

export interface LanguageEdgeSubscription
  extends Promise<AsyncIterator<LanguageEdge>>,
    Fragmentable {
  node: <T = LanguageSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateLanguage {
  count: Int;
}

export interface AggregateLanguagePromise
  extends Promise<AggregateLanguage>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateLanguageSubscription
  extends Promise<AsyncIterator<AggregateLanguage>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Message {
  id: Int;
  fromUser: Int;
  isDelete: Int;
  isRead: Int;
  logCreate: DateTimeOutput;
  message: String;
  sentBy: Int;
  toUser: Int;
  updatedAt: DateTimeOutput;
}

export interface MessagePromise extends Promise<Message>, Fragmentable {
  id: () => Promise<Int>;
  fromUser: () => Promise<Int>;
  isDelete: () => Promise<Int>;
  isRead: () => Promise<Int>;
  logCreate: () => Promise<DateTimeOutput>;
  message: () => Promise<String>;
  sentBy: () => Promise<Int>;
  toUser: () => Promise<Int>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface MessageSubscription
  extends Promise<AsyncIterator<Message>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  fromUser: () => Promise<AsyncIterator<Int>>;
  isDelete: () => Promise<AsyncIterator<Int>>;
  isRead: () => Promise<AsyncIterator<Int>>;
  logCreate: () => Promise<AsyncIterator<DateTimeOutput>>;
  message: () => Promise<AsyncIterator<String>>;
  sentBy: () => Promise<AsyncIterator<Int>>;
  toUser: () => Promise<AsyncIterator<Int>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface MessageNullablePromise
  extends Promise<Message | null>,
    Fragmentable {
  id: () => Promise<Int>;
  fromUser: () => Promise<Int>;
  isDelete: () => Promise<Int>;
  isRead: () => Promise<Int>;
  logCreate: () => Promise<DateTimeOutput>;
  message: () => Promise<String>;
  sentBy: () => Promise<Int>;
  toUser: () => Promise<Int>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface MessageConnection {
  pageInfo: PageInfo;
  edges: MessageEdge[];
}

export interface MessageConnectionPromise
  extends Promise<MessageConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<MessageEdge>>() => T;
  aggregate: <T = AggregateMessagePromise>() => T;
}

export interface MessageConnectionSubscription
  extends Promise<AsyncIterator<MessageConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<MessageEdgeSubscription>>>() => T;
  aggregate: <T = AggregateMessageSubscription>() => T;
}

export interface MessageEdge {
  node: Message;
  cursor: String;
}

export interface MessageEdgePromise extends Promise<MessageEdge>, Fragmentable {
  node: <T = MessagePromise>() => T;
  cursor: () => Promise<String>;
}

export interface MessageEdgeSubscription
  extends Promise<AsyncIterator<MessageEdge>>,
    Fragmentable {
  node: <T = MessageSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateMessage {
  count: Int;
}

export interface AggregateMessagePromise
  extends Promise<AggregateMessage>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateMessageSubscription
  extends Promise<AsyncIterator<AggregateMessage>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Migration {
  id: Int;
  batch: Int;
  migration: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface MigrationPromise extends Promise<Migration>, Fragmentable {
  id: () => Promise<Int>;
  batch: () => Promise<Int>;
  migration: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface MigrationSubscription
  extends Promise<AsyncIterator<Migration>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  batch: () => Promise<AsyncIterator<Int>>;
  migration: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface MigrationNullablePromise
  extends Promise<Migration | null>,
    Fragmentable {
  id: () => Promise<Int>;
  batch: () => Promise<Int>;
  migration: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface MigrationConnection {
  pageInfo: PageInfo;
  edges: MigrationEdge[];
}

export interface MigrationConnectionPromise
  extends Promise<MigrationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<MigrationEdge>>() => T;
  aggregate: <T = AggregateMigrationPromise>() => T;
}

export interface MigrationConnectionSubscription
  extends Promise<AsyncIterator<MigrationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<MigrationEdgeSubscription>>>() => T;
  aggregate: <T = AggregateMigrationSubscription>() => T;
}

export interface MigrationEdge {
  node: Migration;
  cursor: String;
}

export interface MigrationEdgePromise
  extends Promise<MigrationEdge>,
    Fragmentable {
  node: <T = MigrationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface MigrationEdgeSubscription
  extends Promise<AsyncIterator<MigrationEdge>>,
    Fragmentable {
  node: <T = MigrationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateMigration {
  count: Int;
}

export interface AggregateMigrationPromise
  extends Promise<AggregateMigration>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateMigrationSubscription
  extends Promise<AsyncIterator<AggregateMigration>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Offer {
  id: Int;
  description: String;
  descriptionArabic: String;
  endDate: DateTimeOutput;
  heading: String;
  headingArabic: String;
  hospitalId: Int;
  offerImage: String;
  position: Int;
  startDate: DateTimeOutput;
  status: Int;
  type: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface OfferPromise extends Promise<Offer>, Fragmentable {
  id: () => Promise<Int>;
  description: () => Promise<String>;
  descriptionArabic: () => Promise<String>;
  endDate: () => Promise<DateTimeOutput>;
  heading: () => Promise<String>;
  headingArabic: () => Promise<String>;
  hospitalId: () => Promise<Int>;
  offerImage: () => Promise<String>;
  position: () => Promise<Int>;
  startDate: () => Promise<DateTimeOutput>;
  status: () => Promise<Int>;
  type: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface OfferSubscription
  extends Promise<AsyncIterator<Offer>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  description: () => Promise<AsyncIterator<String>>;
  descriptionArabic: () => Promise<AsyncIterator<String>>;
  endDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  heading: () => Promise<AsyncIterator<String>>;
  headingArabic: () => Promise<AsyncIterator<String>>;
  hospitalId: () => Promise<AsyncIterator<Int>>;
  offerImage: () => Promise<AsyncIterator<String>>;
  position: () => Promise<AsyncIterator<Int>>;
  startDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  status: () => Promise<AsyncIterator<Int>>;
  type: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface OfferNullablePromise
  extends Promise<Offer | null>,
    Fragmentable {
  id: () => Promise<Int>;
  description: () => Promise<String>;
  descriptionArabic: () => Promise<String>;
  endDate: () => Promise<DateTimeOutput>;
  heading: () => Promise<String>;
  headingArabic: () => Promise<String>;
  hospitalId: () => Promise<Int>;
  offerImage: () => Promise<String>;
  position: () => Promise<Int>;
  startDate: () => Promise<DateTimeOutput>;
  status: () => Promise<Int>;
  type: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface OfferConnection {
  pageInfo: PageInfo;
  edges: OfferEdge[];
}

export interface OfferConnectionPromise
  extends Promise<OfferConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<OfferEdge>>() => T;
  aggregate: <T = AggregateOfferPromise>() => T;
}

export interface OfferConnectionSubscription
  extends Promise<AsyncIterator<OfferConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<OfferEdgeSubscription>>>() => T;
  aggregate: <T = AggregateOfferSubscription>() => T;
}

export interface OfferEdge {
  node: Offer;
  cursor: String;
}

export interface OfferEdgePromise extends Promise<OfferEdge>, Fragmentable {
  node: <T = OfferPromise>() => T;
  cursor: () => Promise<String>;
}

export interface OfferEdgeSubscription
  extends Promise<AsyncIterator<OfferEdge>>,
    Fragmentable {
  node: <T = OfferSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateOffer {
  count: Int;
}

export interface AggregateOfferPromise
  extends Promise<AggregateOffer>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateOfferSubscription
  extends Promise<AsyncIterator<AggregateOffer>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface OnlineAppointment {
  id: Int;
  apointmentDate: String;
  apointmentFulldate: Int;
  apointmentTime: String;
  diseaseId?: Int;
  doctorArabic: String;
  doctorId?: Int;
  doctorName: String;
  dtId?: Int;
  gender: String;
  optId?: Int;
  patientId?: Int;
  phone: String;
  phoneCode?: String;
  scheduleTimeId: Int;
  status?: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface OnlineAppointmentPromise
  extends Promise<OnlineAppointment>,
    Fragmentable {
  id: () => Promise<Int>;
  apointmentDate: () => Promise<String>;
  apointmentFulldate: () => Promise<Int>;
  apointmentTime: () => Promise<String>;
  diseaseId: () => Promise<Int>;
  doctorArabic: () => Promise<String>;
  doctorId: () => Promise<Int>;
  doctorName: () => Promise<String>;
  dtId: () => Promise<Int>;
  gender: () => Promise<String>;
  optId: () => Promise<Int>;
  patientId: () => Promise<Int>;
  phone: () => Promise<String>;
  phoneCode: () => Promise<String>;
  scheduleTimeId: () => Promise<Int>;
  status: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface OnlineAppointmentSubscription
  extends Promise<AsyncIterator<OnlineAppointment>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  apointmentDate: () => Promise<AsyncIterator<String>>;
  apointmentFulldate: () => Promise<AsyncIterator<Int>>;
  apointmentTime: () => Promise<AsyncIterator<String>>;
  diseaseId: () => Promise<AsyncIterator<Int>>;
  doctorArabic: () => Promise<AsyncIterator<String>>;
  doctorId: () => Promise<AsyncIterator<Int>>;
  doctorName: () => Promise<AsyncIterator<String>>;
  dtId: () => Promise<AsyncIterator<Int>>;
  gender: () => Promise<AsyncIterator<String>>;
  optId: () => Promise<AsyncIterator<Int>>;
  patientId: () => Promise<AsyncIterator<Int>>;
  phone: () => Promise<AsyncIterator<String>>;
  phoneCode: () => Promise<AsyncIterator<String>>;
  scheduleTimeId: () => Promise<AsyncIterator<Int>>;
  status: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface OnlineAppointmentNullablePromise
  extends Promise<OnlineAppointment | null>,
    Fragmentable {
  id: () => Promise<Int>;
  apointmentDate: () => Promise<String>;
  apointmentFulldate: () => Promise<Int>;
  apointmentTime: () => Promise<String>;
  diseaseId: () => Promise<Int>;
  doctorArabic: () => Promise<String>;
  doctorId: () => Promise<Int>;
  doctorName: () => Promise<String>;
  dtId: () => Promise<Int>;
  gender: () => Promise<String>;
  optId: () => Promise<Int>;
  patientId: () => Promise<Int>;
  phone: () => Promise<String>;
  phoneCode: () => Promise<String>;
  scheduleTimeId: () => Promise<Int>;
  status: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface OnlineAppointmentConnection {
  pageInfo: PageInfo;
  edges: OnlineAppointmentEdge[];
}

export interface OnlineAppointmentConnectionPromise
  extends Promise<OnlineAppointmentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<OnlineAppointmentEdge>>() => T;
  aggregate: <T = AggregateOnlineAppointmentPromise>() => T;
}

export interface OnlineAppointmentConnectionSubscription
  extends Promise<AsyncIterator<OnlineAppointmentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<OnlineAppointmentEdgeSubscription>>>() => T;
  aggregate: <T = AggregateOnlineAppointmentSubscription>() => T;
}

export interface OnlineAppointmentEdge {
  node: OnlineAppointment;
  cursor: String;
}

export interface OnlineAppointmentEdgePromise
  extends Promise<OnlineAppointmentEdge>,
    Fragmentable {
  node: <T = OnlineAppointmentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface OnlineAppointmentEdgeSubscription
  extends Promise<AsyncIterator<OnlineAppointmentEdge>>,
    Fragmentable {
  node: <T = OnlineAppointmentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateOnlineAppointment {
  count: Int;
}

export interface AggregateOnlineAppointmentPromise
  extends Promise<AggregateOnlineAppointment>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateOnlineAppointmentSubscription
  extends Promise<AsyncIterator<AggregateOnlineAppointment>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface OnlineDoctor {
  id: Int;
  apiKey: String;
  createdDate: DateTimeOutput;
  designation: String;
  doctorCv: String;
  email?: String;
  gender: String;
  lastSeen: DateTimeOutput;
  mohcard?: String;
  mohId: String;
  name?: String;
  nameArabic: String;
  password: String;
  phone?: String;
  picture?: String;
  specialityId?: Int;
  status?: Int;
}

export interface OnlineDoctorPromise
  extends Promise<OnlineDoctor>,
    Fragmentable {
  id: () => Promise<Int>;
  apiKey: () => Promise<String>;
  createdDate: () => Promise<DateTimeOutput>;
  designation: () => Promise<String>;
  doctorCv: () => Promise<String>;
  email: () => Promise<String>;
  gender: () => Promise<String>;
  lastSeen: () => Promise<DateTimeOutput>;
  mohcard: () => Promise<String>;
  mohId: () => Promise<String>;
  name: () => Promise<String>;
  nameArabic: () => Promise<String>;
  password: () => Promise<String>;
  phone: () => Promise<String>;
  picture: () => Promise<String>;
  specialityId: () => Promise<Int>;
  status: () => Promise<Int>;
}

export interface OnlineDoctorSubscription
  extends Promise<AsyncIterator<OnlineDoctor>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  apiKey: () => Promise<AsyncIterator<String>>;
  createdDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  designation: () => Promise<AsyncIterator<String>>;
  doctorCv: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  gender: () => Promise<AsyncIterator<String>>;
  lastSeen: () => Promise<AsyncIterator<DateTimeOutput>>;
  mohcard: () => Promise<AsyncIterator<String>>;
  mohId: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  nameArabic: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
  picture: () => Promise<AsyncIterator<String>>;
  specialityId: () => Promise<AsyncIterator<Int>>;
  status: () => Promise<AsyncIterator<Int>>;
}

export interface OnlineDoctorNullablePromise
  extends Promise<OnlineDoctor | null>,
    Fragmentable {
  id: () => Promise<Int>;
  apiKey: () => Promise<String>;
  createdDate: () => Promise<DateTimeOutput>;
  designation: () => Promise<String>;
  doctorCv: () => Promise<String>;
  email: () => Promise<String>;
  gender: () => Promise<String>;
  lastSeen: () => Promise<DateTimeOutput>;
  mohcard: () => Promise<String>;
  mohId: () => Promise<String>;
  name: () => Promise<String>;
  nameArabic: () => Promise<String>;
  password: () => Promise<String>;
  phone: () => Promise<String>;
  picture: () => Promise<String>;
  specialityId: () => Promise<Int>;
  status: () => Promise<Int>;
}

export interface OnlineDoctorConnection {
  pageInfo: PageInfo;
  edges: OnlineDoctorEdge[];
}

export interface OnlineDoctorConnectionPromise
  extends Promise<OnlineDoctorConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<OnlineDoctorEdge>>() => T;
  aggregate: <T = AggregateOnlineDoctorPromise>() => T;
}

export interface OnlineDoctorConnectionSubscription
  extends Promise<AsyncIterator<OnlineDoctorConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<OnlineDoctorEdgeSubscription>>>() => T;
  aggregate: <T = AggregateOnlineDoctorSubscription>() => T;
}

export interface OnlineDoctorEdge {
  node: OnlineDoctor;
  cursor: String;
}

export interface OnlineDoctorEdgePromise
  extends Promise<OnlineDoctorEdge>,
    Fragmentable {
  node: <T = OnlineDoctorPromise>() => T;
  cursor: () => Promise<String>;
}

export interface OnlineDoctorEdgeSubscription
  extends Promise<AsyncIterator<OnlineDoctorEdge>>,
    Fragmentable {
  node: <T = OnlineDoctorSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateOnlineDoctor {
  count: Int;
}

export interface AggregateOnlineDoctorPromise
  extends Promise<AggregateOnlineDoctor>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateOnlineDoctorSubscription
  extends Promise<AsyncIterator<AggregateOnlineDoctor>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface OnlineRating {
  id: Int;
  doctorsId?: Int;
  rating?: String;
  systemIp: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface OnlineRatingPromise
  extends Promise<OnlineRating>,
    Fragmentable {
  id: () => Promise<Int>;
  doctorsId: () => Promise<Int>;
  rating: () => Promise<String>;
  systemIp: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface OnlineRatingSubscription
  extends Promise<AsyncIterator<OnlineRating>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  doctorsId: () => Promise<AsyncIterator<Int>>;
  rating: () => Promise<AsyncIterator<String>>;
  systemIp: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface OnlineRatingNullablePromise
  extends Promise<OnlineRating | null>,
    Fragmentable {
  id: () => Promise<Int>;
  doctorsId: () => Promise<Int>;
  rating: () => Promise<String>;
  systemIp: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface OnlineRatingConnection {
  pageInfo: PageInfo;
  edges: OnlineRatingEdge[];
}

export interface OnlineRatingConnectionPromise
  extends Promise<OnlineRatingConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<OnlineRatingEdge>>() => T;
  aggregate: <T = AggregateOnlineRatingPromise>() => T;
}

export interface OnlineRatingConnectionSubscription
  extends Promise<AsyncIterator<OnlineRatingConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<OnlineRatingEdgeSubscription>>>() => T;
  aggregate: <T = AggregateOnlineRatingSubscription>() => T;
}

export interface OnlineRatingEdge {
  node: OnlineRating;
  cursor: String;
}

export interface OnlineRatingEdgePromise
  extends Promise<OnlineRatingEdge>,
    Fragmentable {
  node: <T = OnlineRatingPromise>() => T;
  cursor: () => Promise<String>;
}

export interface OnlineRatingEdgeSubscription
  extends Promise<AsyncIterator<OnlineRatingEdge>>,
    Fragmentable {
  node: <T = OnlineRatingSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateOnlineRating {
  count: Int;
}

export interface AggregateOnlineRatingPromise
  extends Promise<AggregateOnlineRating>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateOnlineRatingSubscription
  extends Promise<AsyncIterator<AggregateOnlineRating>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface OptTimeConnection {
  pageInfo: PageInfo;
  edges: OptTimeEdge[];
}

export interface OptTimeConnectionPromise
  extends Promise<OptTimeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<OptTimeEdge>>() => T;
  aggregate: <T = AggregateOptTimePromise>() => T;
}

export interface OptTimeConnectionSubscription
  extends Promise<AsyncIterator<OptTimeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<OptTimeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateOptTimeSubscription>() => T;
}

export interface OptTimeEdge {
  node: OptTime;
  cursor: String;
}

export interface OptTimeEdgePromise extends Promise<OptTimeEdge>, Fragmentable {
  node: <T = OptTimePromise>() => T;
  cursor: () => Promise<String>;
}

export interface OptTimeEdgeSubscription
  extends Promise<AsyncIterator<OptTimeEdge>>,
    Fragmentable {
  node: <T = OptTimeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateOptTime {
  count: Int;
}

export interface AggregateOptTimePromise
  extends Promise<AggregateOptTime>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateOptTimeSubscription
  extends Promise<AsyncIterator<AggregateOptTime>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Page {
  id: Int;
  slug?: String;
  slug_ar?: String;
  title?: String;
  title_ar?: String;
  content?: String;
  content_ar?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface PagePromise extends Promise<Page>, Fragmentable {
  id: () => Promise<Int>;
  slug: () => Promise<String>;
  slug_ar: () => Promise<String>;
  title: () => Promise<String>;
  title_ar: () => Promise<String>;
  content: () => Promise<String>;
  content_ar: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PageSubscription
  extends Promise<AsyncIterator<Page>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  slug: () => Promise<AsyncIterator<String>>;
  slug_ar: () => Promise<AsyncIterator<String>>;
  title: () => Promise<AsyncIterator<String>>;
  title_ar: () => Promise<AsyncIterator<String>>;
  content: () => Promise<AsyncIterator<String>>;
  content_ar: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PageNullablePromise
  extends Promise<Page | null>,
    Fragmentable {
  id: () => Promise<Int>;
  slug: () => Promise<String>;
  slug_ar: () => Promise<String>;
  title: () => Promise<String>;
  title_ar: () => Promise<String>;
  content: () => Promise<String>;
  content_ar: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PageConnection {
  pageInfo: PageInfo;
  edges: PageEdge[];
}

export interface PageConnectionPromise
  extends Promise<PageConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PageEdge>>() => T;
  aggregate: <T = AggregatePagePromise>() => T;
}

export interface PageConnectionSubscription
  extends Promise<AsyncIterator<PageConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PageEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePageSubscription>() => T;
}

export interface PageEdge {
  node: Page;
  cursor: String;
}

export interface PageEdgePromise extends Promise<PageEdge>, Fragmentable {
  node: <T = PagePromise>() => T;
  cursor: () => Promise<String>;
}

export interface PageEdgeSubscription
  extends Promise<AsyncIterator<PageEdge>>,
    Fragmentable {
  node: <T = PageSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregatePage {
  count: Int;
}

export interface AggregatePagePromise
  extends Promise<AggregatePage>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePageSubscription
  extends Promise<AsyncIterator<AggregatePage>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PasswordReset {
  id: Int;
  createdAt: DateTimeOutput;
  email: String;
  token: String;
  updatedAt: DateTimeOutput;
}

export interface PasswordResetPromise
  extends Promise<PasswordReset>,
    Fragmentable {
  id: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  email: () => Promise<String>;
  token: () => Promise<String>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PasswordResetSubscription
  extends Promise<AsyncIterator<PasswordReset>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  email: () => Promise<AsyncIterator<String>>;
  token: () => Promise<AsyncIterator<String>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PasswordResetNullablePromise
  extends Promise<PasswordReset | null>,
    Fragmentable {
  id: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  email: () => Promise<String>;
  token: () => Promise<String>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PasswordResetConnection {
  pageInfo: PageInfo;
  edges: PasswordResetEdge[];
}

export interface PasswordResetConnectionPromise
  extends Promise<PasswordResetConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PasswordResetEdge>>() => T;
  aggregate: <T = AggregatePasswordResetPromise>() => T;
}

export interface PasswordResetConnectionSubscription
  extends Promise<AsyncIterator<PasswordResetConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PasswordResetEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePasswordResetSubscription>() => T;
}

export interface PasswordResetEdge {
  node: PasswordReset;
  cursor: String;
}

export interface PasswordResetEdgePromise
  extends Promise<PasswordResetEdge>,
    Fragmentable {
  node: <T = PasswordResetPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PasswordResetEdgeSubscription
  extends Promise<AsyncIterator<PasswordResetEdge>>,
    Fragmentable {
  node: <T = PasswordResetSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregatePasswordReset {
  count: Int;
}

export interface AggregatePasswordResetPromise
  extends Promise<AggregatePasswordReset>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePasswordResetSubscription
  extends Promise<AsyncIterator<AggregatePasswordReset>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PatientConnection {
  pageInfo: PageInfo;
  edges: PatientEdge[];
}

export interface PatientConnectionPromise
  extends Promise<PatientConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PatientEdge>>() => T;
  aggregate: <T = AggregatePatientPromise>() => T;
}

export interface PatientConnectionSubscription
  extends Promise<AsyncIterator<PatientConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PatientEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePatientSubscription>() => T;
}

export interface PatientEdge {
  node: Patient;
  cursor: String;
}

export interface PatientEdgePromise extends Promise<PatientEdge>, Fragmentable {
  node: <T = PatientPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PatientEdgeSubscription
  extends Promise<AsyncIterator<PatientEdge>>,
    Fragmentable {
  node: <T = PatientSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregatePatient {
  count: Int;
}

export interface AggregatePatientPromise
  extends Promise<AggregatePatient>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePatientSubscription
  extends Promise<AsyncIterator<AggregatePatient>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PostImageConnection {
  pageInfo: PageInfo;
  edges: PostImageEdge[];
}

export interface PostImageConnectionPromise
  extends Promise<PostImageConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PostImageEdge>>() => T;
  aggregate: <T = AggregatePostImagePromise>() => T;
}

export interface PostImageConnectionSubscription
  extends Promise<AsyncIterator<PostImageConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PostImageEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePostImageSubscription>() => T;
}

export interface PostImageEdge {
  node: PostImage;
  cursor: String;
}

export interface PostImageEdgePromise
  extends Promise<PostImageEdge>,
    Fragmentable {
  node: <T = PostImagePromise>() => T;
  cursor: () => Promise<String>;
}

export interface PostImageEdgeSubscription
  extends Promise<AsyncIterator<PostImageEdge>>,
    Fragmentable {
  node: <T = PostImageSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregatePostImage {
  count: Int;
}

export interface AggregatePostImagePromise
  extends Promise<AggregatePostImage>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePostImageSubscription
  extends Promise<AsyncIterator<AggregatePostImage>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SearchDesign {
  id: Int;
  addressColor: String;
  addressFamily: String;
  addressStyle: String;
  designationColor: String;
  designationFamily: String;
  designationStyle: String;
  doctorColor: String;
  doctorFamily: String;
  doctorStyle: String;
  emailColor: String;
  emailFamily: String;
  emailStyle: String;
  nameColor: String;
  nameFamily: String;
  nameStyle: String;
  phoneColor: String;
  phoneFamily: String;
  phoneStyle: String;
  ratingColor: String;
  ratingFamily: String;
  ratingStyle: String;
  specialityColor: String;
  specialityFamily: String;
  specialityStyle: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface SearchDesignPromise
  extends Promise<SearchDesign>,
    Fragmentable {
  id: () => Promise<Int>;
  addressColor: () => Promise<String>;
  addressFamily: () => Promise<String>;
  addressStyle: () => Promise<String>;
  designationColor: () => Promise<String>;
  designationFamily: () => Promise<String>;
  designationStyle: () => Promise<String>;
  doctorColor: () => Promise<String>;
  doctorFamily: () => Promise<String>;
  doctorStyle: () => Promise<String>;
  emailColor: () => Promise<String>;
  emailFamily: () => Promise<String>;
  emailStyle: () => Promise<String>;
  nameColor: () => Promise<String>;
  nameFamily: () => Promise<String>;
  nameStyle: () => Promise<String>;
  phoneColor: () => Promise<String>;
  phoneFamily: () => Promise<String>;
  phoneStyle: () => Promise<String>;
  ratingColor: () => Promise<String>;
  ratingFamily: () => Promise<String>;
  ratingStyle: () => Promise<String>;
  specialityColor: () => Promise<String>;
  specialityFamily: () => Promise<String>;
  specialityStyle: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface SearchDesignSubscription
  extends Promise<AsyncIterator<SearchDesign>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  addressColor: () => Promise<AsyncIterator<String>>;
  addressFamily: () => Promise<AsyncIterator<String>>;
  addressStyle: () => Promise<AsyncIterator<String>>;
  designationColor: () => Promise<AsyncIterator<String>>;
  designationFamily: () => Promise<AsyncIterator<String>>;
  designationStyle: () => Promise<AsyncIterator<String>>;
  doctorColor: () => Promise<AsyncIterator<String>>;
  doctorFamily: () => Promise<AsyncIterator<String>>;
  doctorStyle: () => Promise<AsyncIterator<String>>;
  emailColor: () => Promise<AsyncIterator<String>>;
  emailFamily: () => Promise<AsyncIterator<String>>;
  emailStyle: () => Promise<AsyncIterator<String>>;
  nameColor: () => Promise<AsyncIterator<String>>;
  nameFamily: () => Promise<AsyncIterator<String>>;
  nameStyle: () => Promise<AsyncIterator<String>>;
  phoneColor: () => Promise<AsyncIterator<String>>;
  phoneFamily: () => Promise<AsyncIterator<String>>;
  phoneStyle: () => Promise<AsyncIterator<String>>;
  ratingColor: () => Promise<AsyncIterator<String>>;
  ratingFamily: () => Promise<AsyncIterator<String>>;
  ratingStyle: () => Promise<AsyncIterator<String>>;
  specialityColor: () => Promise<AsyncIterator<String>>;
  specialityFamily: () => Promise<AsyncIterator<String>>;
  specialityStyle: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface SearchDesignNullablePromise
  extends Promise<SearchDesign | null>,
    Fragmentable {
  id: () => Promise<Int>;
  addressColor: () => Promise<String>;
  addressFamily: () => Promise<String>;
  addressStyle: () => Promise<String>;
  designationColor: () => Promise<String>;
  designationFamily: () => Promise<String>;
  designationStyle: () => Promise<String>;
  doctorColor: () => Promise<String>;
  doctorFamily: () => Promise<String>;
  doctorStyle: () => Promise<String>;
  emailColor: () => Promise<String>;
  emailFamily: () => Promise<String>;
  emailStyle: () => Promise<String>;
  nameColor: () => Promise<String>;
  nameFamily: () => Promise<String>;
  nameStyle: () => Promise<String>;
  phoneColor: () => Promise<String>;
  phoneFamily: () => Promise<String>;
  phoneStyle: () => Promise<String>;
  ratingColor: () => Promise<String>;
  ratingFamily: () => Promise<String>;
  ratingStyle: () => Promise<String>;
  specialityColor: () => Promise<String>;
  specialityFamily: () => Promise<String>;
  specialityStyle: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface SearchDesignConnection {
  pageInfo: PageInfo;
  edges: SearchDesignEdge[];
}

export interface SearchDesignConnectionPromise
  extends Promise<SearchDesignConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SearchDesignEdge>>() => T;
  aggregate: <T = AggregateSearchDesignPromise>() => T;
}

export interface SearchDesignConnectionSubscription
  extends Promise<AsyncIterator<SearchDesignConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SearchDesignEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSearchDesignSubscription>() => T;
}

export interface SearchDesignEdge {
  node: SearchDesign;
  cursor: String;
}

export interface SearchDesignEdgePromise
  extends Promise<SearchDesignEdge>,
    Fragmentable {
  node: <T = SearchDesignPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SearchDesignEdgeSubscription
  extends Promise<AsyncIterator<SearchDesignEdge>>,
    Fragmentable {
  node: <T = SearchDesignSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateSearchDesign {
  count: Int;
}

export interface AggregateSearchDesignPromise
  extends Promise<AggregateSearchDesign>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSearchDesignSubscription
  extends Promise<AsyncIterator<AggregateSearchDesign>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SheduleTimeConnection {
  pageInfo: PageInfo;
  edges: SheduleTimeEdge[];
}

export interface SheduleTimeConnectionPromise
  extends Promise<SheduleTimeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SheduleTimeEdge>>() => T;
  aggregate: <T = AggregateSheduleTimePromise>() => T;
}

export interface SheduleTimeConnectionSubscription
  extends Promise<AsyncIterator<SheduleTimeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SheduleTimeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSheduleTimeSubscription>() => T;
}

export interface SheduleTimeEdge {
  node: SheduleTime;
  cursor: String;
}

export interface SheduleTimeEdgePromise
  extends Promise<SheduleTimeEdge>,
    Fragmentable {
  node: <T = SheduleTimePromise>() => T;
  cursor: () => Promise<String>;
}

export interface SheduleTimeEdgeSubscription
  extends Promise<AsyncIterator<SheduleTimeEdge>>,
    Fragmentable {
  node: <T = SheduleTimeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateSheduleTime {
  count: Int;
}

export interface AggregateSheduleTimePromise
  extends Promise<AggregateSheduleTime>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSheduleTimeSubscription
  extends Promise<AsyncIterator<AggregateSheduleTime>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Slider {
  id: Int;
  arabicHeading: String;
  banner: String;
  heading: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface SliderPromise extends Promise<Slider>, Fragmentable {
  id: () => Promise<Int>;
  arabicHeading: () => Promise<String>;
  banner: () => Promise<String>;
  heading: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface SliderSubscription
  extends Promise<AsyncIterator<Slider>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  arabicHeading: () => Promise<AsyncIterator<String>>;
  banner: () => Promise<AsyncIterator<String>>;
  heading: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface SliderNullablePromise
  extends Promise<Slider | null>,
    Fragmentable {
  id: () => Promise<Int>;
  arabicHeading: () => Promise<String>;
  banner: () => Promise<String>;
  heading: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface SliderConnection {
  pageInfo: PageInfo;
  edges: SliderEdge[];
}

export interface SliderConnectionPromise
  extends Promise<SliderConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SliderEdge>>() => T;
  aggregate: <T = AggregateSliderPromise>() => T;
}

export interface SliderConnectionSubscription
  extends Promise<AsyncIterator<SliderConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SliderEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSliderSubscription>() => T;
}

export interface SliderEdge {
  node: Slider;
  cursor: String;
}

export interface SliderEdgePromise extends Promise<SliderEdge>, Fragmentable {
  node: <T = SliderPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SliderEdgeSubscription
  extends Promise<AsyncIterator<SliderEdge>>,
    Fragmentable {
  node: <T = SliderSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateSlider {
  count: Int;
}

export interface AggregateSliderPromise
  extends Promise<AggregateSlider>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSliderSubscription
  extends Promise<AsyncIterator<AggregateSlider>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SpecialityConnection {
  pageInfo: PageInfo;
  edges: SpecialityEdge[];
}

export interface SpecialityConnectionPromise
  extends Promise<SpecialityConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SpecialityEdge>>() => T;
  aggregate: <T = AggregateSpecialityPromise>() => T;
}

export interface SpecialityConnectionSubscription
  extends Promise<AsyncIterator<SpecialityConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SpecialityEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSpecialitySubscription>() => T;
}

export interface SpecialityEdge {
  node: Speciality;
  cursor: String;
}

export interface SpecialityEdgePromise
  extends Promise<SpecialityEdge>,
    Fragmentable {
  node: <T = SpecialityPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SpecialityEdgeSubscription
  extends Promise<AsyncIterator<SpecialityEdge>>,
    Fragmentable {
  node: <T = SpecialitySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateSpeciality {
  count: Int;
}

export interface AggregateSpecialityPromise
  extends Promise<AggregateSpeciality>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSpecialitySubscription
  extends Promise<AsyncIterator<AggregateSpeciality>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Translation {
  id: Int;
  arabi: String;
  english: String;
  index: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface TranslationPromise extends Promise<Translation>, Fragmentable {
  id: () => Promise<Int>;
  arabi: () => Promise<String>;
  english: () => Promise<String>;
  index: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface TranslationSubscription
  extends Promise<AsyncIterator<Translation>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  arabi: () => Promise<AsyncIterator<String>>;
  english: () => Promise<AsyncIterator<String>>;
  index: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface TranslationNullablePromise
  extends Promise<Translation | null>,
    Fragmentable {
  id: () => Promise<Int>;
  arabi: () => Promise<String>;
  english: () => Promise<String>;
  index: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface TranslationConnection {
  pageInfo: PageInfo;
  edges: TranslationEdge[];
}

export interface TranslationConnectionPromise
  extends Promise<TranslationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TranslationEdge>>() => T;
  aggregate: <T = AggregateTranslationPromise>() => T;
}

export interface TranslationConnectionSubscription
  extends Promise<AsyncIterator<TranslationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TranslationEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTranslationSubscription>() => T;
}

export interface TranslationEdge {
  node: Translation;
  cursor: String;
}

export interface TranslationEdgePromise
  extends Promise<TranslationEdge>,
    Fragmentable {
  node: <T = TranslationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TranslationEdgeSubscription
  extends Promise<AsyncIterator<TranslationEdge>>,
    Fragmentable {
  node: <T = TranslationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateTranslation {
  count: Int;
}

export interface AggregateTranslationPromise
  extends Promise<AggregateTranslation>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTranslationSubscription
  extends Promise<AsyncIterator<AggregateTranslation>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface User {
  id: Int;
  createdAt: DateTimeOutput;
  email: String;
  name: String;
  password: String;
  rememberToken?: String;
  updatedAt: DateTimeOutput;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  email: () => Promise<String>;
  name: () => Promise<String>;
  password: () => Promise<String>;
  rememberToken: () => Promise<String>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  email: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  rememberToken: () => Promise<AsyncIterator<String>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface UserNullablePromise
  extends Promise<User | null>,
    Fragmentable {
  id: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  email: () => Promise<String>;
  name: () => Promise<String>;
  password: () => Promise<String>;
  rememberToken: () => Promise<String>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface VideoRequest {
  id: Int;
  doctorId: Int;
  joinCall: Int;
  patientId: Int;
  requestDate: Int;
  videoCode: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface VideoRequestPromise
  extends Promise<VideoRequest>,
    Fragmentable {
  id: () => Promise<Int>;
  doctorId: () => Promise<Int>;
  joinCall: () => Promise<Int>;
  patientId: () => Promise<Int>;
  requestDate: () => Promise<Int>;
  videoCode: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface VideoRequestSubscription
  extends Promise<AsyncIterator<VideoRequest>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  doctorId: () => Promise<AsyncIterator<Int>>;
  joinCall: () => Promise<AsyncIterator<Int>>;
  patientId: () => Promise<AsyncIterator<Int>>;
  requestDate: () => Promise<AsyncIterator<Int>>;
  videoCode: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface VideoRequestNullablePromise
  extends Promise<VideoRequest | null>,
    Fragmentable {
  id: () => Promise<Int>;
  doctorId: () => Promise<Int>;
  joinCall: () => Promise<Int>;
  patientId: () => Promise<Int>;
  requestDate: () => Promise<Int>;
  videoCode: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface VideoRequestConnection {
  pageInfo: PageInfo;
  edges: VideoRequestEdge[];
}

export interface VideoRequestConnectionPromise
  extends Promise<VideoRequestConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<VideoRequestEdge>>() => T;
  aggregate: <T = AggregateVideoRequestPromise>() => T;
}

export interface VideoRequestConnectionSubscription
  extends Promise<AsyncIterator<VideoRequestConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<VideoRequestEdgeSubscription>>>() => T;
  aggregate: <T = AggregateVideoRequestSubscription>() => T;
}

export interface VideoRequestEdge {
  node: VideoRequest;
  cursor: String;
}

export interface VideoRequestEdgePromise
  extends Promise<VideoRequestEdge>,
    Fragmentable {
  node: <T = VideoRequestPromise>() => T;
  cursor: () => Promise<String>;
}

export interface VideoRequestEdgeSubscription
  extends Promise<AsyncIterator<VideoRequestEdge>>,
    Fragmentable {
  node: <T = VideoRequestSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateVideoRequest {
  count: Int;
}

export interface AggregateVideoRequestPromise
  extends Promise<AggregateVideoRequest>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateVideoRequestSubscription
  extends Promise<AsyncIterator<AggregateVideoRequest>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Visitor {
  id: Int;
  country?: String;
  hits: Int;
  ipAddress: String;
  visitDate: DateTimeOutput;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface VisitorPromise extends Promise<Visitor>, Fragmentable {
  id: () => Promise<Int>;
  country: () => Promise<String>;
  hits: () => Promise<Int>;
  ipAddress: () => Promise<String>;
  visitDate: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface VisitorSubscription
  extends Promise<AsyncIterator<Visitor>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  country: () => Promise<AsyncIterator<String>>;
  hits: () => Promise<AsyncIterator<Int>>;
  ipAddress: () => Promise<AsyncIterator<String>>;
  visitDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface VisitorNullablePromise
  extends Promise<Visitor | null>,
    Fragmentable {
  id: () => Promise<Int>;
  country: () => Promise<String>;
  hits: () => Promise<Int>;
  ipAddress: () => Promise<String>;
  visitDate: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface VisitorConnection {
  pageInfo: PageInfo;
  edges: VisitorEdge[];
}

export interface VisitorConnectionPromise
  extends Promise<VisitorConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<VisitorEdge>>() => T;
  aggregate: <T = AggregateVisitorPromise>() => T;
}

export interface VisitorConnectionSubscription
  extends Promise<AsyncIterator<VisitorConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<VisitorEdgeSubscription>>>() => T;
  aggregate: <T = AggregateVisitorSubscription>() => T;
}

export interface VisitorEdge {
  node: Visitor;
  cursor: String;
}

export interface VisitorEdgePromise extends Promise<VisitorEdge>, Fragmentable {
  node: <T = VisitorPromise>() => T;
  cursor: () => Promise<String>;
}

export interface VisitorEdgeSubscription
  extends Promise<AsyncIterator<VisitorEdge>>,
    Fragmentable {
  node: <T = VisitorSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateVisitor {
  count: Int;
}

export interface AggregateVisitorPromise
  extends Promise<AggregateVisitor>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateVisitorSubscription
  extends Promise<AsyncIterator<AggregateVisitor>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface AboutUsSubscriptionPayload {
  mutation: MutationType;
  node: AboutUs;
  updatedFields: String[];
  previousValues: AboutUsPreviousValues;
}

export interface AboutUsSubscriptionPayloadPromise
  extends Promise<AboutUsSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AboutUsPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AboutUsPreviousValuesPromise>() => T;
}

export interface AboutUsSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AboutUsSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AboutUsSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AboutUsPreviousValuesSubscription>() => T;
}

export interface AboutUsPreviousValues {
  id: Int;
  arabicContent: String;
  englishContent: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface AboutUsPreviousValuesPromise
  extends Promise<AboutUsPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  arabicContent: () => Promise<String>;
  englishContent: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface AboutUsPreviousValuesSubscription
  extends Promise<AsyncIterator<AboutUsPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  arabicContent: () => Promise<AsyncIterator<String>>;
  englishContent: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AdminSubscriptionPayload {
  mutation: MutationType;
  node: Admin;
  updatedFields: String[];
  previousValues: AdminPreviousValues;
}

export interface AdminSubscriptionPayloadPromise
  extends Promise<AdminSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AdminPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AdminPreviousValuesPromise>() => T;
}

export interface AdminSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AdminSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AdminSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AdminPreviousValuesSubscription>() => T;
}

export interface AdminPreviousValues {
  id: Int;
  email: String;
  pass?: String;
  superAdmin: Int;
  user?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface AdminPreviousValuesPromise
  extends Promise<AdminPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  email: () => Promise<String>;
  pass: () => Promise<String>;
  superAdmin: () => Promise<Int>;
  user: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface AdminPreviousValuesSubscription
  extends Promise<AsyncIterator<AdminPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  email: () => Promise<AsyncIterator<String>>;
  pass: () => Promise<AsyncIterator<String>>;
  superAdmin: () => Promise<AsyncIterator<Int>>;
  user: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AppointmentSubscriptionPayload {
  mutation: MutationType;
  node: Appointment;
  updatedFields: String[];
  previousValues: AppointmentPreviousValues;
}

export interface AppointmentSubscriptionPayloadPromise
  extends Promise<AppointmentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AppointmentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AppointmentPreviousValuesPromise>() => T;
}

export interface AppointmentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AppointmentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AppointmentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AppointmentPreviousValuesSubscription>() => T;
}

export interface AppointmentPreviousValues {
  id: Int;
  apointmentDate: String;
  apointmentFulldate: Int;
  apointmentTime: String;
  doctorArabic: String;
  doctorName: String;
  gender: String;
  isRead: Int;
  phone: String;
  phoneCode?: String;
  status?: Int;
}

export interface AppointmentPreviousValuesPromise
  extends Promise<AppointmentPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  apointmentDate: () => Promise<String>;
  apointmentFulldate: () => Promise<Int>;
  apointmentTime: () => Promise<String>;
  doctorArabic: () => Promise<String>;
  doctorName: () => Promise<String>;
  gender: () => Promise<String>;
  isRead: () => Promise<Int>;
  phone: () => Promise<String>;
  phoneCode: () => Promise<String>;
  status: () => Promise<Int>;
}

export interface AppointmentPreviousValuesSubscription
  extends Promise<AsyncIterator<AppointmentPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  apointmentDate: () => Promise<AsyncIterator<String>>;
  apointmentFulldate: () => Promise<AsyncIterator<Int>>;
  apointmentTime: () => Promise<AsyncIterator<String>>;
  doctorArabic: () => Promise<AsyncIterator<String>>;
  doctorName: () => Promise<AsyncIterator<String>>;
  gender: () => Promise<AsyncIterator<String>>;
  isRead: () => Promise<AsyncIterator<Int>>;
  phone: () => Promise<AsyncIterator<String>>;
  phoneCode: () => Promise<AsyncIterator<String>>;
  status: () => Promise<AsyncIterator<Int>>;
}

export interface BlogSubscriptionPayload {
  mutation: MutationType;
  node: Blog;
  updatedFields: String[];
  previousValues: BlogPreviousValues;
}

export interface BlogSubscriptionPayloadPromise
  extends Promise<BlogSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = BlogPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BlogPreviousValuesPromise>() => T;
}

export interface BlogSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BlogSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BlogSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BlogPreviousValuesSubscription>() => T;
}

export interface BlogPreviousValues {
  id: Int;
  bannerImage: String;
  createdDate: DateTimeOutput;
  name: String;
  status: Int;
  updatedAt?: DateTimeOutput;
}

export interface BlogPreviousValuesPromise
  extends Promise<BlogPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  bannerImage: () => Promise<String>;
  createdDate: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  status: () => Promise<Int>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface BlogPreviousValuesSubscription
  extends Promise<AsyncIterator<BlogPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  bannerImage: () => Promise<AsyncIterator<String>>;
  createdDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  status: () => Promise<AsyncIterator<Int>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface BlogCommentSubscriptionPayload {
  mutation: MutationType;
  node: BlogComment;
  updatedFields: String[];
  previousValues: BlogCommentPreviousValues;
}

export interface BlogCommentSubscriptionPayloadPromise
  extends Promise<BlogCommentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = BlogCommentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BlogCommentPreviousValuesPromise>() => T;
}

export interface BlogCommentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BlogCommentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BlogCommentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BlogCommentPreviousValuesSubscription>() => T;
}

export interface BlogCommentPreviousValues {
  id: Int;
  commentator: Int;
  commentatorName: String;
  comments: String;
  logCreated: DateTimeOutput;
  updatedAt?: DateTimeOutput;
}

export interface BlogCommentPreviousValuesPromise
  extends Promise<BlogCommentPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  commentator: () => Promise<Int>;
  commentatorName: () => Promise<String>;
  comments: () => Promise<String>;
  logCreated: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface BlogCommentPreviousValuesSubscription
  extends Promise<AsyncIterator<BlogCommentPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  commentator: () => Promise<AsyncIterator<Int>>;
  commentatorName: () => Promise<AsyncIterator<String>>;
  comments: () => Promise<AsyncIterator<String>>;
  logCreated: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface BlogPostSubscriptionPayload {
  mutation: MutationType;
  node: BlogPost;
  updatedFields: String[];
  previousValues: BlogPostPreviousValues;
}

export interface BlogPostSubscriptionPayloadPromise
  extends Promise<BlogPostSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = BlogPostPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BlogPostPreviousValuesPromise>() => T;
}

export interface BlogPostSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BlogPostSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BlogPostSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BlogPostPreviousValuesSubscription>() => T;
}

export interface BlogPostPreviousValues {
  id: Int;
  logCreated: DateTimeOutput;
  postContent: String;
  postTitle: String;
  status: Int;
  totalViewers: Int;
  updatedAt?: DateTimeOutput;
}

export interface BlogPostPreviousValuesPromise
  extends Promise<BlogPostPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  logCreated: () => Promise<DateTimeOutput>;
  postContent: () => Promise<String>;
  postTitle: () => Promise<String>;
  status: () => Promise<Int>;
  totalViewers: () => Promise<Int>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface BlogPostPreviousValuesSubscription
  extends Promise<AsyncIterator<BlogPostPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  logCreated: () => Promise<AsyncIterator<DateTimeOutput>>;
  postContent: () => Promise<AsyncIterator<String>>;
  postTitle: () => Promise<AsyncIterator<String>>;
  status: () => Promise<AsyncIterator<Int>>;
  totalViewers: () => Promise<AsyncIterator<Int>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CitySubscriptionPayload {
  mutation: MutationType;
  node: City;
  updatedFields: String[];
  previousValues: CityPreviousValues;
}

export interface CitySubscriptionPayloadPromise
  extends Promise<CitySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CityPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CityPreviousValuesPromise>() => T;
}

export interface CitySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CitySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CitySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CityPreviousValuesSubscription>() => T;
}

export interface CityPreviousValues {
  id: Int;
  city?: String;
  cityArabic: String;
  countryId?: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface CityPreviousValuesPromise
  extends Promise<CityPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  city: () => Promise<String>;
  cityArabic: () => Promise<String>;
  countryId: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CityPreviousValuesSubscription
  extends Promise<AsyncIterator<CityPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  city: () => Promise<AsyncIterator<String>>;
  cityArabic: () => Promise<AsyncIterator<String>>;
  countryId: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ContactUsSubscriptionPayload {
  mutation: MutationType;
  node: ContactUs;
  updatedFields: String[];
  previousValues: ContactUsPreviousValues;
}

export interface ContactUsSubscriptionPayloadPromise
  extends Promise<ContactUsSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ContactUsPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ContactUsPreviousValuesPromise>() => T;
}

export interface ContactUsSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ContactUsSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ContactUsSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ContactUsPreviousValuesSubscription>() => T;
}

export interface ContactUsPreviousValues {
  id: Int;
  address: String;
  email: String;
  lat: String;
  lon: String;
  phone: String;
  pobox: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ContactUsPreviousValuesPromise
  extends Promise<ContactUsPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  address: () => Promise<String>;
  email: () => Promise<String>;
  lat: () => Promise<String>;
  lon: () => Promise<String>;
  phone: () => Promise<String>;
  pobox: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ContactUsPreviousValuesSubscription
  extends Promise<AsyncIterator<ContactUsPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  address: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  lat: () => Promise<AsyncIterator<String>>;
  lon: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
  pobox: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CountrySubscriptionPayload {
  mutation: MutationType;
  node: Country;
  updatedFields: String[];
  previousValues: CountryPreviousValues;
}

export interface CountrySubscriptionPayloadPromise
  extends Promise<CountrySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CountryPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CountryPreviousValuesPromise>() => T;
}

export interface CountrySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CountrySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CountrySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CountryPreviousValuesSubscription>() => T;
}

export interface CountryPreviousValues {
  id: Int;
  country?: String;
  countryArabic: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface CountryPreviousValuesPromise
  extends Promise<CountryPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  country: () => Promise<String>;
  countryArabic: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CountryPreviousValuesSubscription
  extends Promise<AsyncIterator<CountryPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  country: () => Promise<AsyncIterator<String>>;
  countryArabic: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface DiseaseSubscriptionPayload {
  mutation: MutationType;
  node: Disease;
  updatedFields: String[];
  previousValues: DiseasePreviousValues;
}

export interface DiseaseSubscriptionPayloadPromise
  extends Promise<DiseaseSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = DiseasePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = DiseasePreviousValuesPromise>() => T;
}

export interface DiseaseSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<DiseaseSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = DiseaseSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = DiseasePreviousValuesSubscription>() => T;
}

export interface DiseasePreviousValues {
  id: Int;
  disease?: String;
  diseaseArabic: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface DiseasePreviousValuesPromise
  extends Promise<DiseasePreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  disease: () => Promise<String>;
  diseaseArabic: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface DiseasePreviousValuesSubscription
  extends Promise<AsyncIterator<DiseasePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  disease: () => Promise<AsyncIterator<String>>;
  diseaseArabic: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface DiseaseCoveredSubscriptionPayload {
  mutation: MutationType;
  node: DiseaseCovered;
  updatedFields: String[];
  previousValues: DiseaseCoveredPreviousValues;
}

export interface DiseaseCoveredSubscriptionPayloadPromise
  extends Promise<DiseaseCoveredSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = DiseaseCoveredPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = DiseaseCoveredPreviousValuesPromise>() => T;
}

export interface DiseaseCoveredSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<DiseaseCoveredSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = DiseaseCoveredSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = DiseaseCoveredPreviousValuesSubscription>() => T;
}

export interface DiseaseCoveredPreviousValues {
  id: Int;
  diseaseId?: Int;
  insuranceCatId?: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface DiseaseCoveredPreviousValuesPromise
  extends Promise<DiseaseCoveredPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  diseaseId: () => Promise<Int>;
  insuranceCatId: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface DiseaseCoveredPreviousValuesSubscription
  extends Promise<AsyncIterator<DiseaseCoveredPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  diseaseId: () => Promise<AsyncIterator<Int>>;
  insuranceCatId: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface DoctorSubscriptionPayload {
  mutation: MutationType;
  node: Doctor;
  updatedFields: String[];
  previousValues: DoctorPreviousValues;
}

export interface DoctorSubscriptionPayloadPromise
  extends Promise<DoctorSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = DoctorPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = DoctorPreviousValuesPromise>() => T;
}

export interface DoctorSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<DoctorSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = DoctorSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = DoctorPreviousValuesSubscription>() => T;
}

export interface DoctorPreviousValues {
  id: Int;
  apiKey: String;
  designation?: String;
  doctorCv: String;
  email?: String;
  gender?: String;
  mohcard?: String;
  mohId: String;
  name?: String;
  nameArabic?: String;
  password: String;
  phone?: String;
  fees?: String;
  picture?: String;
  specialityId?: Int;
  status?: Int;
  updatedAt?: DateTimeOutput;
  createdDate: DateTimeOutput;
}

export interface DoctorPreviousValuesPromise
  extends Promise<DoctorPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  apiKey: () => Promise<String>;
  designation: () => Promise<String>;
  doctorCv: () => Promise<String>;
  email: () => Promise<String>;
  gender: () => Promise<String>;
  mohcard: () => Promise<String>;
  mohId: () => Promise<String>;
  name: () => Promise<String>;
  nameArabic: () => Promise<String>;
  password: () => Promise<String>;
  phone: () => Promise<String>;
  fees: () => Promise<String>;
  picture: () => Promise<String>;
  specialityId: () => Promise<Int>;
  status: () => Promise<Int>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdDate: () => Promise<DateTimeOutput>;
}

export interface DoctorPreviousValuesSubscription
  extends Promise<AsyncIterator<DoctorPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  apiKey: () => Promise<AsyncIterator<String>>;
  designation: () => Promise<AsyncIterator<String>>;
  doctorCv: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  gender: () => Promise<AsyncIterator<String>>;
  mohcard: () => Promise<AsyncIterator<String>>;
  mohId: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  nameArabic: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
  fees: () => Promise<AsyncIterator<String>>;
  picture: () => Promise<AsyncIterator<String>>;
  specialityId: () => Promise<AsyncIterator<Int>>;
  status: () => Promise<AsyncIterator<Int>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdDate: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface DoctorOldSubscriptionPayload {
  mutation: MutationType;
  node: DoctorOld;
  updatedFields: String[];
  previousValues: DoctorOldPreviousValues;
}

export interface DoctorOldSubscriptionPayloadPromise
  extends Promise<DoctorOldSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = DoctorOldPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = DoctorOldPreviousValuesPromise>() => T;
}

export interface DoctorOldSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<DoctorOldSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = DoctorOldSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = DoctorOldPreviousValuesSubscription>() => T;
}

export interface DoctorOldPreviousValues {
  id: Int;
  apiKey: String;
  createdDate: DateTimeOutput;
  designation: String;
  doctorCv: String;
  email?: String;
  gender: String;
  mohcard?: String;
  mohId: String;
  name?: String;
  nameArabic: String;
  password: String;
  phone?: String;
  fees?: String;
  picture?: String;
  status?: Int;
  updatedAt: DateTimeOutput;
}

export interface DoctorOldPreviousValuesPromise
  extends Promise<DoctorOldPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  apiKey: () => Promise<String>;
  createdDate: () => Promise<DateTimeOutput>;
  designation: () => Promise<String>;
  doctorCv: () => Promise<String>;
  email: () => Promise<String>;
  gender: () => Promise<String>;
  mohcard: () => Promise<String>;
  mohId: () => Promise<String>;
  name: () => Promise<String>;
  nameArabic: () => Promise<String>;
  password: () => Promise<String>;
  phone: () => Promise<String>;
  fees: () => Promise<String>;
  picture: () => Promise<String>;
  status: () => Promise<Int>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface DoctorOldPreviousValuesSubscription
  extends Promise<AsyncIterator<DoctorOldPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  apiKey: () => Promise<AsyncIterator<String>>;
  createdDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  designation: () => Promise<AsyncIterator<String>>;
  doctorCv: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  gender: () => Promise<AsyncIterator<String>>;
  mohcard: () => Promise<AsyncIterator<String>>;
  mohId: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  nameArabic: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
  fees: () => Promise<AsyncIterator<String>>;
  picture: () => Promise<AsyncIterator<String>>;
  status: () => Promise<AsyncIterator<Int>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface DoctorSheduleSubscriptionPayload {
  mutation: MutationType;
  node: DoctorShedule;
  updatedFields: String[];
  previousValues: DoctorShedulePreviousValues;
}

export interface DoctorSheduleSubscriptionPayloadPromise
  extends Promise<DoctorSheduleSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = DoctorShedulePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = DoctorShedulePreviousValuesPromise>() => T;
}

export interface DoctorSheduleSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<DoctorSheduleSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = DoctorSheduleSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = DoctorShedulePreviousValuesSubscription>() => T;
}

export interface DoctorShedulePreviousValues {
  id: Int;
  date?: Int;
  doctorId?: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface DoctorShedulePreviousValuesPromise
  extends Promise<DoctorShedulePreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  date: () => Promise<Int>;
  doctorId: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface DoctorShedulePreviousValuesSubscription
  extends Promise<AsyncIterator<DoctorShedulePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  date: () => Promise<AsyncIterator<Int>>;
  doctorId: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface DoctorSheduleTimeSubscriptionPayload {
  mutation: MutationType;
  node: DoctorSheduleTime;
  updatedFields: String[];
  previousValues: DoctorSheduleTimePreviousValues;
}

export interface DoctorSheduleTimeSubscriptionPayloadPromise
  extends Promise<DoctorSheduleTimeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = DoctorSheduleTimePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = DoctorSheduleTimePreviousValuesPromise>() => T;
}

export interface DoctorSheduleTimeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<DoctorSheduleTimeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = DoctorSheduleTimeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = DoctorSheduleTimePreviousValuesSubscription>() => T;
}

export interface DoctorSheduleTimePreviousValues {
  id: Int;
  drSheduleId?: Int;
  scheduleTime?: Int;
  status?: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface DoctorSheduleTimePreviousValuesPromise
  extends Promise<DoctorSheduleTimePreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  drSheduleId: () => Promise<Int>;
  scheduleTime: () => Promise<Int>;
  status: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface DoctorSheduleTimePreviousValuesSubscription
  extends Promise<AsyncIterator<DoctorSheduleTimePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  drSheduleId: () => Promise<AsyncIterator<Int>>;
  scheduleTime: () => Promise<AsyncIterator<Int>>;
  status: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface DoctorsRatingSubscriptionPayload {
  mutation: MutationType;
  node: DoctorsRating;
  updatedFields: String[];
  previousValues: DoctorsRatingPreviousValues;
}

export interface DoctorsRatingSubscriptionPayloadPromise
  extends Promise<DoctorsRatingSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = DoctorsRatingPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = DoctorsRatingPreviousValuesPromise>() => T;
}

export interface DoctorsRatingSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<DoctorsRatingSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = DoctorsRatingSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = DoctorsRatingPreviousValuesSubscription>() => T;
}

export interface DoctorsRatingPreviousValues {
  id: Int;
  rating?: String;
  systemIp: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface DoctorsRatingPreviousValuesPromise
  extends Promise<DoctorsRatingPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  rating: () => Promise<String>;
  systemIp: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface DoctorsRatingPreviousValuesSubscription
  extends Promise<AsyncIterator<DoctorsRatingPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  rating: () => Promise<AsyncIterator<String>>;
  systemIp: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface DrSheduleSubscriptionPayload {
  mutation: MutationType;
  node: DrShedule;
  updatedFields: String[];
  previousValues: DrShedulePreviousValues;
}

export interface DrSheduleSubscriptionPayloadPromise
  extends Promise<DrSheduleSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = DrShedulePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = DrShedulePreviousValuesPromise>() => T;
}

export interface DrSheduleSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<DrSheduleSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = DrSheduleSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = DrShedulePreviousValuesSubscription>() => T;
}

export interface DrShedulePreviousValues {
  id: Int;
  date?: DateTimeOutput;
  doctorId?: Int;
  hospitalId?: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface DrShedulePreviousValuesPromise
  extends Promise<DrShedulePreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  date: () => Promise<DateTimeOutput>;
  doctorId: () => Promise<Int>;
  hospitalId: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface DrShedulePreviousValuesSubscription
  extends Promise<AsyncIterator<DrShedulePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  doctorId: () => Promise<AsyncIterator<Int>>;
  hospitalId: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface EmailSubscriptionSubscriptionPayload {
  mutation: MutationType;
  node: EmailSubscription;
  updatedFields: String[];
  previousValues: EmailSubscriptionPreviousValues;
}

export interface EmailSubscriptionSubscriptionPayloadPromise
  extends Promise<EmailSubscriptionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = EmailSubscriptionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = EmailSubscriptionPreviousValuesPromise>() => T;
}

export interface EmailSubscriptionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<EmailSubscriptionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = EmailSubscriptionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = EmailSubscriptionPreviousValuesSubscription>() => T;
}

export interface EmailSubscriptionPreviousValues {
  id: Int;
  email: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface EmailSubscriptionPreviousValuesPromise
  extends Promise<EmailSubscriptionPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  email: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface EmailSubscriptionPreviousValuesSubscription
  extends Promise<AsyncIterator<EmailSubscriptionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  email: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface FacilitySubscriptionPayload {
  mutation: MutationType;
  node: Facility;
  updatedFields: String[];
  previousValues: FacilityPreviousValues;
}

export interface FacilitySubscriptionPayloadPromise
  extends Promise<FacilitySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = FacilityPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = FacilityPreviousValuesPromise>() => T;
}

export interface FacilitySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<FacilitySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = FacilitySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = FacilityPreviousValuesSubscription>() => T;
}

export interface FacilityPreviousValues {
  id: Int;
  facility?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface FacilityPreviousValuesPromise
  extends Promise<FacilityPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  facility: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface FacilityPreviousValuesSubscription
  extends Promise<AsyncIterator<FacilityPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  facility: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface HospitalSubscriptionPayload {
  mutation: MutationType;
  node: Hospital;
  updatedFields: String[];
  previousValues: HospitalPreviousValues;
}

export interface HospitalSubscriptionPayloadPromise
  extends Promise<HospitalSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = HospitalPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = HospitalPreviousValuesPromise>() => T;
}

export interface HospitalSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<HospitalSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = HospitalSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = HospitalPreviousValuesSubscription>() => T;
}

export interface HospitalPreviousValues {
  id: Int;
  address: String;
  addressArabic: String;
  apiKey: String;
  email?: String;
  hospital?: String;
  hospitalArabic: String;
  language: String;
  latitude: String;
  location: String;
  logo?: String;
  longitude: String;
  password?: String;
  phone?: String;
  phone1: String;
  status?: Int;
  type?: String;
  uniqeId: String;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
  createdDate: DateTimeOutput;
}

export interface HospitalPreviousValuesPromise
  extends Promise<HospitalPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  address: () => Promise<String>;
  addressArabic: () => Promise<String>;
  apiKey: () => Promise<String>;
  email: () => Promise<String>;
  hospital: () => Promise<String>;
  hospitalArabic: () => Promise<String>;
  language: () => Promise<String>;
  latitude: () => Promise<String>;
  location: () => Promise<String>;
  logo: () => Promise<String>;
  longitude: () => Promise<String>;
  password: () => Promise<String>;
  phone: () => Promise<String>;
  phone1: () => Promise<String>;
  status: () => Promise<Int>;
  type: () => Promise<String>;
  uniqeId: () => Promise<String>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  createdDate: () => Promise<DateTimeOutput>;
}

export interface HospitalPreviousValuesSubscription
  extends Promise<AsyncIterator<HospitalPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  address: () => Promise<AsyncIterator<String>>;
  addressArabic: () => Promise<AsyncIterator<String>>;
  apiKey: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  hospital: () => Promise<AsyncIterator<String>>;
  hospitalArabic: () => Promise<AsyncIterator<String>>;
  language: () => Promise<AsyncIterator<String>>;
  latitude: () => Promise<AsyncIterator<String>>;
  location: () => Promise<AsyncIterator<String>>;
  logo: () => Promise<AsyncIterator<String>>;
  longitude: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
  phone1: () => Promise<AsyncIterator<String>>;
  status: () => Promise<AsyncIterator<Int>>;
  type: () => Promise<AsyncIterator<String>>;
  uniqeId: () => Promise<AsyncIterator<String>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdDate: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface HospitalFacilitySubscriptionPayload {
  mutation: MutationType;
  node: HospitalFacility;
  updatedFields: String[];
  previousValues: HospitalFacilityPreviousValues;
}

export interface HospitalFacilitySubscriptionPayloadPromise
  extends Promise<HospitalFacilitySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = HospitalFacilityPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = HospitalFacilityPreviousValuesPromise>() => T;
}

export interface HospitalFacilitySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<HospitalFacilitySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = HospitalFacilitySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = HospitalFacilityPreviousValuesSubscription>() => T;
}

export interface HospitalFacilityPreviousValues {
  id: Int;
  facilityId?: Int;
  hospitalId?: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface HospitalFacilityPreviousValuesPromise
  extends Promise<HospitalFacilityPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  facilityId: () => Promise<Int>;
  hospitalId: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface HospitalFacilityPreviousValuesSubscription
  extends Promise<AsyncIterator<HospitalFacilityPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  facilityId: () => Promise<AsyncIterator<Int>>;
  hospitalId: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface HospitalRatingSubscriptionPayload {
  mutation: MutationType;
  node: HospitalRating;
  updatedFields: String[];
  previousValues: HospitalRatingPreviousValues;
}

export interface HospitalRatingSubscriptionPayloadPromise
  extends Promise<HospitalRatingSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = HospitalRatingPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = HospitalRatingPreviousValuesPromise>() => T;
}

export interface HospitalRatingSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<HospitalRatingSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = HospitalRatingSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = HospitalRatingPreviousValuesSubscription>() => T;
}

export interface HospitalRatingPreviousValues {
  id: Int;
  hospitalId?: Int;
  rating?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface HospitalRatingPreviousValuesPromise
  extends Promise<HospitalRatingPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  hospitalId: () => Promise<Int>;
  rating: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface HospitalRatingPreviousValuesSubscription
  extends Promise<AsyncIterator<HospitalRatingPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  hospitalId: () => Promise<AsyncIterator<Int>>;
  rating: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface IllnessSubscriptionPayload {
  mutation: MutationType;
  node: Illness;
  updatedFields: String[];
  previousValues: IllnessPreviousValues;
}

export interface IllnessSubscriptionPayloadPromise
  extends Promise<IllnessSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = IllnessPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = IllnessPreviousValuesPromise>() => T;
}

export interface IllnessSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<IllnessSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = IllnessSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = IllnessPreviousValuesSubscription>() => T;
}

export interface IllnessPreviousValues {
  id: Int;
  illness?: String;
  illnessArabic?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface IllnessPreviousValuesPromise
  extends Promise<IllnessPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  illness: () => Promise<String>;
  illnessArabic: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface IllnessPreviousValuesSubscription
  extends Promise<AsyncIterator<IllnessPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  illness: () => Promise<AsyncIterator<String>>;
  illnessArabic: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface InsuranceSubscriptionPayload {
  mutation: MutationType;
  node: Insurance;
  updatedFields: String[];
  previousValues: InsurancePreviousValues;
}

export interface InsuranceSubscriptionPayloadPromise
  extends Promise<InsuranceSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = InsurancePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = InsurancePreviousValuesPromise>() => T;
}

export interface InsuranceSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<InsuranceSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = InsuranceSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = InsurancePreviousValuesSubscription>() => T;
}

export interface InsurancePreviousValues {
  id: Int;
  countryId: Int;
  insurance?: String;
  insuranceArabic?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface InsurancePreviousValuesPromise
  extends Promise<InsurancePreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  countryId: () => Promise<Int>;
  insurance: () => Promise<String>;
  insuranceArabic: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface InsurancePreviousValuesSubscription
  extends Promise<AsyncIterator<InsurancePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  countryId: () => Promise<AsyncIterator<Int>>;
  insurance: () => Promise<AsyncIterator<String>>;
  insuranceArabic: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface InsuranceCategorySubscriptionPayload {
  mutation: MutationType;
  node: InsuranceCategory;
  updatedFields: String[];
  previousValues: InsuranceCategoryPreviousValues;
}

export interface InsuranceCategorySubscriptionPayloadPromise
  extends Promise<InsuranceCategorySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = InsuranceCategoryPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = InsuranceCategoryPreviousValuesPromise>() => T;
}

export interface InsuranceCategorySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<InsuranceCategorySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = InsuranceCategorySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = InsuranceCategoryPreviousValuesSubscription>() => T;
}

export interface InsuranceCategoryPreviousValues {
  id: Int;
  category?: String;
  insuranceId?: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface InsuranceCategoryPreviousValuesPromise
  extends Promise<InsuranceCategoryPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  category: () => Promise<String>;
  insuranceId: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface InsuranceCategoryPreviousValuesSubscription
  extends Promise<AsyncIterator<InsuranceCategoryPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  category: () => Promise<AsyncIterator<String>>;
  insuranceId: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface JobSubscriptionPayload {
  mutation: MutationType;
  node: Job;
  updatedFields: String[];
  previousValues: JobPreviousValues;
}

export interface JobSubscriptionPayloadPromise
  extends Promise<JobSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = JobPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = JobPreviousValuesPromise>() => T;
}

export interface JobSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<JobSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = JobSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = JobPreviousValuesSubscription>() => T;
}

export interface JobPreviousValues {
  id: Int;
  position: String;
  positionArabic: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface JobPreviousValuesPromise
  extends Promise<JobPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  position: () => Promise<String>;
  positionArabic: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface JobPreviousValuesSubscription
  extends Promise<AsyncIterator<JobPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  position: () => Promise<AsyncIterator<String>>;
  positionArabic: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface LanguageSubscriptionPayload {
  mutation: MutationType;
  node: Language;
  updatedFields: String[];
  previousValues: LanguagePreviousValues;
}

export interface LanguageSubscriptionPayloadPromise
  extends Promise<LanguageSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = LanguagePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = LanguagePreviousValuesPromise>() => T;
}

export interface LanguageSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<LanguageSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = LanguageSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = LanguagePreviousValuesSubscription>() => T;
}

export interface LanguagePreviousValues {
  id: Int;
  language?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface LanguagePreviousValuesPromise
  extends Promise<LanguagePreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  language: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface LanguagePreviousValuesSubscription
  extends Promise<AsyncIterator<LanguagePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  language: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface MessageSubscriptionPayload {
  mutation: MutationType;
  node: Message;
  updatedFields: String[];
  previousValues: MessagePreviousValues;
}

export interface MessageSubscriptionPayloadPromise
  extends Promise<MessageSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = MessagePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = MessagePreviousValuesPromise>() => T;
}

export interface MessageSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<MessageSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = MessageSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = MessagePreviousValuesSubscription>() => T;
}

export interface MessagePreviousValues {
  id: Int;
  fromUser: Int;
  isDelete: Int;
  isRead: Int;
  logCreate: DateTimeOutput;
  message: String;
  sentBy: Int;
  toUser: Int;
  updatedAt: DateTimeOutput;
}

export interface MessagePreviousValuesPromise
  extends Promise<MessagePreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  fromUser: () => Promise<Int>;
  isDelete: () => Promise<Int>;
  isRead: () => Promise<Int>;
  logCreate: () => Promise<DateTimeOutput>;
  message: () => Promise<String>;
  sentBy: () => Promise<Int>;
  toUser: () => Promise<Int>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface MessagePreviousValuesSubscription
  extends Promise<AsyncIterator<MessagePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  fromUser: () => Promise<AsyncIterator<Int>>;
  isDelete: () => Promise<AsyncIterator<Int>>;
  isRead: () => Promise<AsyncIterator<Int>>;
  logCreate: () => Promise<AsyncIterator<DateTimeOutput>>;
  message: () => Promise<AsyncIterator<String>>;
  sentBy: () => Promise<AsyncIterator<Int>>;
  toUser: () => Promise<AsyncIterator<Int>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface MigrationSubscriptionPayload {
  mutation: MutationType;
  node: Migration;
  updatedFields: String[];
  previousValues: MigrationPreviousValues;
}

export interface MigrationSubscriptionPayloadPromise
  extends Promise<MigrationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = MigrationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = MigrationPreviousValuesPromise>() => T;
}

export interface MigrationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<MigrationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = MigrationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = MigrationPreviousValuesSubscription>() => T;
}

export interface MigrationPreviousValues {
  id: Int;
  batch: Int;
  migration: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface MigrationPreviousValuesPromise
  extends Promise<MigrationPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  batch: () => Promise<Int>;
  migration: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface MigrationPreviousValuesSubscription
  extends Promise<AsyncIterator<MigrationPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  batch: () => Promise<AsyncIterator<Int>>;
  migration: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface OfferSubscriptionPayload {
  mutation: MutationType;
  node: Offer;
  updatedFields: String[];
  previousValues: OfferPreviousValues;
}

export interface OfferSubscriptionPayloadPromise
  extends Promise<OfferSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = OfferPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = OfferPreviousValuesPromise>() => T;
}

export interface OfferSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<OfferSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = OfferSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = OfferPreviousValuesSubscription>() => T;
}

export interface OfferPreviousValues {
  id: Int;
  description: String;
  descriptionArabic: String;
  endDate: DateTimeOutput;
  heading: String;
  headingArabic: String;
  hospitalId: Int;
  offerImage: String;
  position: Int;
  startDate: DateTimeOutput;
  status: Int;
  type: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface OfferPreviousValuesPromise
  extends Promise<OfferPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  description: () => Promise<String>;
  descriptionArabic: () => Promise<String>;
  endDate: () => Promise<DateTimeOutput>;
  heading: () => Promise<String>;
  headingArabic: () => Promise<String>;
  hospitalId: () => Promise<Int>;
  offerImage: () => Promise<String>;
  position: () => Promise<Int>;
  startDate: () => Promise<DateTimeOutput>;
  status: () => Promise<Int>;
  type: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface OfferPreviousValuesSubscription
  extends Promise<AsyncIterator<OfferPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  description: () => Promise<AsyncIterator<String>>;
  descriptionArabic: () => Promise<AsyncIterator<String>>;
  endDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  heading: () => Promise<AsyncIterator<String>>;
  headingArabic: () => Promise<AsyncIterator<String>>;
  hospitalId: () => Promise<AsyncIterator<Int>>;
  offerImage: () => Promise<AsyncIterator<String>>;
  position: () => Promise<AsyncIterator<Int>>;
  startDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  status: () => Promise<AsyncIterator<Int>>;
  type: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface OnlineAppointmentSubscriptionPayload {
  mutation: MutationType;
  node: OnlineAppointment;
  updatedFields: String[];
  previousValues: OnlineAppointmentPreviousValues;
}

export interface OnlineAppointmentSubscriptionPayloadPromise
  extends Promise<OnlineAppointmentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = OnlineAppointmentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = OnlineAppointmentPreviousValuesPromise>() => T;
}

export interface OnlineAppointmentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<OnlineAppointmentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = OnlineAppointmentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = OnlineAppointmentPreviousValuesSubscription>() => T;
}

export interface OnlineAppointmentPreviousValues {
  id: Int;
  apointmentDate: String;
  apointmentFulldate: Int;
  apointmentTime: String;
  diseaseId?: Int;
  doctorArabic: String;
  doctorId?: Int;
  doctorName: String;
  dtId?: Int;
  gender: String;
  optId?: Int;
  patientId?: Int;
  phone: String;
  phoneCode?: String;
  scheduleTimeId: Int;
  status?: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface OnlineAppointmentPreviousValuesPromise
  extends Promise<OnlineAppointmentPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  apointmentDate: () => Promise<String>;
  apointmentFulldate: () => Promise<Int>;
  apointmentTime: () => Promise<String>;
  diseaseId: () => Promise<Int>;
  doctorArabic: () => Promise<String>;
  doctorId: () => Promise<Int>;
  doctorName: () => Promise<String>;
  dtId: () => Promise<Int>;
  gender: () => Promise<String>;
  optId: () => Promise<Int>;
  patientId: () => Promise<Int>;
  phone: () => Promise<String>;
  phoneCode: () => Promise<String>;
  scheduleTimeId: () => Promise<Int>;
  status: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface OnlineAppointmentPreviousValuesSubscription
  extends Promise<AsyncIterator<OnlineAppointmentPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  apointmentDate: () => Promise<AsyncIterator<String>>;
  apointmentFulldate: () => Promise<AsyncIterator<Int>>;
  apointmentTime: () => Promise<AsyncIterator<String>>;
  diseaseId: () => Promise<AsyncIterator<Int>>;
  doctorArabic: () => Promise<AsyncIterator<String>>;
  doctorId: () => Promise<AsyncIterator<Int>>;
  doctorName: () => Promise<AsyncIterator<String>>;
  dtId: () => Promise<AsyncIterator<Int>>;
  gender: () => Promise<AsyncIterator<String>>;
  optId: () => Promise<AsyncIterator<Int>>;
  patientId: () => Promise<AsyncIterator<Int>>;
  phone: () => Promise<AsyncIterator<String>>;
  phoneCode: () => Promise<AsyncIterator<String>>;
  scheduleTimeId: () => Promise<AsyncIterator<Int>>;
  status: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface OnlineDoctorSubscriptionPayload {
  mutation: MutationType;
  node: OnlineDoctor;
  updatedFields: String[];
  previousValues: OnlineDoctorPreviousValues;
}

export interface OnlineDoctorSubscriptionPayloadPromise
  extends Promise<OnlineDoctorSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = OnlineDoctorPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = OnlineDoctorPreviousValuesPromise>() => T;
}

export interface OnlineDoctorSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<OnlineDoctorSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = OnlineDoctorSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = OnlineDoctorPreviousValuesSubscription>() => T;
}

export interface OnlineDoctorPreviousValues {
  id: Int;
  apiKey: String;
  createdDate: DateTimeOutput;
  designation: String;
  doctorCv: String;
  email?: String;
  gender: String;
  lastSeen: DateTimeOutput;
  mohcard?: String;
  mohId: String;
  name?: String;
  nameArabic: String;
  password: String;
  phone?: String;
  picture?: String;
  specialityId?: Int;
  status?: Int;
}

export interface OnlineDoctorPreviousValuesPromise
  extends Promise<OnlineDoctorPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  apiKey: () => Promise<String>;
  createdDate: () => Promise<DateTimeOutput>;
  designation: () => Promise<String>;
  doctorCv: () => Promise<String>;
  email: () => Promise<String>;
  gender: () => Promise<String>;
  lastSeen: () => Promise<DateTimeOutput>;
  mohcard: () => Promise<String>;
  mohId: () => Promise<String>;
  name: () => Promise<String>;
  nameArabic: () => Promise<String>;
  password: () => Promise<String>;
  phone: () => Promise<String>;
  picture: () => Promise<String>;
  specialityId: () => Promise<Int>;
  status: () => Promise<Int>;
}

export interface OnlineDoctorPreviousValuesSubscription
  extends Promise<AsyncIterator<OnlineDoctorPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  apiKey: () => Promise<AsyncIterator<String>>;
  createdDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  designation: () => Promise<AsyncIterator<String>>;
  doctorCv: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  gender: () => Promise<AsyncIterator<String>>;
  lastSeen: () => Promise<AsyncIterator<DateTimeOutput>>;
  mohcard: () => Promise<AsyncIterator<String>>;
  mohId: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  nameArabic: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
  picture: () => Promise<AsyncIterator<String>>;
  specialityId: () => Promise<AsyncIterator<Int>>;
  status: () => Promise<AsyncIterator<Int>>;
}

export interface OnlineRatingSubscriptionPayload {
  mutation: MutationType;
  node: OnlineRating;
  updatedFields: String[];
  previousValues: OnlineRatingPreviousValues;
}

export interface OnlineRatingSubscriptionPayloadPromise
  extends Promise<OnlineRatingSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = OnlineRatingPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = OnlineRatingPreviousValuesPromise>() => T;
}

export interface OnlineRatingSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<OnlineRatingSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = OnlineRatingSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = OnlineRatingPreviousValuesSubscription>() => T;
}

export interface OnlineRatingPreviousValues {
  id: Int;
  doctorsId?: Int;
  rating?: String;
  systemIp: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface OnlineRatingPreviousValuesPromise
  extends Promise<OnlineRatingPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  doctorsId: () => Promise<Int>;
  rating: () => Promise<String>;
  systemIp: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface OnlineRatingPreviousValuesSubscription
  extends Promise<AsyncIterator<OnlineRatingPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  doctorsId: () => Promise<AsyncIterator<Int>>;
  rating: () => Promise<AsyncIterator<String>>;
  systemIp: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface OptTimeSubscriptionPayload {
  mutation: MutationType;
  node: OptTime;
  updatedFields: String[];
  previousValues: OptTimePreviousValues;
}

export interface OptTimeSubscriptionPayloadPromise
  extends Promise<OptTimeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = OptTimePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = OptTimePreviousValuesPromise>() => T;
}

export interface OptTimeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<OptTimeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = OptTimeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = OptTimePreviousValuesSubscription>() => T;
}

export interface OptTimePreviousValues {
  id: Int;
  fifteenMins?: String;
  thirtyMins?: String;
  twentyMins?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface OptTimePreviousValuesPromise
  extends Promise<OptTimePreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  fifteenMins: () => Promise<String>;
  thirtyMins: () => Promise<String>;
  twentyMins: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface OptTimePreviousValuesSubscription
  extends Promise<AsyncIterator<OptTimePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  fifteenMins: () => Promise<AsyncIterator<String>>;
  thirtyMins: () => Promise<AsyncIterator<String>>;
  twentyMins: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PageSubscriptionPayload {
  mutation: MutationType;
  node: Page;
  updatedFields: String[];
  previousValues: PagePreviousValues;
}

export interface PageSubscriptionPayloadPromise
  extends Promise<PageSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PagePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PagePreviousValuesPromise>() => T;
}

export interface PageSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PageSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PageSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PagePreviousValuesSubscription>() => T;
}

export interface PagePreviousValues {
  id: Int;
  slug?: String;
  slug_ar?: String;
  title?: String;
  title_ar?: String;
  content?: String;
  content_ar?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface PagePreviousValuesPromise
  extends Promise<PagePreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  slug: () => Promise<String>;
  slug_ar: () => Promise<String>;
  title: () => Promise<String>;
  title_ar: () => Promise<String>;
  content: () => Promise<String>;
  content_ar: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PagePreviousValuesSubscription
  extends Promise<AsyncIterator<PagePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  slug: () => Promise<AsyncIterator<String>>;
  slug_ar: () => Promise<AsyncIterator<String>>;
  title: () => Promise<AsyncIterator<String>>;
  title_ar: () => Promise<AsyncIterator<String>>;
  content: () => Promise<AsyncIterator<String>>;
  content_ar: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PasswordResetSubscriptionPayload {
  mutation: MutationType;
  node: PasswordReset;
  updatedFields: String[];
  previousValues: PasswordResetPreviousValues;
}

export interface PasswordResetSubscriptionPayloadPromise
  extends Promise<PasswordResetSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PasswordResetPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PasswordResetPreviousValuesPromise>() => T;
}

export interface PasswordResetSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PasswordResetSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PasswordResetSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PasswordResetPreviousValuesSubscription>() => T;
}

export interface PasswordResetPreviousValues {
  id: Int;
  createdAt: DateTimeOutput;
  email: String;
  token: String;
  updatedAt: DateTimeOutput;
}

export interface PasswordResetPreviousValuesPromise
  extends Promise<PasswordResetPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  email: () => Promise<String>;
  token: () => Promise<String>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PasswordResetPreviousValuesSubscription
  extends Promise<AsyncIterator<PasswordResetPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  email: () => Promise<AsyncIterator<String>>;
  token: () => Promise<AsyncIterator<String>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PatientSubscriptionPayload {
  mutation: MutationType;
  node: Patient;
  updatedFields: String[];
  previousValues: PatientPreviousValues;
}

export interface PatientSubscriptionPayloadPromise
  extends Promise<PatientSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PatientPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PatientPreviousValuesPromise>() => T;
}

export interface PatientSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PatientSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PatientSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PatientPreviousValuesSubscription>() => T;
}

export interface PatientPreviousValues {
  id: Int;
  age: Int;
  apiKey: String;
  createdDate: DateTimeOutput;
  dob?: String;
  email?: String;
  gender?: String;
  lastAction: String;
  lastSeen: DateTimeOutput;
  mailSubs?: Int;
  mobile?: String;
  name?: String;
  password?: String;
  status: Int;
  uniqeId: String;
}

export interface PatientPreviousValuesPromise
  extends Promise<PatientPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  age: () => Promise<Int>;
  apiKey: () => Promise<String>;
  createdDate: () => Promise<DateTimeOutput>;
  dob: () => Promise<String>;
  email: () => Promise<String>;
  gender: () => Promise<String>;
  lastAction: () => Promise<String>;
  lastSeen: () => Promise<DateTimeOutput>;
  mailSubs: () => Promise<Int>;
  mobile: () => Promise<String>;
  name: () => Promise<String>;
  password: () => Promise<String>;
  status: () => Promise<Int>;
  uniqeId: () => Promise<String>;
}

export interface PatientPreviousValuesSubscription
  extends Promise<AsyncIterator<PatientPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  age: () => Promise<AsyncIterator<Int>>;
  apiKey: () => Promise<AsyncIterator<String>>;
  createdDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  dob: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  gender: () => Promise<AsyncIterator<String>>;
  lastAction: () => Promise<AsyncIterator<String>>;
  lastSeen: () => Promise<AsyncIterator<DateTimeOutput>>;
  mailSubs: () => Promise<AsyncIterator<Int>>;
  mobile: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  status: () => Promise<AsyncIterator<Int>>;
  uniqeId: () => Promise<AsyncIterator<String>>;
}

export interface PostImageSubscriptionPayload {
  mutation: MutationType;
  node: PostImage;
  updatedFields: String[];
  previousValues: PostImagePreviousValues;
}

export interface PostImageSubscriptionPayloadPromise
  extends Promise<PostImageSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PostImagePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PostImagePreviousValuesPromise>() => T;
}

export interface PostImageSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PostImageSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PostImageSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PostImagePreviousValuesSubscription>() => T;
}

export interface PostImagePreviousValues {
  id: Int;
  isDefault: Int;
  pic: String;
  createdAt?: DateTimeOutput;
  updatedAt?: DateTimeOutput;
}

export interface PostImagePreviousValuesPromise
  extends Promise<PostImagePreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  isDefault: () => Promise<Int>;
  pic: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PostImagePreviousValuesSubscription
  extends Promise<AsyncIterator<PostImagePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  isDefault: () => Promise<AsyncIterator<Int>>;
  pic: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface SearchDesignSubscriptionPayload {
  mutation: MutationType;
  node: SearchDesign;
  updatedFields: String[];
  previousValues: SearchDesignPreviousValues;
}

export interface SearchDesignSubscriptionPayloadPromise
  extends Promise<SearchDesignSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SearchDesignPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SearchDesignPreviousValuesPromise>() => T;
}

export interface SearchDesignSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SearchDesignSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SearchDesignSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SearchDesignPreviousValuesSubscription>() => T;
}

export interface SearchDesignPreviousValues {
  id: Int;
  addressColor: String;
  addressFamily: String;
  addressStyle: String;
  designationColor: String;
  designationFamily: String;
  designationStyle: String;
  doctorColor: String;
  doctorFamily: String;
  doctorStyle: String;
  emailColor: String;
  emailFamily: String;
  emailStyle: String;
  nameColor: String;
  nameFamily: String;
  nameStyle: String;
  phoneColor: String;
  phoneFamily: String;
  phoneStyle: String;
  ratingColor: String;
  ratingFamily: String;
  ratingStyle: String;
  specialityColor: String;
  specialityFamily: String;
  specialityStyle: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface SearchDesignPreviousValuesPromise
  extends Promise<SearchDesignPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  addressColor: () => Promise<String>;
  addressFamily: () => Promise<String>;
  addressStyle: () => Promise<String>;
  designationColor: () => Promise<String>;
  designationFamily: () => Promise<String>;
  designationStyle: () => Promise<String>;
  doctorColor: () => Promise<String>;
  doctorFamily: () => Promise<String>;
  doctorStyle: () => Promise<String>;
  emailColor: () => Promise<String>;
  emailFamily: () => Promise<String>;
  emailStyle: () => Promise<String>;
  nameColor: () => Promise<String>;
  nameFamily: () => Promise<String>;
  nameStyle: () => Promise<String>;
  phoneColor: () => Promise<String>;
  phoneFamily: () => Promise<String>;
  phoneStyle: () => Promise<String>;
  ratingColor: () => Promise<String>;
  ratingFamily: () => Promise<String>;
  ratingStyle: () => Promise<String>;
  specialityColor: () => Promise<String>;
  specialityFamily: () => Promise<String>;
  specialityStyle: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface SearchDesignPreviousValuesSubscription
  extends Promise<AsyncIterator<SearchDesignPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  addressColor: () => Promise<AsyncIterator<String>>;
  addressFamily: () => Promise<AsyncIterator<String>>;
  addressStyle: () => Promise<AsyncIterator<String>>;
  designationColor: () => Promise<AsyncIterator<String>>;
  designationFamily: () => Promise<AsyncIterator<String>>;
  designationStyle: () => Promise<AsyncIterator<String>>;
  doctorColor: () => Promise<AsyncIterator<String>>;
  doctorFamily: () => Promise<AsyncIterator<String>>;
  doctorStyle: () => Promise<AsyncIterator<String>>;
  emailColor: () => Promise<AsyncIterator<String>>;
  emailFamily: () => Promise<AsyncIterator<String>>;
  emailStyle: () => Promise<AsyncIterator<String>>;
  nameColor: () => Promise<AsyncIterator<String>>;
  nameFamily: () => Promise<AsyncIterator<String>>;
  nameStyle: () => Promise<AsyncIterator<String>>;
  phoneColor: () => Promise<AsyncIterator<String>>;
  phoneFamily: () => Promise<AsyncIterator<String>>;
  phoneStyle: () => Promise<AsyncIterator<String>>;
  ratingColor: () => Promise<AsyncIterator<String>>;
  ratingFamily: () => Promise<AsyncIterator<String>>;
  ratingStyle: () => Promise<AsyncIterator<String>>;
  specialityColor: () => Promise<AsyncIterator<String>>;
  specialityFamily: () => Promise<AsyncIterator<String>>;
  specialityStyle: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface SheduleTimeSubscriptionPayload {
  mutation: MutationType;
  node: SheduleTime;
  updatedFields: String[];
  previousValues: SheduleTimePreviousValues;
}

export interface SheduleTimeSubscriptionPayloadPromise
  extends Promise<SheduleTimeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SheduleTimePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SheduleTimePreviousValuesPromise>() => T;
}

export interface SheduleTimeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SheduleTimeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SheduleTimeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SheduleTimePreviousValuesSubscription>() => T;
}

export interface SheduleTimePreviousValues {
  id: Int;
  drSheduleId?: Int;
  scheduleFullDate: Int;
  sheduleTime?: String;
  status?: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface SheduleTimePreviousValuesPromise
  extends Promise<SheduleTimePreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  drSheduleId: () => Promise<Int>;
  scheduleFullDate: () => Promise<Int>;
  sheduleTime: () => Promise<String>;
  status: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface SheduleTimePreviousValuesSubscription
  extends Promise<AsyncIterator<SheduleTimePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  drSheduleId: () => Promise<AsyncIterator<Int>>;
  scheduleFullDate: () => Promise<AsyncIterator<Int>>;
  sheduleTime: () => Promise<AsyncIterator<String>>;
  status: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface SliderSubscriptionPayload {
  mutation: MutationType;
  node: Slider;
  updatedFields: String[];
  previousValues: SliderPreviousValues;
}

export interface SliderSubscriptionPayloadPromise
  extends Promise<SliderSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SliderPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SliderPreviousValuesPromise>() => T;
}

export interface SliderSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SliderSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SliderSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SliderPreviousValuesSubscription>() => T;
}

export interface SliderPreviousValues {
  id: Int;
  arabicHeading: String;
  banner: String;
  heading: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface SliderPreviousValuesPromise
  extends Promise<SliderPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  arabicHeading: () => Promise<String>;
  banner: () => Promise<String>;
  heading: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface SliderPreviousValuesSubscription
  extends Promise<AsyncIterator<SliderPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  arabicHeading: () => Promise<AsyncIterator<String>>;
  banner: () => Promise<AsyncIterator<String>>;
  heading: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface SpecialitySubscriptionPayload {
  mutation: MutationType;
  node: Speciality;
  updatedFields: String[];
  previousValues: SpecialityPreviousValues;
}

export interface SpecialitySubscriptionPayloadPromise
  extends Promise<SpecialitySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SpecialityPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SpecialityPreviousValuesPromise>() => T;
}

export interface SpecialitySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SpecialitySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SpecialitySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SpecialityPreviousValuesSubscription>() => T;
}

export interface SpecialityPreviousValues {
  id: Int;
  speciality?: String;
  specialityArabic?: String;
  createdAt?: DateTimeOutput;
  updatedAt?: DateTimeOutput;
}

export interface SpecialityPreviousValuesPromise
  extends Promise<SpecialityPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  speciality: () => Promise<String>;
  specialityArabic: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface SpecialityPreviousValuesSubscription
  extends Promise<AsyncIterator<SpecialityPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  speciality: () => Promise<AsyncIterator<String>>;
  specialityArabic: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface TranslationSubscriptionPayload {
  mutation: MutationType;
  node: Translation;
  updatedFields: String[];
  previousValues: TranslationPreviousValues;
}

export interface TranslationSubscriptionPayloadPromise
  extends Promise<TranslationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TranslationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TranslationPreviousValuesPromise>() => T;
}

export interface TranslationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TranslationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TranslationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TranslationPreviousValuesSubscription>() => T;
}

export interface TranslationPreviousValues {
  id: Int;
  arabi: String;
  english: String;
  index: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface TranslationPreviousValuesPromise
  extends Promise<TranslationPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  arabi: () => Promise<String>;
  english: () => Promise<String>;
  index: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface TranslationPreviousValuesSubscription
  extends Promise<AsyncIterator<TranslationPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  arabi: () => Promise<AsyncIterator<String>>;
  english: () => Promise<AsyncIterator<String>>;
  index: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface UserPreviousValues {
  id: Int;
  createdAt: DateTimeOutput;
  email: String;
  name: String;
  password: String;
  rememberToken?: String;
  updatedAt: DateTimeOutput;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  email: () => Promise<String>;
  name: () => Promise<String>;
  password: () => Promise<String>;
  rememberToken: () => Promise<String>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  email: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  rememberToken: () => Promise<AsyncIterator<String>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface VideoRequestSubscriptionPayload {
  mutation: MutationType;
  node: VideoRequest;
  updatedFields: String[];
  previousValues: VideoRequestPreviousValues;
}

export interface VideoRequestSubscriptionPayloadPromise
  extends Promise<VideoRequestSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = VideoRequestPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = VideoRequestPreviousValuesPromise>() => T;
}

export interface VideoRequestSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<VideoRequestSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = VideoRequestSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = VideoRequestPreviousValuesSubscription>() => T;
}

export interface VideoRequestPreviousValues {
  id: Int;
  doctorId: Int;
  joinCall: Int;
  patientId: Int;
  requestDate: Int;
  videoCode: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface VideoRequestPreviousValuesPromise
  extends Promise<VideoRequestPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  doctorId: () => Promise<Int>;
  joinCall: () => Promise<Int>;
  patientId: () => Promise<Int>;
  requestDate: () => Promise<Int>;
  videoCode: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface VideoRequestPreviousValuesSubscription
  extends Promise<AsyncIterator<VideoRequestPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  doctorId: () => Promise<AsyncIterator<Int>>;
  joinCall: () => Promise<AsyncIterator<Int>>;
  patientId: () => Promise<AsyncIterator<Int>>;
  requestDate: () => Promise<AsyncIterator<Int>>;
  videoCode: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface VisitorSubscriptionPayload {
  mutation: MutationType;
  node: Visitor;
  updatedFields: String[];
  previousValues: VisitorPreviousValues;
}

export interface VisitorSubscriptionPayloadPromise
  extends Promise<VisitorSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = VisitorPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = VisitorPreviousValuesPromise>() => T;
}

export interface VisitorSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<VisitorSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = VisitorSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = VisitorPreviousValuesSubscription>() => T;
}

export interface VisitorPreviousValues {
  id: Int;
  country?: String;
  hits: Int;
  ipAddress: String;
  visitDate: DateTimeOutput;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface VisitorPreviousValuesPromise
  extends Promise<VisitorPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  country: () => Promise<String>;
  hits: () => Promise<Int>;
  ipAddress: () => Promise<String>;
  visitDate: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface VisitorPreviousValuesSubscription
  extends Promise<AsyncIterator<VisitorPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  country: () => Promise<AsyncIterator<String>>;
  hits: () => Promise<AsyncIterator<Int>>;
  ipAddress: () => Promise<AsyncIterator<String>>;
  visitDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "AboutUs",
    embedded: false
  },
  {
    name: "Admin",
    embedded: false
  },
  {
    name: "Appointment",
    embedded: false
  },
  {
    name: "Blog",
    embedded: false
  },
  {
    name: "BlogComment",
    embedded: false
  },
  {
    name: "BlogPost",
    embedded: false
  },
  {
    name: "PostImage",
    embedded: false
  },
  {
    name: "City",
    embedded: false
  },
  {
    name: "ContactUs",
    embedded: false
  },
  {
    name: "Country",
    embedded: false
  },
  {
    name: "Disease",
    embedded: false
  },
  {
    name: "DiseaseCovered",
    embedded: false
  },
  {
    name: "Doctor",
    embedded: false
  },
  {
    name: "DoctorOld",
    embedded: false
  },
  {
    name: "DoctorShedule",
    embedded: false
  },
  {
    name: "DoctorSheduleTime",
    embedded: false
  },
  {
    name: "DoctorSpeciality",
    embedded: false
  },
  {
    name: "DoctorsRating",
    embedded: false
  },
  {
    name: "DrShedule",
    embedded: false
  },
  {
    name: "Facility",
    embedded: false
  },
  {
    name: "Hospital",
    embedded: false
  },
  {
    name: "HospitalDoctor",
    embedded: false
  },
  {
    name: "HospitalFacility",
    embedded: false
  },
  {
    name: "HospitalInsurance",
    embedded: false
  },
  {
    name: "HospitalRating",
    embedded: false
  },
  {
    name: "Illness",
    embedded: false
  },
  {
    name: "Insurance",
    embedded: false
  },
  {
    name: "InsuranceCategory",
    embedded: false
  },
  {
    name: "Job",
    embedded: false
  },
  {
    name: "Language",
    embedded: false
  },
  {
    name: "Message",
    embedded: false
  },
  {
    name: "Migration",
    embedded: false
  },
  {
    name: "Offer",
    embedded: false
  },
  {
    name: "OnlineAppointment",
    embedded: false
  },
  {
    name: "OnlineDoctor",
    embedded: false
  },
  {
    name: "OnlineRating",
    embedded: false
  },
  {
    name: "OptTime",
    embedded: false
  },
  {
    name: "PasswordReset",
    embedded: false
  },
  {
    name: "Patient",
    embedded: false
  },
  {
    name: "SearchDesign",
    embedded: false
  },
  {
    name: "SheduleTime",
    embedded: false
  },
  {
    name: "Slider",
    embedded: false
  },
  {
    name: "Speciality",
    embedded: false
  },
  {
    name: "EmailSubscription",
    embedded: false
  },
  {
    name: "User",
    embedded: false
  },
  {
    name: "VideoRequest",
    embedded: false
  },
  {
    name: "Visitor",
    embedded: false
  },
  {
    name: "Translation",
    embedded: false
  },
  {
    name: "Page",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const Prisma = makePrismaClientClass<ClientConstructor<Prisma>>({
  typeDefs,
  models,
  endpoint: `https://prisma.hakeemy.com/hakeemy/default`
});
export const prisma = new Prisma();
