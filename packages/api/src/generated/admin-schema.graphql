### This file was autogenerated by GraphQL Nexus
### Do not make changes to this file directly


type Admin {
  createdAt: DateTime!
  email: String!
  id: Int!
  pass: String
  superAdmin: Int!
  updatedAt: DateTime!
  user: String
}

type AdminAuthPayload {
  admin: Admin
  token: String
}

type AdminConnection {
  aggregate: AggregateAdmin!
  edges: [AdminEdge!]!
  pageInfo: PageInfo!
}

input AdminCreateInput {
  email: String!
  id: Int
  pass: String
  superAdmin: Int
  user: String
}

type AdminEdge {
  cursor: String!
  node: Admin!
}

enum AdminOrderByInput {
  createdAt_ASC
  createdAt_DESC
  email_ASC
  email_DESC
  id_ASC
  id_DESC
  pass_ASC
  pass_DESC
  superAdmin_ASC
  superAdmin_DESC
  updatedAt_ASC
  updatedAt_DESC
  user_ASC
  user_DESC
}

input AdminUpdateInput {
  email: String
  pass: String
  superAdmin: Int
  user: String
}

input AdminWhereInput {
  AND: [AdminWhereInput!]
  createdAt: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdAt_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_not: DateTime
  createdAt_not_in: [DateTime!]
  email: String
  email_contains: String
  email_ends_with: String
  email_gt: String
  email_gte: String
  email_in: [String!]
  email_lt: String
  email_lte: String
  email_not: String
  email_not_contains: String
  email_not_ends_with: String
  email_not_in: [String!]
  email_not_starts_with: String
  email_starts_with: String
  id: Int
  id_gt: Int
  id_gte: Int
  id_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_not: Int
  id_not_in: [Int!]
  NOT: [AdminWhereInput!]
  OR: [AdminWhereInput!]
  pass: String
  pass_contains: String
  pass_ends_with: String
  pass_gt: String
  pass_gte: String
  pass_in: [String!]
  pass_lt: String
  pass_lte: String
  pass_not: String
  pass_not_contains: String
  pass_not_ends_with: String
  pass_not_in: [String!]
  pass_not_starts_with: String
  pass_starts_with: String
  superAdmin: Int
  superAdmin_gt: Int
  superAdmin_gte: Int
  superAdmin_in: [Int!]
  superAdmin_lt: Int
  superAdmin_lte: Int
  superAdmin_not: Int
  superAdmin_not_in: [Int!]
  updatedAt: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_not: DateTime
  updatedAt_not_in: [DateTime!]
  user: String
  user_contains: String
  user_ends_with: String
  user_gt: String
  user_gte: String
  user_in: [String!]
  user_lt: String
  user_lte: String
  user_not: String
  user_not_contains: String
  user_not_ends_with: String
  user_not_in: [String!]
  user_not_starts_with: String
  user_starts_with: String
}

input AdminWhereUniqueInput {
  email: String
  id: Int
  user: String
}

type AggregateAdmin {
  count: Int!
}

type AggregatePage {
  count: Int!
}

type AggregateTranslation {
  count: Int!
}

type AggregateUser {
  count: Int!
}

scalar DateTime

type Mutation {
  createAdmin(data: AdminCreateInput!): Admin!
  createPage(data: PageCreateInput!): Page!
  createTranslation(data: TranslationCreateInput!): Translation!
  createUser(data: UserCreateInput!): User!
  deleteAdmin(where: AdminWhereUniqueInput!): Admin
  deleteTranslation(where: TranslationWhereUniqueInput!): Translation
  login(password: String, username: String): AdminAuthPayload
  updateAdmin(data: AdminUpdateInput!, where: AdminWhereUniqueInput!): Admin
  updatePage(data: PageUpdateInput!, where: PageWhereUniqueInput!): Page
  updateTranslation(data: TranslationUpdateInput!, where: TranslationWhereUniqueInput!): Translation
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
}

type Page {
  content: String
  content_ar: String
  createdAt: DateTime!
  id: Int!
  slug: String
  slug_ar: String
  title: String
  title_ar: String
  updatedAt: DateTime!
}

type PageConnection {
  aggregate: AggregatePage!
  edges: [PageEdge!]!
  pageInfo: PageInfo!
}

input PageCreateInput {
  content: String
  content_ar: String
  id: Int
  slug: String
  slug_ar: String
  title: String
  title_ar: String
}

type PageEdge {
  cursor: String!
  node: Page!
}

type PageInfo {
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
}

enum PageOrderByInput {
  content_ar_ASC
  content_ar_DESC
  content_ASC
  content_DESC
  createdAt_ASC
  createdAt_DESC
  id_ASC
  id_DESC
  slug_ar_ASC
  slug_ar_DESC
  slug_ASC
  slug_DESC
  title_ar_ASC
  title_ar_DESC
  title_ASC
  title_DESC
  updatedAt_ASC
  updatedAt_DESC
}

input PageUpdateInput {
  content: String
  content_ar: String
  slug: String
  slug_ar: String
  title: String
  title_ar: String
}

input PageWhereInput {
  AND: [PageWhereInput!]
  content: String
  content_ar: String
  content_ar_contains: String
  content_ar_ends_with: String
  content_ar_gt: String
  content_ar_gte: String
  content_ar_in: [String!]
  content_ar_lt: String
  content_ar_lte: String
  content_ar_not: String
  content_ar_not_contains: String
  content_ar_not_ends_with: String
  content_ar_not_in: [String!]
  content_ar_not_starts_with: String
  content_ar_starts_with: String
  content_contains: String
  content_ends_with: String
  content_gt: String
  content_gte: String
  content_in: [String!]
  content_lt: String
  content_lte: String
  content_not: String
  content_not_contains: String
  content_not_ends_with: String
  content_not_in: [String!]
  content_not_starts_with: String
  content_starts_with: String
  createdAt: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdAt_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_not: DateTime
  createdAt_not_in: [DateTime!]
  id: Int
  id_gt: Int
  id_gte: Int
  id_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_not: Int
  id_not_in: [Int!]
  NOT: [PageWhereInput!]
  OR: [PageWhereInput!]
  slug: String
  slug_ar: String
  slug_ar_contains: String
  slug_ar_ends_with: String
  slug_ar_gt: String
  slug_ar_gte: String
  slug_ar_in: [String!]
  slug_ar_lt: String
  slug_ar_lte: String
  slug_ar_not: String
  slug_ar_not_contains: String
  slug_ar_not_ends_with: String
  slug_ar_not_in: [String!]
  slug_ar_not_starts_with: String
  slug_ar_starts_with: String
  slug_contains: String
  slug_ends_with: String
  slug_gt: String
  slug_gte: String
  slug_in: [String!]
  slug_lt: String
  slug_lte: String
  slug_not: String
  slug_not_contains: String
  slug_not_ends_with: String
  slug_not_in: [String!]
  slug_not_starts_with: String
  slug_starts_with: String
  title: String
  title_ar: String
  title_ar_contains: String
  title_ar_ends_with: String
  title_ar_gt: String
  title_ar_gte: String
  title_ar_in: [String!]
  title_ar_lt: String
  title_ar_lte: String
  title_ar_not: String
  title_ar_not_contains: String
  title_ar_not_ends_with: String
  title_ar_not_in: [String!]
  title_ar_not_starts_with: String
  title_ar_starts_with: String
  title_contains: String
  title_ends_with: String
  title_gt: String
  title_gte: String
  title_in: [String!]
  title_lt: String
  title_lte: String
  title_not: String
  title_not_contains: String
  title_not_ends_with: String
  title_not_in: [String!]
  title_not_starts_with: String
  title_starts_with: String
  updatedAt: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_not: DateTime
  updatedAt_not_in: [DateTime!]
}

input PageWhereUniqueInput {
  id: Int
  slug: String
  slug_ar: String
}

type Query {
  admin(where: AdminWhereUniqueInput!): Admin
  admins(after: String, before: String, first: Int, last: Int, orderBy: AdminOrderByInput, skip: Int, where: AdminWhereInput): [Admin!]!
  adminsConnection(after: String, before: String, first: Int, last: Int, orderBy: AdminOrderByInput, skip: Int, where: AdminWhereInput): AdminConnection!
  me: User
  page(where: PageWhereUniqueInput!): Page
  pages(after: String, before: String, first: Int, last: Int, orderBy: PageOrderByInput, skip: Int, where: PageWhereInput): [Page!]!
  pagesConnection(after: String, before: String, first: Int, last: Int, orderBy: PageOrderByInput, skip: Int, where: PageWhereInput): PageConnection!
  translation(where: TranslationWhereUniqueInput!): Translation
  translations(after: String, before: String, first: Int, last: Int, orderBy: TranslationOrderByInput, skip: Int, where: TranslationWhereInput): [Translation!]!
  translationsConnection(after: String, before: String, first: Int, last: Int, orderBy: TranslationOrderByInput, skip: Int, where: TranslationWhereInput): TranslationConnection!
  user(where: UserWhereUniqueInput!): User
  users(after: String, before: String, first: Int, last: Int, orderBy: UserOrderByInput, skip: Int, where: UserWhereInput): [User!]!
  usersConnection(after: String, before: String, first: Int, last: Int, orderBy: UserOrderByInput, skip: Int, where: UserWhereInput): UserConnection!
}

type Translation {
  arabi: String!
  createdAt: DateTime!
  english: String!
  id: Int!
  index: String!
  updatedAt: DateTime!
}

type TranslationConnection {
  aggregate: AggregateTranslation!
  edges: [TranslationEdge!]!
  pageInfo: PageInfo!
}

input TranslationCreateInput {
  arabi: String!
  english: String!
  id: Int
  index: String!
}

type TranslationEdge {
  cursor: String!
  node: Translation!
}

enum TranslationOrderByInput {
  arabi_ASC
  arabi_DESC
  createdAt_ASC
  createdAt_DESC
  english_ASC
  english_DESC
  id_ASC
  id_DESC
  index_ASC
  index_DESC
  updatedAt_ASC
  updatedAt_DESC
}

input TranslationUpdateInput {
  arabi: String
  english: String
  index: String
}

input TranslationWhereInput {
  AND: [TranslationWhereInput!]
  arabi: String
  arabi_contains: String
  arabi_ends_with: String
  arabi_gt: String
  arabi_gte: String
  arabi_in: [String!]
  arabi_lt: String
  arabi_lte: String
  arabi_not: String
  arabi_not_contains: String
  arabi_not_ends_with: String
  arabi_not_in: [String!]
  arabi_not_starts_with: String
  arabi_starts_with: String
  createdAt: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdAt_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_not: DateTime
  createdAt_not_in: [DateTime!]
  english: String
  english_contains: String
  english_ends_with: String
  english_gt: String
  english_gte: String
  english_in: [String!]
  english_lt: String
  english_lte: String
  english_not: String
  english_not_contains: String
  english_not_ends_with: String
  english_not_in: [String!]
  english_not_starts_with: String
  english_starts_with: String
  id: Int
  id_gt: Int
  id_gte: Int
  id_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_not: Int
  id_not_in: [Int!]
  index: String
  index_contains: String
  index_ends_with: String
  index_gt: String
  index_gte: String
  index_in: [String!]
  index_lt: String
  index_lte: String
  index_not: String
  index_not_contains: String
  index_not_ends_with: String
  index_not_in: [String!]
  index_not_starts_with: String
  index_starts_with: String
  NOT: [TranslationWhereInput!]
  OR: [TranslationWhereInput!]
  updatedAt: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_not: DateTime
  updatedAt_not_in: [DateTime!]
}

input TranslationWhereUniqueInput {
  id: Int
}

type User {
  createdAt: DateTime!
  email: String!
  id: Int!
  name: String!
  password: String!
  rememberToken: String
  updatedAt: DateTime!
}

type UserConnection {
  aggregate: AggregateUser!
  edges: [UserEdge!]!
  pageInfo: PageInfo!
}

input UserCreateInput {
  email: String!
  id: Int
  name: String!
  password: String!
  rememberToken: String
}

type UserEdge {
  cursor: String!
  node: User!
}

enum UserOrderByInput {
  createdAt_ASC
  createdAt_DESC
  email_ASC
  email_DESC
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  password_ASC
  password_DESC
  rememberToken_ASC
  rememberToken_DESC
  updatedAt_ASC
  updatedAt_DESC
}

input UserUpdateInput {
  email: String
  name: String
  password: String
  rememberToken: String
}

input UserWhereInput {
  AND: [UserWhereInput!]
  createdAt: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdAt_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_not: DateTime
  createdAt_not_in: [DateTime!]
  email: String
  email_contains: String
  email_ends_with: String
  email_gt: String
  email_gte: String
  email_in: [String!]
  email_lt: String
  email_lte: String
  email_not: String
  email_not_contains: String
  email_not_ends_with: String
  email_not_in: [String!]
  email_not_starts_with: String
  email_starts_with: String
  id: Int
  id_gt: Int
  id_gte: Int
  id_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_not: Int
  id_not_in: [Int!]
  name: String
  name_contains: String
  name_ends_with: String
  name_gt: String
  name_gte: String
  name_in: [String!]
  name_lt: String
  name_lte: String
  name_not: String
  name_not_contains: String
  name_not_ends_with: String
  name_not_in: [String!]
  name_not_starts_with: String
  name_starts_with: String
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  password: String
  password_contains: String
  password_ends_with: String
  password_gt: String
  password_gte: String
  password_in: [String!]
  password_lt: String
  password_lte: String
  password_not: String
  password_not_contains: String
  password_not_ends_with: String
  password_not_in: [String!]
  password_not_starts_with: String
  password_starts_with: String
  rememberToken: String
  rememberToken_contains: String
  rememberToken_ends_with: String
  rememberToken_gt: String
  rememberToken_gte: String
  rememberToken_in: [String!]
  rememberToken_lt: String
  rememberToken_lte: String
  rememberToken_not: String
  rememberToken_not_contains: String
  rememberToken_not_ends_with: String
  rememberToken_not_in: [String!]
  rememberToken_not_starts_with: String
  rememberToken_starts_with: String
  updatedAt: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_not: DateTime
  updatedAt_not_in: [DateTime!]
}

input UserWhereUniqueInput {
  email: String
  id: Int
}
